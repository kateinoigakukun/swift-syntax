
//// Automatically Generated by generate-swiftsyntaxbuilder
//// Do Not Edit Directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import SwiftSyntax

public extension TokenSyntax {
  /// The `associatedtype` keyword
  static var `associatedtype`: Token {
    return .associatedtypeKeyword()
  }
  
  /// The `class` keyword
  static var `class`: Token {
    return .classKeyword()
  }
  
  /// The `deinit` keyword
  static var `deinit`: Token {
    return .deinitKeyword()
  }
  
  /// The `enum` keyword
  static var `enum`: Token {
    return .enumKeyword()
  }
  
  /// The `extension` keyword
  static var `extension`: Token {
    return .extensionKeyword()
  }
  
  /// The `func` keyword
  static var `func`: Token {
    return .funcKeyword()
  }
  
  /// The `import` keyword
  static var `import`: Token {
    return .importKeyword()
  }
  
  /// The `init` keyword
  static var `init`: Token {
    return .initKeyword()
  }
  
  /// The `inout` keyword
  static var `inout`: Token {
    return .inoutKeyword()
  }
  
  /// The `let` keyword
  static var `let`: Token {
    return .letKeyword()
  }
  
  /// The `operator` keyword
  static var `operator`: Token {
    return .operatorKeyword()
  }
  
  /// The `precedencegroup` keyword
  static var `precedencegroup`: Token {
    return .precedencegroupKeyword()
  }
  
  /// The `protocol` keyword
  static var `protocol`: Token {
    return .protocolKeyword()
  }
  
  /// The `struct` keyword
  static var `struct`: Token {
    return .structKeyword()
  }
  
  /// The `subscript` keyword
  static var `subscript`: Token {
    return .subscriptKeyword()
  }
  
  /// The `typealias` keyword
  static var `typealias`: Token {
    return .typealiasKeyword()
  }
  
  /// The `var` keyword
  static var `var`: Token {
    return .varKeyword()
  }
  
  /// The `fileprivate` keyword
  static var `fileprivate`: Token {
    return .fileprivateKeyword()
  }
  
  /// The `internal` keyword
  static var `internal`: Token {
    return .internalKeyword()
  }
  
  /// The `private` keyword
  static var `private`: Token {
    return .privateKeyword()
  }
  
  /// The `public` keyword
  static var `public`: Token {
    return .publicKeyword()
  }
  
  /// The `static` keyword
  static var `static`: Token {
    return .staticKeyword()
  }
  
  /// The `defer` keyword
  static var `defer`: Token {
    return .deferKeyword()
  }
  
  /// The `if` keyword
  static var `if`: Token {
    return .ifKeyword()
  }
  
  /// The `guard` keyword
  static var `guard`: Token {
    return .guardKeyword()
  }
  
  /// The `do` keyword
  static var `do`: Token {
    return .doKeyword()
  }
  
  /// The `repeat` keyword
  static var `repeat`: Token {
    return .repeatKeyword()
  }
  
  /// The `else` keyword
  static var `else`: Token {
    return .elseKeyword()
  }
  
  /// The `for` keyword
  static var `for`: Token {
    return .forKeyword()
  }
  
  /// The `in` keyword
  static var `in`: Token {
    return .inKeyword()
  }
  
  /// The `while` keyword
  static var `while`: Token {
    return .whileKeyword()
  }
  
  /// The `return` keyword
  static var `return`: Token {
    return .returnKeyword()
  }
  
  /// The `break` keyword
  static var `break`: Token {
    return .breakKeyword()
  }
  
  /// The `continue` keyword
  static var `continue`: Token {
    return .continueKeyword()
  }
  
  /// The `fallthrough` keyword
  static var `fallthrough`: Token {
    return .fallthroughKeyword()
  }
  
  /// The `switch` keyword
  static var `switch`: Token {
    return .switchKeyword()
  }
  
  /// The `case` keyword
  static var `case`: Token {
    return .caseKeyword()
  }
  
  /// The `default` keyword
  static var `default`: Token {
    return .defaultKeyword()
  }
  
  /// The `where` keyword
  static var `where`: Token {
    return .whereKeyword()
  }
  
  /// The `catch` keyword
  static var `catch`: Token {
    return .catchKeyword()
  }
  
  /// The `throw` keyword
  static var `throw`: Token {
    return .throwKeyword()
  }
  
  /// The `as` keyword
  static var `as`: Token {
    return .asKeyword()
  }
  
  /// The `Any` keyword
  static var `any`: Token {
    return .anyKeyword()
  }
  
  /// The `false` keyword
  static var `false`: Token {
    return .falseKeyword()
  }
  
  /// The `is` keyword
  static var `is`: Token {
    return .isKeyword()
  }
  
  /// The `nil` keyword
  static var `nil`: Token {
    return .nilKeyword()
  }
  
  /// The `rethrows` keyword
  static var `rethrows`: Token {
    return .rethrowsKeyword()
  }
  
  /// The `super` keyword
  static var `super`: Token {
    return .superKeyword()
  }
  
  /// The `self` keyword
  static var `self`: Token {
    return .selfKeyword()
  }
  
  /// The `Self` keyword
  static var `capitalSelf`: Token {
    return .capitalSelfKeyword()
  }
  
  /// The `true` keyword
  static var `true`: Token {
    return .trueKeyword()
  }
  
  /// The `try` keyword
  static var `try`: Token {
    return .tryKeyword()
  }
  
  /// The `throws` keyword
  static var `throws`: Token {
    return .throwsKeyword()
  }
  
  /// The `_` keyword
  static var `wildcard`: Token {
    return .wildcardKeyword()
  }
  
  /// The `(` token
  static var `leftParen`: TokenSyntax {
    return .leftParenToken()
  }
  
  /// The `)` token
  static var `rightParen`: TokenSyntax {
    return .rightParenToken()
  }
  
  /// The `{` token
  static var `leftBrace`: TokenSyntax {
    return .leftBraceToken()
  }
  
  /// The `}` token
  static var `rightBrace`: TokenSyntax {
    return .rightBraceToken()
  }
  
  /// The `[` token
  static var `leftSquareBracket`: TokenSyntax {
    return .leftSquareBracketToken()
  }
  
  /// The `]` token
  static var `rightSquareBracket`: TokenSyntax {
    return .rightSquareBracketToken()
  }
  
  /// The `<` token
  static var `leftAngle`: TokenSyntax {
    return .leftAngleToken()
  }
  
  /// The `>` token
  static var `rightAngle`: TokenSyntax {
    return .rightAngleToken()
  }
  
  /// The `.` token
  static var `period`: TokenSyntax {
    return .periodToken()
  }
  
  /// The `.` token
  static var `prefixPeriod`: TokenSyntax {
    return .prefixPeriodToken()
  }
  
  /// The `,` token
  static var `comma`: TokenSyntax {
    return .commaToken()
  }
  
  /// The `...` token
  static var `ellipsis`: TokenSyntax {
    return .ellipsisToken()
  }
  
  /// The `:` token
  static var `colon`: TokenSyntax {
    return .colonToken()
  }
  
  /// The `;` token
  static var `semicolon`: TokenSyntax {
    return .semicolonToken()
  }
  
  /// The `=` token
  static var `equal`: TokenSyntax {
    return .equalToken()
  }
  
  /// The `@` token
  static var `atSign`: TokenSyntax {
    return .atSignToken()
  }
  
  /// The `#` token
  static var `pound`: TokenSyntax {
    return .poundToken()
  }
  
  /// The `&` token
  static var `prefixAmpersand`: TokenSyntax {
    return .prefixAmpersandToken()
  }
  
  /// The `->` token
  static var `arrow`: TokenSyntax {
    return .arrowToken()
  }
  
  /// The ``` token
  static var `backtick`: TokenSyntax {
    return .backtickToken()
  }
  
  /// The `\` token
  static var `backslash`: TokenSyntax {
    return .backslashToken()
  }
  
  /// The `!` token
  static var `exclamationMark`: TokenSyntax {
    return .exclamationMarkToken()
  }
  
  /// The `?` token
  static var `postfixQuestionMark`: TokenSyntax {
    return .postfixQuestionMarkToken()
  }
  
  /// The `?` token
  static var `infixQuestionMark`: TokenSyntax {
    return .infixQuestionMarkToken()
  }
  
  /// The `"` token
  static var `stringQuote`: TokenSyntax {
    return .stringQuoteToken()
  }
  
  /// The `'` token
  static var `singleQuote`: TokenSyntax {
    return .singleQuoteToken()
  }
  
  /// The `"""` token
  static var `multilineStringQuote`: TokenSyntax {
    return .multilineStringQuoteToken()
  }
  
  /// The `#keyPath` keyword
  static var `poundKeyPath`: Token {
    return .poundKeyPathKeyword()
  }
  
  /// The `#line` keyword
  static var `poundLine`: Token {
    return .poundLineKeyword()
  }
  
  /// The `#selector` keyword
  static var `poundSelector`: Token {
    return .poundSelectorKeyword()
  }
  
  /// The `#file` keyword
  static var `poundFile`: Token {
    return .poundFileKeyword()
  }
  
  /// The `#fileID` keyword
  static var `poundFileID`: Token {
    return .poundFileIDKeyword()
  }
  
  /// The `#filePath` keyword
  static var `poundFilePath`: Token {
    return .poundFilePathKeyword()
  }
  
  /// The `#column` keyword
  static var `poundColumn`: Token {
    return .poundColumnKeyword()
  }
  
  /// The `#function` keyword
  static var `poundFunction`: Token {
    return .poundFunctionKeyword()
  }
  
  /// The `#dsohandle` keyword
  static var `poundDsohandle`: Token {
    return .poundDsohandleKeyword()
  }
  
  /// The `#assert` keyword
  static var `poundAssert`: Token {
    return .poundAssertKeyword()
  }
  
  /// The `#sourceLocation` keyword
  static var `poundSourceLocation`: Token {
    return .poundSourceLocationKeyword()
  }
  
  /// The `#warning` keyword
  static var `poundWarning`: Token {
    return .poundWarningKeyword()
  }
  
  /// The `#error` keyword
  static var `poundError`: Token {
    return .poundErrorKeyword()
  }
  
  /// The `#if` keyword
  static var `poundIf`: Token {
    return .poundIfKeyword()
  }
  
  /// The `#else` keyword
  static var `poundElse`: Token {
    return .poundElseKeyword()
  }
  
  /// The `#elseif` keyword
  static var `poundElseif`: Token {
    return .poundElseifKeyword()
  }
  
  /// The `#endif` keyword
  static var `poundEndif`: Token {
    return .poundEndifKeyword()
  }
  
  /// The `#available` keyword
  static var `poundAvailable`: Token {
    return .poundAvailableKeyword()
  }
  
  /// The `#unavailable` keyword
  static var `poundUnavailable`: Token {
    return .poundUnavailableKeyword()
  }
  
  /// The `#fileLiteral` keyword
  static var `poundFileLiteral`: Token {
    return .poundFileLiteralKeyword()
  }
  
  /// The `#imageLiteral` keyword
  static var `poundImageLiteral`: Token {
    return .poundImageLiteralKeyword()
  }
  
  /// The `#colorLiteral` keyword
  static var `poundColorLiteral`: Token {
    return .poundColorLiteralKeyword()
  }
  
  /// The `#_hasSymbol` keyword
  static var `poundHasSymbol`: Token {
    return .poundHasSymbolKeyword()
  }
  
  /// The `)` token
  static var `stringInterpolationAnchor`: TokenSyntax {
    return .stringInterpolationAnchorToken()
  }
  
  /// The `yield` token
  static var `yield`: TokenSyntax {
    return .yieldToken()
  }
  
  /// The `eof` token
  static var eof: TokenSyntax {
    return .eof()
  }
  
  /// The `open` contextual token
  static var open: TokenSyntax {
    return .contextualKeyword("open").withTrailingTrivia(.space)
  }
}
