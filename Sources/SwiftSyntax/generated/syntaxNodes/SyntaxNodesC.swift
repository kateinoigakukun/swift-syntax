//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - CanImportExprSyntax

/// ### Children
/// 
///  - `canImportKeyword`: `'canImport'`
///  - `leftParen`: `'('`
///  - `importPath`: `<identifier>`
///  - `versionInfo`: ``CanImportVersionInfoSyntax``?
///  - `rightParen`: `')'`
public struct CanImportExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .canImportExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CanImportExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .canImportExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCanImportKeyword: UnexpectedNodesSyntax? = nil,
      canImportKeyword: TokenSyntax = .keyword(.canImport),
      _ unexpectedBetweenCanImportKeywordAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndImportPath: UnexpectedNodesSyntax? = nil,
      importPath: TokenSyntax,
      _ unexpectedBetweenImportPathAndVersionInfo: UnexpectedNodesSyntax? = nil,
      versionInfo: CanImportVersionInfoSyntax? = nil,
      _ unexpectedBetweenVersionInfoAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCanImportKeyword, 
            canImportKeyword, 
            unexpectedBetweenCanImportKeywordAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndImportPath, 
            importPath, 
            unexpectedBetweenImportPathAndVersionInfo, 
            versionInfo, 
            unexpectedBetweenVersionInfoAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCanImportKeyword?.raw, 
          canImportKeyword.raw, 
          unexpectedBetweenCanImportKeywordAndLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndImportPath?.raw, 
          importPath.raw, 
          unexpectedBetweenImportPathAndVersionInfo?.raw, 
          versionInfo?.raw, 
          unexpectedBetweenVersionInfoAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.canImportExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCanImportKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var canImportKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCanImportKeywordAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndImportPath: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var importPath: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenImportPathAndVersionInfo: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var versionInfo: CanImportVersionInfoSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(CanImportVersionInfoSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenVersionInfoAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCanImportKeyword, 
          \Self.canImportKeyword, 
          \Self.unexpectedBetweenCanImportKeywordAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndImportPath, 
          \Self.importPath, 
          \Self.unexpectedBetweenImportPathAndVersionInfo, 
          \Self.versionInfo, 
          \Self.unexpectedBetweenVersionInfoAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - CanImportVersionInfoSyntax

/// ### Children
/// 
///  - `comma`: `','`
///  - `label`: (`'_version'` | `'_underlyingVersion'`)
///  - `colon`: `':'`
///  - `version`: ``VersionTupleSyntax``
///
/// ### Contained in
/// 
///  - ``CanImportExprSyntax``.``CanImportExprSyntax/versionInfo``
public struct CanImportVersionInfoSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .canImportVersionInfo else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CanImportVersionInfoSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .canImportVersionInfo)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax = .commaToken(),
      _ unexpectedBetweenCommaAndLabel: UnexpectedNodesSyntax? = nil,
      label: TokenSyntax,
      _ unexpectedBetweenLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndVersion: UnexpectedNodesSyntax? = nil,
      version: VersionTupleSyntax,
      _ unexpectedAfterVersion: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeComma, 
            comma, 
            unexpectedBetweenCommaAndLabel, 
            label, 
            unexpectedBetweenLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndVersion, 
            version, 
            unexpectedAfterVersion
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeComma?.raw, 
          comma.raw, 
          unexpectedBetweenCommaAndLabel?.raw, 
          label.raw, 
          unexpectedBetweenLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndVersion?.raw, 
          version.raw, 
          unexpectedAfterVersion?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.canImportVersionInfo,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var comma: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCommaAndLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var label: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndVersion: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var version: VersionTupleSyntax {
    get {
      return VersionTupleSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterVersion: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeComma, 
          \Self.comma, 
          \Self.unexpectedBetweenCommaAndLabel, 
          \Self.label, 
          \Self.unexpectedBetweenLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndVersion, 
          \Self.version, 
          \Self.unexpectedAfterVersion
        ])
  }
}

// MARK: - CatchClauseSyntax

/// ### Children
/// 
///  - `catchKeyword`: `'catch'`
///  - `catchItems`: ``CatchItemListSyntax``
///  - `body`: ``CodeBlockSyntax``
///
/// ### Contained in
/// 
///  - ``CatchClauseListSyntax``
public struct CatchClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .catchClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CatchClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .catchClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCatchKeyword: UnexpectedNodesSyntax? = nil,
      catchKeyword: TokenSyntax = .keyword(.catch),
      _ unexpectedBetweenCatchKeywordAndCatchItems: UnexpectedNodesSyntax? = nil,
      catchItems: CatchItemListSyntax = [],
      _ unexpectedBetweenCatchItemsAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCatchKeyword, 
            catchKeyword, 
            unexpectedBetweenCatchKeywordAndCatchItems, 
            catchItems, 
            unexpectedBetweenCatchItemsAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCatchKeyword?.raw, 
          catchKeyword.raw, 
          unexpectedBetweenCatchKeywordAndCatchItems?.raw, 
          catchItems.raw, 
          unexpectedBetweenCatchItemsAndBody?.raw, 
          body.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.catchClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCatchKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CatchClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var catchKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CatchClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCatchKeywordAndCatchItems: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CatchClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var catchItems: CatchItemListSyntax {
    get {
      return CatchItemListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = CatchClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `catchItems`
  /// collection.
  ///
  /// - param element: The new `CatchItem` to add to the node's
  ///                  `catchItems` collection.
  /// - returns: A copy of the receiver with the provided `CatchItem`
  ///            appended to its `catchItems` collection.
  @available(*, deprecated, message: "Use node.catchItems.append(newElement) instead")
  public func addCatchItem(_ element: CatchItemSyntax) -> CatchClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.catchItemList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return CatchClauseSyntax(newData)
  }
  
  public var unexpectedBetweenCatchItemsAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CatchClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax {
    get {
      return CodeBlockSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = CatchClauseSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CatchClauseSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCatchKeyword, 
          \Self.catchKeyword, 
          \Self.unexpectedBetweenCatchKeywordAndCatchItems, 
          \Self.catchItems, 
          \Self.unexpectedBetweenCatchItemsAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - CatchItemSyntax

/// ### Children
/// 
///  - `pattern`: ``PatternSyntax``?
///  - `whereClause`: ``WhereClauseSyntax``?
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``CatchItemListSyntax``
public struct CatchItemSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .catchItem else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CatchItemSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .catchItem)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePattern: UnexpectedNodesSyntax? = nil,
      pattern: (some PatternSyntaxProtocol)? = PatternSyntax?.none,
      _ unexpectedBetweenPatternAndWhereClause: UnexpectedNodesSyntax? = nil,
      whereClause: WhereClauseSyntax? = nil,
      _ unexpectedBetweenWhereClauseAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforePattern, 
            pattern, 
            unexpectedBetweenPatternAndWhereClause, 
            whereClause, 
            unexpectedBetweenWhereClauseAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforePattern?.raw, 
          pattern?.raw, 
          unexpectedBetweenPatternAndWhereClause?.raw, 
          whereClause?.raw, 
          unexpectedBetweenWhereClauseAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.catchItem,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CatchItemSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var pattern: PatternSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(PatternSyntax.init)
    }
    set(value) {
      self = CatchItemSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPatternAndWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CatchItemSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var whereClause: WhereClauseSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(WhereClauseSyntax.init)
    }
    set(value) {
      self = CatchItemSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenWhereClauseAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CatchItemSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = CatchItemSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CatchItemSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforePattern, 
          \Self.pattern, 
          \Self.unexpectedBetweenPatternAndWhereClause, 
          \Self.whereClause, 
          \Self.unexpectedBetweenWhereClauseAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - ClassDeclSyntax

/// A `class` declaration
/// 
/// An example of a class declaration is
/// 
/// ```swift
/// class SomeClass {
///   let someMember: String
/// 
///   init(someMember: String) {
///     self.someMember = someMember
///   }
/// 
///   func foo() {
///     print(someMember)
///   }
/// 
///   static func bar() -> Int {
///     return 1
///   }
/// }
/// ```
/// 
/// A class declaration may be declared without any members.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `classKeyword`: `'class'`
///  - `name`: `<identifier>`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct ClassDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .classDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClassDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .classDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes attached to the class declaration, such as an `@available` attribute.
  ///   - modifiers: Modifiers attached to the class declaration, such as `public`.
  ///   - classKeyword: The `class` keyword for this declaration.
  ///   - name: The name of the class.
  ///   - genericParameterClause: The generic parameters, if any, of the class declaration.
  ///   - inheritanceClause: The inheritance clause describing one or more conformances for this class declaration.
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters of this class declaration.
  ///   - memberBlock: The members of the class declaration. As class extension declarations may declare additional members, the contents of this member block isn't guaranteed to be a complete list of members for this type.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndClassKeyword: UnexpectedNodesSyntax? = nil,
      classKeyword: TokenSyntax = .keyword(.class),
      _ unexpectedBetweenClassKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndClassKeyword, 
            classKeyword, 
            unexpectedBetweenClassKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndClassKeyword?.raw, 
          classKeyword.raw, 
          unexpectedBetweenClassKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.classDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes attached to the class declaration, such as an `@available` attribute.
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> ClassDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClassDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers attached to the class declaration, such as `public`.
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> ClassDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClassDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndClassKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `class` keyword for this declaration.
  public var classKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenClassKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of the class.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The generic parameters, if any, of the class declaration.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The inheritance clause describing one or more conformances for this class declaration.
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `where` clause that applies to the generic parameters of this class declaration.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The members of the class declaration. As class extension declarations may declare additional members, the contents of this member block isn't guaranteed to be a complete list of members for this type.
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 15, parent: Syntax(self))!)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 15, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndClassKeyword, 
          \Self.classKeyword, 
          \Self.unexpectedBetweenClassKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}

// MARK: - ClassRestrictionTypeSyntax

/// ### Children
/// 
///  - `classKeyword`: `'class'`
public struct ClassRestrictionTypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .classRestrictionType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClassRestrictionTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .classRestrictionType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeClassKeyword: UnexpectedNodesSyntax? = nil,
      classKeyword: TokenSyntax = .keyword(.class),
      _ unexpectedAfterClassKeyword: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeClassKeyword, classKeyword, unexpectedAfterClassKeyword))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeClassKeyword?.raw, classKeyword.raw, unexpectedAfterClassKeyword?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.classRestrictionType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeClassKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassRestrictionTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var classKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClassRestrictionTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterClassKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassRestrictionTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeClassKeyword, \Self.classKeyword, \Self.unexpectedAfterClassKeyword])
  }
}

// MARK: - ClosureCaptureClauseSyntax

/// ### Children
/// 
///  - `leftSquare`: `'['`
///  - `items`: ``ClosureCaptureListSyntax``
///  - `rightSquare`: `']'`
///
/// ### Contained in
/// 
///  - ``ClosureSignatureSyntax``.``ClosureSignatureSyntax/capture``
public struct ClosureCaptureClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureCaptureClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClosureCaptureClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureCaptureClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? = nil,
      leftSquare: TokenSyntax = .leftSquareToken(),
      _ unexpectedBetweenLeftSquareAndItems: UnexpectedNodesSyntax? = nil,
      items: ClosureCaptureListSyntax,
      _ unexpectedBetweenItemsAndRightSquare: UnexpectedNodesSyntax? = nil,
      rightSquare: TokenSyntax = .rightSquareToken(),
      _ unexpectedAfterRightSquare: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftSquare, 
            leftSquare, 
            unexpectedBetweenLeftSquareAndItems, 
            items, 
            unexpectedBetweenItemsAndRightSquare, 
            rightSquare, 
            unexpectedAfterRightSquare
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftSquare?.raw, 
          leftSquare.raw, 
          unexpectedBetweenLeftSquareAndItems?.raw, 
          items.raw, 
          unexpectedBetweenItemsAndRightSquare?.raw, 
          rightSquare.raw, 
          unexpectedAfterRightSquare?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureCaptureClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureCaptureClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftSquareAndItems: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var items: ClosureCaptureListSyntax {
    get {
      return ClosureCaptureListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureCaptureClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `items`
  /// collection.
  ///
  /// - param element: The new `Item` to add to the node's
  ///                  `items` collection.
  /// - returns: A copy of the receiver with the provided `Item`
  ///            appended to its `items` collection.
  @available(*, deprecated, message: "Use node.items.append(newElement) instead")
  public func addItem(_ element: ClosureCaptureSyntax) -> ClosureCaptureClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.closureCaptureList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClosureCaptureClauseSyntax(newData)
  }
  
  public var unexpectedBetweenItemsAndRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureCaptureClauseSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureClauseSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftSquare, 
          \Self.leftSquare, 
          \Self.unexpectedBetweenLeftSquareAndItems, 
          \Self.items, 
          \Self.unexpectedBetweenItemsAndRightSquare, 
          \Self.rightSquare, 
          \Self.unexpectedAfterRightSquare
        ])
  }
}

// MARK: - ClosureCaptureSpecifierSyntax

/// ### Children
/// 
///  - `specifier`: (`'weak'` | `'unowned'`)
///  - `leftParen`: `'('`?
///  - `detail`: (`'safe'` | `'unsafe'`)?
///  - `rightParen`: `')'`?
///
/// ### Contained in
/// 
///  - ``ClosureCaptureSyntax``.``ClosureCaptureSyntax/specifier``
public struct ClosureCaptureSpecifierSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureCaptureSpecifier else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClosureCaptureSpecifierSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureCaptureSpecifier)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeSpecifier: UnexpectedNodesSyntax? = nil,
      specifier: TokenSyntax,
      _ unexpectedBetweenSpecifierAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax? = nil,
      _ unexpectedBetweenLeftParenAndDetail: UnexpectedNodesSyntax? = nil,
      detail: TokenSyntax? = nil,
      _ unexpectedBetweenDetailAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax? = nil,
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeSpecifier, 
            specifier, 
            unexpectedBetweenSpecifierAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndDetail, 
            detail, 
            unexpectedBetweenDetailAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeSpecifier?.raw, 
          specifier.raw, 
          unexpectedBetweenSpecifierAndLeftParen?.raw, 
          leftParen?.raw, 
          unexpectedBetweenLeftParenAndDetail?.raw, 
          detail?.raw, 
          unexpectedBetweenDetailAndRightParen?.raw, 
          rightParen?.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureCaptureSpecifier,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSpecifierSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var specifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureCaptureSpecifierSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSpecifierAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSpecifierSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSpecifierSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndDetail: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSpecifierSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var detail: TokenSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSpecifierSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDetailAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSpecifierSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSpecifierSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSpecifierSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeSpecifier, 
          \Self.specifier, 
          \Self.unexpectedBetweenSpecifierAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndDetail, 
          \Self.detail, 
          \Self.unexpectedBetweenDetailAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - ClosureCaptureSyntax

/// ### Children
/// 
///  - `specifier`: ``ClosureCaptureSpecifierSyntax``?
///  - `name`: `<identifier>`?
///  - `equal`: `'='`?
///  - `expression`: ``ExprSyntax``
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``ClosureCaptureListSyntax``
public struct ClosureCaptureSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureCapture else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClosureCaptureSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureCapture)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeSpecifier: UnexpectedNodesSyntax? = nil,
      specifier: ClosureCaptureSpecifierSyntax? = nil,
      _ unexpectedBetweenSpecifierAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax? = nil,
      _ unexpectedBetweenNameAndEqual: UnexpectedNodesSyntax? = nil,
      equal: TokenSyntax? = nil,
      _ unexpectedBetweenEqualAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeSpecifier, 
            specifier, 
            unexpectedBetweenSpecifierAndName, 
            name, 
            unexpectedBetweenNameAndEqual, 
            equal, 
            unexpectedBetweenEqualAndExpression, 
            expression, 
            unexpectedBetweenExpressionAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeSpecifier?.raw, 
          specifier?.raw, 
          unexpectedBetweenSpecifierAndName?.raw, 
          name?.raw, 
          unexpectedBetweenNameAndEqual?.raw, 
          equal?.raw, 
          unexpectedBetweenEqualAndExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureCapture,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var specifier: ClosureCaptureSpecifierSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(ClosureCaptureSpecifierSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSpecifierAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndEqual: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var equal: TokenSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEqualAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureCaptureSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeSpecifier, 
          \Self.specifier, 
          \Self.unexpectedBetweenSpecifierAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndEqual, 
          \Self.equal, 
          \Self.unexpectedBetweenEqualAndExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - ClosureExprSyntax

/// ### Children
/// 
///  - `leftBrace`: `'{'`
///  - `signature`: ``ClosureSignatureSyntax``?
///  - `statements`: ``CodeBlockItemListSyntax``
///  - `rightBrace`: `'}'`
///
/// ### Contained in
/// 
///  - ``FunctionCallExprSyntax``.``FunctionCallExprSyntax/trailingClosure``
///  - ``MacroExpansionDeclSyntax``.``MacroExpansionDeclSyntax/trailingClosure``
///  - ``MacroExpansionExprSyntax``.``MacroExpansionExprSyntax/trailingClosure``
///  - ``MultipleTrailingClosureElementSyntax``.``MultipleTrailingClosureElementSyntax/closure``
///  - ``SubscriptCallExprSyntax``.``SubscriptCallExprSyntax/trailingClosure``
public struct ClosureExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClosureExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftBrace: UnexpectedNodesSyntax? = nil,
      leftBrace: TokenSyntax = .leftBraceToken(),
      _ unexpectedBetweenLeftBraceAndSignature: UnexpectedNodesSyntax? = nil,
      signature: ClosureSignatureSyntax? = nil,
      _ unexpectedBetweenSignatureAndStatements: UnexpectedNodesSyntax? = nil,
      statements: CodeBlockItemListSyntax,
      _ unexpectedBetweenStatementsAndRightBrace: UnexpectedNodesSyntax? = nil,
      rightBrace: TokenSyntax = .rightBraceToken(),
      _ unexpectedAfterRightBrace: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftBrace, 
            leftBrace, 
            unexpectedBetweenLeftBraceAndSignature, 
            signature, 
            unexpectedBetweenSignatureAndStatements, 
            statements, 
            unexpectedBetweenStatementsAndRightBrace, 
            rightBrace, 
            unexpectedAfterRightBrace
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftBrace?.raw, 
          leftBrace.raw, 
          unexpectedBetweenLeftBraceAndSignature?.raw, 
          signature?.raw, 
          unexpectedBetweenSignatureAndStatements?.raw, 
          statements.raw, 
          unexpectedBetweenStatementsAndRightBrace?.raw, 
          rightBrace.raw, 
          unexpectedAfterRightBrace?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftBraceAndSignature: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var signature: ClosureSignatureSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(ClosureSignatureSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSignatureAndStatements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var statements: CodeBlockItemListSyntax {
    get {
      return CodeBlockItemListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `statements`
  /// collection.
  ///
  /// - param element: The new `Statement` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `Statement`
  ///            appended to its `statements` collection.
  @available(*, deprecated, message: "Use node.statements.append(newElement) instead")
  public func addStatement(_ element: CodeBlockItemSyntax) -> ClosureExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.codeBlockItemList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClosureExprSyntax(newData)
  }
  
  public var unexpectedBetweenStatementsAndRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftBrace, 
          \Self.leftBrace, 
          \Self.unexpectedBetweenLeftBraceAndSignature, 
          \Self.signature, 
          \Self.unexpectedBetweenSignatureAndStatements, 
          \Self.statements, 
          \Self.unexpectedBetweenStatementsAndRightBrace, 
          \Self.rightBrace, 
          \Self.unexpectedAfterRightBrace
        ])
  }
}

// MARK: - ClosureParameterClauseSyntax

/// ### Children
/// 
///  - `leftParen`: `'('`
///  - `parameters`: ``ClosureParameterListSyntax``
///  - `rightParen`: `')'`
///
/// ### Contained in
/// 
///  - ``ClosureSignatureSyntax``.``ClosureSignatureSyntax/parameterClause``
public struct ClosureParameterClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureParameterClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClosureParameterClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureParameterClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - leftParen: The '(' to open the parameter clause.
  ///   - parameters: The actual parameters.
  ///   - rightParen: The ')' to close the parameter clause.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndParameters: UnexpectedNodesSyntax? = nil,
      parameters: ClosureParameterListSyntax,
      _ unexpectedBetweenParametersAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndParameters, 
            parameters, 
            unexpectedBetweenParametersAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndParameters?.raw, 
          parameters.raw, 
          unexpectedBetweenParametersAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureParameterClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The '(' to open the parameter clause.
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureParameterClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndParameters: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The actual parameters.
  public var parameters: ClosureParameterListSyntax {
    get {
      return ClosureParameterListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureParameterClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `parameters`
  /// collection.
  ///
  /// - param element: The new `Parameter` to add to the node's
  ///                  `parameters` collection.
  /// - returns: A copy of the receiver with the provided `Parameter`
  ///            appended to its `parameters` collection.
  @available(*, deprecated, message: "Use node.parameters.append(newElement) instead")
  public func addParameter(_ element: ClosureParameterSyntax) -> ClosureParameterClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.closureParameterList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClosureParameterClauseSyntax(newData)
  }
  
  public var unexpectedBetweenParametersAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The ')' to close the parameter clause.
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureParameterClauseSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterClauseSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndParameters, 
          \Self.parameters, 
          \Self.unexpectedBetweenParametersAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - ClosureParameterSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `firstName`: (`<identifier>` | `'_'`)
///  - `secondName`: (`<identifier>` | `'_'`)?
///  - `colon`: `':'`?
///  - `type`: ``TypeSyntax``?
///  - `ellipsis`: `'...'`?
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``ClosureParameterListSyntax``
public struct ClosureParameterSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureParameter else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClosureParameterSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureParameter)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - firstName: The label of this parameter that will be used when the closure is called.
  ///   - secondName: If this is specified, it is the name by which the parameter can be referenced inside the closure body. If it is `nil`, the closure parameter is referenced by the first name.
  ///   - colon: The colon separating the parameter's name and type.
  ///   - type: The type of the parameter.
  ///   - ellipsis: If the parameter is variadic, `...` to indicate that.
  ///   - trailingComma: If the parameter is followed by another parameter, the comma separating them.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndFirstName: UnexpectedNodesSyntax? = nil,
      firstName: TokenSyntax,
      _ unexpectedBetweenFirstNameAndSecondName: UnexpectedNodesSyntax? = nil,
      secondName: TokenSyntax? = nil,
      _ unexpectedBetweenSecondNameAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax? = nil,
      _ unexpectedBetweenColonAndType: UnexpectedNodesSyntax? = nil,
      type: (some TypeSyntaxProtocol)? = TypeSyntax?.none,
      _ unexpectedBetweenTypeAndEllipsis: UnexpectedNodesSyntax? = nil,
      ellipsis: TokenSyntax? = nil,
      _ unexpectedBetweenEllipsisAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndFirstName, 
            firstName, 
            unexpectedBetweenFirstNameAndSecondName, 
            secondName, 
            unexpectedBetweenSecondNameAndColon, 
            colon, 
            unexpectedBetweenColonAndType, 
            type, 
            unexpectedBetweenTypeAndEllipsis, 
            ellipsis, 
            unexpectedBetweenEllipsisAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndFirstName?.raw, 
          firstName.raw, 
          unexpectedBetweenFirstNameAndSecondName?.raw, 
          secondName?.raw, 
          unexpectedBetweenSecondNameAndColon?.raw, 
          colon?.raw, 
          unexpectedBetweenColonAndType?.raw, 
          type?.raw, 
          unexpectedBetweenTypeAndEllipsis?.raw, 
          ellipsis?.raw, 
          unexpectedBetweenEllipsisAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureParameter,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> ClosureParameterSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClosureParameterSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> ClosureParameterSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClosureParameterSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndFirstName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The label of this parameter that will be used when the closure is called.
  public var firstName: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFirstNameAndSecondName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If this is specified, it is the name by which the parameter can be referenced inside the closure body. If it is `nil`, the closure parameter is referenced by the first name.
  public var secondName: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSecondNameAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The colon separating the parameter's name and type.
  public var colon: TokenSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The type of the parameter.
  public var type: TypeSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(TypeSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypeAndEllipsis: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the parameter is variadic, `...` to indicate that.
  public var ellipsis: TokenSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEllipsisAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the parameter is followed by another parameter, the comma separating them.
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureParameterSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndFirstName, 
          \Self.firstName, 
          \Self.unexpectedBetweenFirstNameAndSecondName, 
          \Self.secondName, 
          \Self.unexpectedBetweenSecondNameAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndType, 
          \Self.type, 
          \Self.unexpectedBetweenTypeAndEllipsis, 
          \Self.ellipsis, 
          \Self.unexpectedBetweenEllipsisAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - ClosureShorthandParameterSyntax

/// ### Children
/// 
///  - `name`: (`<identifier>` | `'_'`)
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``ClosureShorthandParameterListSyntax``
public struct ClosureShorthandParameterSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureShorthandParameter else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClosureShorthandParameterSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureShorthandParameter)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeName, 
            name, 
            unexpectedBetweenNameAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureShorthandParameter,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureShorthandParameterSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureShorthandParameterSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureShorthandParameterSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ClosureShorthandParameterSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureShorthandParameterSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - ClosureSignatureSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `capture`: ``ClosureCaptureClauseSyntax``?
///  - `parameterClause`: (``ClosureShorthandParameterListSyntax`` | ``ClosureParameterClauseSyntax``)?
///  - `effectSpecifiers`: ``TypeEffectSpecifiersSyntax``?
///  - `returnClause`: ``ReturnClauseSyntax``?
///  - `inKeyword`: `'in'`
///
/// ### Contained in
/// 
///  - ``ClosureExprSyntax``.``ClosureExprSyntax/signature``
public struct ClosureSignatureSyntax: SyntaxProtocol, SyntaxHashable {
  public enum ParameterClause: SyntaxChildChoices, SyntaxHashable {
    case `simpleInput`(ClosureShorthandParameterListSyntax)
    case `parameterClause`(ClosureParameterClauseSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .simpleInput(let node):
        return node._syntaxNode
      case .parameterClause(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: ClosureShorthandParameterListSyntax) {
      self = .simpleInput(node)
    }
    
    public init(_ node: ClosureParameterClauseSyntax) {
      self = .parameterClause(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(ClosureShorthandParameterListSyntax.self) {
        self = .simpleInput(node)
        return
      }
      if let node = node.as(ClosureParameterClauseSyntax.self) {
        self = .parameterClause(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(ClosureShorthandParameterListSyntax.self), .node(ClosureParameterClauseSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureSignature else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClosureSignatureSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureSignature)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndCapture: UnexpectedNodesSyntax? = nil,
      capture: ClosureCaptureClauseSyntax? = nil,
      _ unexpectedBetweenCaptureAndParameterClause: UnexpectedNodesSyntax? = nil,
      parameterClause: ParameterClause? = nil,
      _ unexpectedBetweenParameterClauseAndEffectSpecifiers: UnexpectedNodesSyntax? = nil,
      effectSpecifiers: TypeEffectSpecifiersSyntax? = nil,
      _ unexpectedBetweenEffectSpecifiersAndReturnClause: UnexpectedNodesSyntax? = nil,
      returnClause: ReturnClauseSyntax? = nil,
      _ unexpectedBetweenReturnClauseAndInKeyword: UnexpectedNodesSyntax? = nil,
      inKeyword: TokenSyntax = .keyword(.in),
      _ unexpectedAfterInKeyword: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndCapture, 
            capture, 
            unexpectedBetweenCaptureAndParameterClause, 
            parameterClause, 
            unexpectedBetweenParameterClauseAndEffectSpecifiers, 
            effectSpecifiers, 
            unexpectedBetweenEffectSpecifiersAndReturnClause, 
            returnClause, 
            unexpectedBetweenReturnClauseAndInKeyword, 
            inKeyword, 
            unexpectedAfterInKeyword
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndCapture?.raw, 
          capture?.raw, 
          unexpectedBetweenCaptureAndParameterClause?.raw, 
          parameterClause?.raw, 
          unexpectedBetweenParameterClauseAndEffectSpecifiers?.raw, 
          effectSpecifiers?.raw, 
          unexpectedBetweenEffectSpecifiersAndReturnClause?.raw, 
          returnClause?.raw, 
          unexpectedBetweenReturnClauseAndInKeyword?.raw, 
          inKeyword.raw, 
          unexpectedAfterInKeyword?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureSignature,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> ClosureSignatureSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClosureSignatureSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndCapture: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var capture: ClosureCaptureClauseSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(ClosureCaptureClauseSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCaptureAndParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var parameterClause: ParameterClause? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(ParameterClause.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenParameterClauseAndEffectSpecifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var effectSpecifiers: TypeEffectSpecifiersSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TypeEffectSpecifiersSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEffectSpecifiersAndReturnClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var returnClause: ReturnClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(ReturnClauseSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenReturnClauseAndInKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var inKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterInKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureSignatureSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndCapture, 
          \Self.capture, 
          \Self.unexpectedBetweenCaptureAndParameterClause, 
          \Self.parameterClause, 
          \Self.unexpectedBetweenParameterClauseAndEffectSpecifiers, 
          \Self.effectSpecifiers, 
          \Self.unexpectedBetweenEffectSpecifiersAndReturnClause, 
          \Self.returnClause, 
          \Self.unexpectedBetweenReturnClauseAndInKeyword, 
          \Self.inKeyword, 
          \Self.unexpectedAfterInKeyword
        ])
  }
}

// MARK: - CodeBlockItemSyntax

/// A CodeBlockItem is any Syntax node that appears on its own line inside a CodeBlock.
///
/// ### Children
/// 
///  - `item`: (``DeclSyntax`` | ``StmtSyntax`` | ``ExprSyntax``)
///  - `semicolon`: `';'`?
///
/// ### Contained in
/// 
///  - ``CodeBlockItemListSyntax``
public struct CodeBlockItemSyntax: SyntaxProtocol, SyntaxHashable {
  public enum Item: SyntaxChildChoices, SyntaxHashable {
    case `decl`(DeclSyntax)
    case `stmt`(StmtSyntax)
    case `expr`(ExprSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .decl(let node):
        return node._syntaxNode
      case .stmt(let node):
        return node._syntaxNode
      case .expr(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: some DeclSyntaxProtocol) {
      self = .decl(DeclSyntax(node))
    }
    
    public init(_ node: some StmtSyntaxProtocol) {
      self = .stmt(StmtSyntax(node))
    }
    
    public init(_ node: some ExprSyntaxProtocol) {
      self = .expr(ExprSyntax(node))
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(DeclSyntax.self) {
        self = .decl(node)
        return
      }
      if let node = node.as(StmtSyntax.self) {
        self = .stmt(node)
        return
      }
      if let node = node.as(ExprSyntax.self) {
        self = .expr(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(DeclSyntax.self), .node(StmtSyntax.self), .node(ExprSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .codeBlockItem else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CodeBlockItemSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .codeBlockItem)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - item: The underlying node inside the code block.
  ///   - semicolon: If present, the trailing semicolon at the end of the item.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeItem: UnexpectedNodesSyntax? = nil,
      item: Item,
      _ unexpectedBetweenItemAndSemicolon: UnexpectedNodesSyntax? = nil,
      semicolon: TokenSyntax? = nil,
      _ unexpectedAfterSemicolon: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeItem, 
            item, 
            unexpectedBetweenItemAndSemicolon, 
            semicolon, 
            unexpectedAfterSemicolon
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeItem?.raw, 
          item.raw, 
          unexpectedBetweenItemAndSemicolon?.raw, 
          semicolon?.raw, 
          unexpectedAfterSemicolon?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.codeBlockItem,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeItem: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CodeBlockItemSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The underlying node inside the code block.
  public var item: Item {
    get {
      return Item(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CodeBlockItemSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenItemAndSemicolon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CodeBlockItemSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If present, the trailing semicolon at the end of the item.
  public var semicolon: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = CodeBlockItemSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterSemicolon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CodeBlockItemSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeItem, 
          \Self.item, 
          \Self.unexpectedBetweenItemAndSemicolon, 
          \Self.semicolon, 
          \Self.unexpectedAfterSemicolon
        ])
  }
}

// MARK: - CodeBlockSyntax

/// ### Children
/// 
///  - `leftBrace`: `'{'`
///  - `statements`: ``CodeBlockItemListSyntax``
///  - `rightBrace`: `'}'`
///
/// ### Contained in
/// 
///  - ``AccessorDeclSyntax``.``AccessorDeclSyntax/body``
///  - ``CatchClauseSyntax``.``CatchClauseSyntax/body``
///  - ``DeferStmtSyntax``.``DeferStmtSyntax/body``
///  - ``DeinitializerDeclSyntax``.``DeinitializerDeclSyntax/body``
///  - ``DoStmtSyntax``.``DoStmtSyntax/body``
///  - ``ForStmtSyntax``.``ForStmtSyntax/body``
///  - ``FunctionDeclSyntax``.``FunctionDeclSyntax/body``
///  - ``GuardStmtSyntax``.``GuardStmtSyntax/body``
///  - ``IfExprSyntax``.``IfExprSyntax/body``
///  - ``IfExprSyntax``.``IfExprSyntax/elseBody``
///  - ``InitializerDeclSyntax``.``InitializerDeclSyntax/body``
///  - ``RepeatStmtSyntax``.``RepeatStmtSyntax/body``
///  - ``WhileStmtSyntax``.``WhileStmtSyntax/body``
public struct CodeBlockSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .codeBlock else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CodeBlockSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .codeBlock)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftBrace: UnexpectedNodesSyntax? = nil,
      leftBrace: TokenSyntax = .leftBraceToken(),
      _ unexpectedBetweenLeftBraceAndStatements: UnexpectedNodesSyntax? = nil,
      statements: CodeBlockItemListSyntax,
      _ unexpectedBetweenStatementsAndRightBrace: UnexpectedNodesSyntax? = nil,
      rightBrace: TokenSyntax = .rightBraceToken(),
      _ unexpectedAfterRightBrace: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftBrace, 
            leftBrace, 
            unexpectedBetweenLeftBraceAndStatements, 
            statements, 
            unexpectedBetweenStatementsAndRightBrace, 
            rightBrace, 
            unexpectedAfterRightBrace
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftBrace?.raw, 
          leftBrace.raw, 
          unexpectedBetweenLeftBraceAndStatements?.raw, 
          statements.raw, 
          unexpectedBetweenStatementsAndRightBrace?.raw, 
          rightBrace.raw, 
          unexpectedAfterRightBrace?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.codeBlock,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CodeBlockSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CodeBlockSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftBraceAndStatements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CodeBlockSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var statements: CodeBlockItemListSyntax {
    get {
      return CodeBlockItemListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = CodeBlockSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `statements`
  /// collection.
  ///
  /// - param element: The new `Statement` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `Statement`
  ///            appended to its `statements` collection.
  @available(*, deprecated, message: "Use node.statements.append(newElement) instead")
  public func addStatement(_ element: CodeBlockItemSyntax) -> CodeBlockSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.codeBlockItemList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return CodeBlockSyntax(newData)
  }
  
  public var unexpectedBetweenStatementsAndRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CodeBlockSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = CodeBlockSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CodeBlockSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftBrace, 
          \Self.leftBrace, 
          \Self.unexpectedBetweenLeftBraceAndStatements, 
          \Self.statements, 
          \Self.unexpectedBetweenStatementsAndRightBrace, 
          \Self.rightBrace, 
          \Self.unexpectedAfterRightBrace
        ])
  }
}

// MARK: - CompositionTypeElementSyntax

/// ### Children
/// 
///  - `type`: ``TypeSyntax``
///  - `ampersand`: ``TokenSyntax``?
///
/// ### Contained in
/// 
///  - ``CompositionTypeElementListSyntax``
public struct CompositionTypeElementSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .compositionTypeElement else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CompositionTypeElementSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .compositionTypeElement)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedBetweenTypeAndAmpersand: UnexpectedNodesSyntax? = nil,
      ampersand: TokenSyntax? = nil,
      _ unexpectedAfterAmpersand: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeType, 
            type, 
            unexpectedBetweenTypeAndAmpersand, 
            ampersand, 
            unexpectedAfterAmpersand
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeType?.raw, 
          type.raw, 
          unexpectedBetweenTypeAndAmpersand?.raw, 
          ampersand?.raw, 
          unexpectedAfterAmpersand?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.compositionTypeElement,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CompositionTypeElementSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var type: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CompositionTypeElementSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypeAndAmpersand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CompositionTypeElementSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var ampersand: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = CompositionTypeElementSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterAmpersand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CompositionTypeElementSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeType, 
          \Self.type, 
          \Self.unexpectedBetweenTypeAndAmpersand, 
          \Self.ampersand, 
          \Self.unexpectedAfterAmpersand
        ])
  }
}

// MARK: - CompositionTypeSyntax

/// ### Children
/// 
///  - `elements`: ``CompositionTypeElementListSyntax``
public struct CompositionTypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .compositionType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CompositionTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .compositionType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeElements: UnexpectedNodesSyntax? = nil,
      elements: CompositionTypeElementListSyntax,
      _ unexpectedAfterElements: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeElements, elements, unexpectedAfterElements))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeElements?.raw, elements.raw, unexpectedAfterElements?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.compositionType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CompositionTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elements: CompositionTypeElementListSyntax {
    get {
      return CompositionTypeElementListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CompositionTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  ///
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  @available(*, deprecated, message: "Use node.elements.append(newElement) instead")
  public func addElement(_ element: CompositionTypeElementSyntax) -> CompositionTypeSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.compositionTypeElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return CompositionTypeSyntax(newData)
  }
  
  public var unexpectedAfterElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CompositionTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeElements, \Self.elements, \Self.unexpectedAfterElements])
  }
}

// MARK: - ConditionElementSyntax

/// ### Children
/// 
///  - `condition`: (``ExprSyntax`` | ``AvailabilityConditionSyntax`` | ``MatchingPatternConditionSyntax`` | ``OptionalBindingConditionSyntax``)
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``ConditionElementListSyntax``
public struct ConditionElementSyntax: SyntaxProtocol, SyntaxHashable {
  public enum Condition: SyntaxChildChoices, SyntaxHashable {
    case `expression`(ExprSyntax)
    case `availability`(AvailabilityConditionSyntax)
    case `matchingPattern`(MatchingPatternConditionSyntax)
    case `optionalBinding`(OptionalBindingConditionSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .expression(let node):
        return node._syntaxNode
      case .availability(let node):
        return node._syntaxNode
      case .matchingPattern(let node):
        return node._syntaxNode
      case .optionalBinding(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: some ExprSyntaxProtocol) {
      self = .expression(ExprSyntax(node))
    }
    
    public init(_ node: AvailabilityConditionSyntax) {
      self = .availability(node)
    }
    
    public init(_ node: MatchingPatternConditionSyntax) {
      self = .matchingPattern(node)
    }
    
    public init(_ node: OptionalBindingConditionSyntax) {
      self = .optionalBinding(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(ExprSyntax.self) {
        self = .expression(node)
        return
      }
      if let node = node.as(AvailabilityConditionSyntax.self) {
        self = .availability(node)
        return
      }
      if let node = node.as(MatchingPatternConditionSyntax.self) {
        self = .matchingPattern(node)
        return
      }
      if let node = node.as(OptionalBindingConditionSyntax.self) {
        self = .optionalBinding(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
            .node(ExprSyntax.self), 
            .node(AvailabilityConditionSyntax.self), 
            .node(MatchingPatternConditionSyntax.self), 
            .node(OptionalBindingConditionSyntax.self)
          ])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .conditionElement else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ConditionElementSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .conditionElement)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCondition: UnexpectedNodesSyntax? = nil,
      condition: Condition,
      _ unexpectedBetweenConditionAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCondition, 
            condition, 
            unexpectedBetweenConditionAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCondition?.raw, 
          condition.raw, 
          unexpectedBetweenConditionAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.conditionElement,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCondition: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConditionElementSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var condition: Condition {
    get {
      return Condition(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ConditionElementSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenConditionAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConditionElementSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ConditionElementSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConditionElementSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCondition, 
          \Self.condition, 
          \Self.unexpectedBetweenConditionAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - ConformanceRequirementSyntax

/// ### Children
/// 
///  - `leftType`: ``TypeSyntax``
///  - `colon`: `':'`
///  - `rightType`: ``TypeSyntax``
///
/// ### Contained in
/// 
///  - ``GenericRequirementSyntax``.``GenericRequirementSyntax/requirement``
public struct ConformanceRequirementSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .conformanceRequirement else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ConformanceRequirementSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .conformanceRequirement)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftType: UnexpectedNodesSyntax? = nil,
      leftType: some TypeSyntaxProtocol,
      _ unexpectedBetweenLeftTypeAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndRightType: UnexpectedNodesSyntax? = nil,
      rightType: some TypeSyntaxProtocol,
      _ unexpectedAfterRightType: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftType, 
            leftType, 
            unexpectedBetweenLeftTypeAndColon, 
            colon, 
            unexpectedBetweenColonAndRightType, 
            rightType, 
            unexpectedAfterRightType
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftType?.raw, 
          leftType.raw, 
          unexpectedBetweenLeftTypeAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndRightType?.raw, 
          rightType.raw, 
          unexpectedAfterRightType?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.conformanceRequirement,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConformanceRequirementSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftType: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ConformanceRequirementSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftTypeAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConformanceRequirementSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ConformanceRequirementSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndRightType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConformanceRequirementSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightType: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ConformanceRequirementSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConformanceRequirementSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftType, 
          \Self.leftType, 
          \Self.unexpectedBetweenLeftTypeAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndRightType, 
          \Self.rightType, 
          \Self.unexpectedAfterRightType
        ])
  }
}

// MARK: - ConsumeExprSyntax

/// ### Children
/// 
///  - `consumeKeyword`: (`'_move'` | `'consume'`)
///  - `expression`: ``ExprSyntax``
public struct ConsumeExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .consumeExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ConsumeExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .consumeExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeConsumeKeyword: UnexpectedNodesSyntax? = nil,
      consumeKeyword: TokenSyntax,
      _ unexpectedBetweenConsumeKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeConsumeKeyword, 
            consumeKeyword, 
            unexpectedBetweenConsumeKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeConsumeKeyword?.raw, 
          consumeKeyword.raw, 
          unexpectedBetweenConsumeKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.consumeExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeConsumeKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConsumeExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var consumeKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ConsumeExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenConsumeKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConsumeExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ConsumeExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConsumeExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeConsumeKeyword, 
          \Self.consumeKeyword, 
          \Self.unexpectedBetweenConsumeKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - ContinueStmtSyntax

/// ### Children
/// 
///  - `continueKeyword`: `'continue'`
///  - `label`: `<identifier>`?
public struct ContinueStmtSyntax: StmtSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .continueStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ContinueStmtSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .continueStmt)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeContinueKeyword: UnexpectedNodesSyntax? = nil,
      continueKeyword: TokenSyntax = .keyword(.continue),
      _ unexpectedBetweenContinueKeywordAndLabel: UnexpectedNodesSyntax? = nil,
      label: TokenSyntax? = nil,
      _ unexpectedAfterLabel: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeContinueKeyword, 
            continueKeyword, 
            unexpectedBetweenContinueKeywordAndLabel, 
            label, 
            unexpectedAfterLabel
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeContinueKeyword?.raw, 
          continueKeyword.raw, 
          unexpectedBetweenContinueKeywordAndLabel?.raw, 
          label?.raw, 
          unexpectedAfterLabel?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.continueStmt,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeContinueKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ContinueStmtSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var continueKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ContinueStmtSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenContinueKeywordAndLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ContinueStmtSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var label: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ContinueStmtSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ContinueStmtSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeContinueKeyword, 
          \Self.continueKeyword, 
          \Self.unexpectedBetweenContinueKeywordAndLabel, 
          \Self.label, 
          \Self.unexpectedAfterLabel
        ])
  }
}

// MARK: - ConventionAttributeArgumentsSyntax

/// The arguments for the '@convention(...)'.
///
/// ### Children
/// 
///  - `conventionLabel`: `<identifier>`
///  - `comma`: `','`?
///  - `cTypeLabel`: `'cType'`?
///  - `colon`: `':'`?
///  - `cTypeString`: ``StringLiteralExprSyntax``?
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct ConventionAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .conventionAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ConventionAttributeArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .conventionAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - conventionLabel: The convention label.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeConventionLabel: UnexpectedNodesSyntax? = nil,
      conventionLabel: TokenSyntax,
      _ unexpectedBetweenConventionLabelAndComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax? = nil,
      _ unexpectedBetweenCommaAndCTypeLabel: UnexpectedNodesSyntax? = nil,
      cTypeLabel: TokenSyntax? = nil,
      _ unexpectedBetweenCTypeLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax? = nil,
      _ unexpectedBetweenColonAndCTypeString: UnexpectedNodesSyntax? = nil,
      cTypeString: StringLiteralExprSyntax? = nil,
      _ unexpectedAfterCTypeString: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeConventionLabel, 
            conventionLabel, 
            unexpectedBetweenConventionLabelAndComma, 
            comma, 
            unexpectedBetweenCommaAndCTypeLabel, 
            cTypeLabel, 
            unexpectedBetweenCTypeLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndCTypeString, 
            cTypeString, 
            unexpectedAfterCTypeString
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeConventionLabel?.raw, 
          conventionLabel.raw, 
          unexpectedBetweenConventionLabelAndComma?.raw, 
          comma?.raw, 
          unexpectedBetweenCommaAndCTypeLabel?.raw, 
          cTypeLabel?.raw, 
          unexpectedBetweenCTypeLabelAndColon?.raw, 
          colon?.raw, 
          unexpectedBetweenColonAndCTypeString?.raw, 
          cTypeString?.raw, 
          unexpectedAfterCTypeString?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.conventionAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeConventionLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The convention label.
  public var conventionLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenConventionLabelAndComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var comma: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCommaAndCTypeLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var cTypeLabel: TokenSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCTypeLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndCTypeString: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var cTypeString: StringLiteralExprSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(StringLiteralExprSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterCTypeString: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionAttributeArgumentsSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeConventionLabel, 
          \Self.conventionLabel, 
          \Self.unexpectedBetweenConventionLabelAndComma, 
          \Self.comma, 
          \Self.unexpectedBetweenCommaAndCTypeLabel, 
          \Self.cTypeLabel, 
          \Self.unexpectedBetweenCTypeLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndCTypeString, 
          \Self.cTypeString, 
          \Self.unexpectedAfterCTypeString
        ])
  }
}

// MARK: - ConventionWitnessMethodAttributeArgumentsSyntax

/// The arguments for the '@convention(witness_method: ...)'.
///
/// ### Children
/// 
///  - `witnessMethodLabel`: `'witness_method'`
///  - `colon`: `':'`
///  - `protocolName`: `<identifier>`
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct ConventionWitnessMethodAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .conventionWitnessMethodAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ConventionWitnessMethodAttributeArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .conventionWitnessMethodAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWitnessMethodLabel: UnexpectedNodesSyntax? = nil,
      witnessMethodLabel: TokenSyntax = .keyword(.witness_method),
      _ unexpectedBetweenWitnessMethodLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndProtocolName: UnexpectedNodesSyntax? = nil,
      protocolName: TokenSyntax,
      _ unexpectedAfterProtocolName: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeWitnessMethodLabel, 
            witnessMethodLabel, 
            unexpectedBetweenWitnessMethodLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndProtocolName, 
            protocolName, 
            unexpectedAfterProtocolName
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeWitnessMethodLabel?.raw, 
          witnessMethodLabel.raw, 
          unexpectedBetweenWitnessMethodLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndProtocolName?.raw, 
          protocolName.raw, 
          unexpectedAfterProtocolName?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.conventionWitnessMethodAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeWitnessMethodLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionWitnessMethodAttributeArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var witnessMethodLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ConventionWitnessMethodAttributeArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenWitnessMethodLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionWitnessMethodAttributeArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ConventionWitnessMethodAttributeArgumentsSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndProtocolName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionWitnessMethodAttributeArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var protocolName: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ConventionWitnessMethodAttributeArgumentsSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterProtocolName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ConventionWitnessMethodAttributeArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeWitnessMethodLabel, 
          \Self.witnessMethodLabel, 
          \Self.unexpectedBetweenWitnessMethodLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndProtocolName, 
          \Self.protocolName, 
          \Self.unexpectedAfterProtocolName
        ])
  }
}

// MARK: - CopyExprSyntax

/// ### Children
/// 
///  - `copyKeyword`: `'copy'`
///  - `expression`: ``ExprSyntax``
public struct CopyExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .copyExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CopyExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .copyExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCopyKeyword: UnexpectedNodesSyntax? = nil,
      copyKeyword: TokenSyntax = .keyword(.copy),
      _ unexpectedBetweenCopyKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCopyKeyword, 
            copyKeyword, 
            unexpectedBetweenCopyKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCopyKeyword?.raw, 
          copyKeyword.raw, 
          unexpectedBetweenCopyKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.copyExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCopyKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var copyKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCopyKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCopyKeyword, 
          \Self.copyKeyword, 
          \Self.unexpectedBetweenCopyKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}
