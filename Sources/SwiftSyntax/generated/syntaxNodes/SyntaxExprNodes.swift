//// Automatically generated by generate-swiftsyntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - ArrayExprSyntax

/// ### Children
/// 
///  - `leftSquare`: `'['`
///  - `elements`: ``ArrayElementListSyntax``
///  - `rightSquare`: `']'`
public struct ArrayExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .arrayExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ArrayExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .arrayExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? = nil,
      leftSquare: TokenSyntax = .leftSquareToken(),
      _ unexpectedBetweenLeftSquareAndElements: UnexpectedNodesSyntax? = nil,
      elements: ArrayElementListSyntax,
      _ unexpectedBetweenElementsAndRightSquare: UnexpectedNodesSyntax? = nil,
      rightSquare: TokenSyntax = .rightSquareToken(),
      _ unexpectedAfterRightSquare: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftSquare, 
            leftSquare, 
            unexpectedBetweenLeftSquareAndElements, 
            elements, 
            unexpectedBetweenElementsAndRightSquare, 
            rightSquare, 
            unexpectedAfterRightSquare
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftSquare?.raw, 
          leftSquare.raw, 
          unexpectedBetweenLeftSquareAndElements?.raw, 
          elements.raw, 
          unexpectedBetweenElementsAndRightSquare?.raw, 
          rightSquare.raw, 
          unexpectedAfterRightSquare?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.arrayExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftSquareAndElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elements: ArrayElementListSyntax {
    get {
      return ArrayElementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: ArrayElementSyntax) -> ArrayExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.arrayElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ArrayExprSyntax(newData)
  }
  
  public var unexpectedBetweenElementsAndRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrayExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftSquare, 
          \Self.leftSquare, 
          \Self.unexpectedBetweenLeftSquareAndElements, 
          \Self.elements, 
          \Self.unexpectedBetweenElementsAndRightSquare, 
          \Self.rightSquare, 
          \Self.unexpectedAfterRightSquare
        ])
  }
}

// MARK: - ArrowExprSyntax

/// ### Children
/// 
///  - `effectSpecifiers`: ``TypeEffectSpecifiersSyntax``?
///  - `arrow`: `'->'`
public struct ArrowExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .arrowExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ArrowExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .arrowExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeEffectSpecifiers: UnexpectedNodesSyntax? = nil,
      effectSpecifiers: TypeEffectSpecifiersSyntax? = nil,
      _ unexpectedBetweenEffectSpecifiersAndArrow: UnexpectedNodesSyntax? = nil,
      arrow: TokenSyntax = .arrowToken(),
      _ unexpectedAfterArrow: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeEffectSpecifiers, 
            effectSpecifiers, 
            unexpectedBetweenEffectSpecifiersAndArrow, 
            arrow, 
            unexpectedAfterArrow
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeEffectSpecifiers?.raw, 
          effectSpecifiers?.raw, 
          unexpectedBetweenEffectSpecifiersAndArrow?.raw, 
          arrow.raw, 
          unexpectedAfterArrow?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.arrowExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeEffectSpecifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var effectSpecifiers: TypeEffectSpecifiersSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TypeEffectSpecifiersSyntax.init)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEffectSpecifiersAndArrow: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arrow: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterArrow: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ArrowExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeEffectSpecifiers, 
          \Self.effectSpecifiers, 
          \Self.unexpectedBetweenEffectSpecifiersAndArrow, 
          \Self.arrow, 
          \Self.unexpectedAfterArrow
        ])
  }
}

// MARK: - AsExprSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `asKeyword`: `'as'`
///  - `questionOrExclamationMark`: (`'?'` | `'!'`)?
///  - `typeName`: ``TypeSyntax``
public struct AsExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .asExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``AsExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .asExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndAsKeyword: UnexpectedNodesSyntax? = nil,
      asKeyword: TokenSyntax = .keyword(.as),
      _ unexpectedBetweenAsKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      questionOrExclamationMark: TokenSyntax? = nil,
      _ unexpectedBetweenQuestionOrExclamationMarkAndTypeName: UnexpectedNodesSyntax? = nil,
      typeName: some TypeSyntaxProtocol,
      _ unexpectedAfterTypeName: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndAsKeyword, 
            asKeyword, 
            unexpectedBetweenAsKeywordAndQuestionOrExclamationMark, 
            questionOrExclamationMark, 
            unexpectedBetweenQuestionOrExclamationMarkAndTypeName, 
            typeName, 
            unexpectedAfterTypeName
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndAsKeyword?.raw, 
          asKeyword.raw, 
          unexpectedBetweenAsKeywordAndQuestionOrExclamationMark?.raw, 
          questionOrExclamationMark?.raw, 
          unexpectedBetweenQuestionOrExclamationMarkAndTypeName?.raw, 
          typeName.raw, 
          unexpectedAfterTypeName?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.asExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndAsKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var asKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAsKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenQuestionOrExclamationMarkAndTypeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var typeName: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTypeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AsExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndAsKeyword, 
          \Self.asKeyword, 
          \Self.unexpectedBetweenAsKeywordAndQuestionOrExclamationMark, 
          \Self.questionOrExclamationMark, 
          \Self.unexpectedBetweenQuestionOrExclamationMarkAndTypeName, 
          \Self.typeName, 
          \Self.unexpectedAfterTypeName
        ])
  }
}

// MARK: - AssignmentExprSyntax

/// ### Children
/// 
///  - `equal`: `'='`
public struct AssignmentExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .assignmentExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``AssignmentExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .assignmentExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeEqual: UnexpectedNodesSyntax? = nil,
      equal: TokenSyntax = .equalToken(),
      _ unexpectedAfterEqual: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeEqual, equal, unexpectedAfterEqual))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeEqual?.raw, equal.raw, unexpectedAfterEqual?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.assignmentExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeEqual: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssignmentExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var equal: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = AssignmentExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterEqual: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssignmentExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeEqual, \Self.equal, \Self.unexpectedAfterEqual])
  }
}

// MARK: - AwaitExprSyntax

/// ### Children
/// 
///  - `awaitKeyword`: `'await'`
///  - `expression`: ``ExprSyntax``
public struct AwaitExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .awaitExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``AwaitExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .awaitExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAwaitKeyword: UnexpectedNodesSyntax? = nil,
      awaitKeyword: TokenSyntax = .keyword(.await),
      _ unexpectedBetweenAwaitKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAwaitKeyword, 
            awaitKeyword, 
            unexpectedBetweenAwaitKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAwaitKeyword?.raw, 
          awaitKeyword.raw, 
          unexpectedBetweenAwaitKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.awaitExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAwaitKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var awaitKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAwaitKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AwaitExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAwaitKeyword, 
          \Self.awaitKeyword, 
          \Self.unexpectedBetweenAwaitKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - BinaryOperatorExprSyntax

/// ### Children
/// 
///  - `operator`: `<binaryOperator>`
public struct BinaryOperatorExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .binaryOperatorExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``BinaryOperatorExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .binaryOperatorExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOperator: UnexpectedNodesSyntax? = nil,
      operator: TokenSyntax,
      _ unexpectedAfterOperator: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeOperator, `operator`, unexpectedAfterOperator))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeOperator?.raw, `operator`.raw, unexpectedAfterOperator?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.binaryOperatorExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOperator: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BinaryOperatorExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var `operator`: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = BinaryOperatorExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterOperator: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BinaryOperatorExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeOperator, \Self.operator, \Self.unexpectedAfterOperator])
  }
}

// MARK: - BooleanLiteralExprSyntax

/// ### Children
/// 
///  - `literal`: (`'true'` | `'false'`)
public struct BooleanLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .booleanLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``BooleanLiteralExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .booleanLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLiteral: UnexpectedNodesSyntax? = nil,
      literal: TokenSyntax,
      _ unexpectedAfterLiteral: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeLiteral, literal, unexpectedAfterLiteral))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeLiteral?.raw, literal.raw, unexpectedAfterLiteral?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.booleanLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLiteral: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BooleanLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var literal: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = BooleanLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterLiteral: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BooleanLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeLiteral, \Self.literal, \Self.unexpectedAfterLiteral])
  }
}

// MARK: - BorrowExprSyntax

/// ### Children
/// 
///  - `borrowKeyword`: `'_borrow'`
///  - `expression`: ``ExprSyntax``
public struct BorrowExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .borrowExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``BorrowExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .borrowExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBorrowKeyword: UnexpectedNodesSyntax? = nil,
      borrowKeyword: TokenSyntax = .keyword(._borrow),
      _ unexpectedBetweenBorrowKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBorrowKeyword, 
            borrowKeyword, 
            unexpectedBetweenBorrowKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBorrowKeyword?.raw, 
          borrowKeyword.raw, 
          unexpectedBetweenBorrowKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.borrowExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBorrowKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var borrowKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBorrowKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = BorrowExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBorrowKeyword, 
          \Self.borrowKeyword, 
          \Self.unexpectedBetweenBorrowKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - CanImportExprSyntax

/// ### Children
/// 
///  - `canImportKeyword`: `'canImport'`
///  - `leftParen`: `'('`
///  - `importPath`: `<identifier>`
///  - `versionInfo`: ``CanImportVersionInfoSyntax``?
///  - `rightParen`: `')'`
public struct CanImportExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .canImportExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CanImportExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .canImportExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCanImportKeyword: UnexpectedNodesSyntax? = nil,
      canImportKeyword: TokenSyntax = .keyword(.canImport),
      _ unexpectedBetweenCanImportKeywordAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndImportPath: UnexpectedNodesSyntax? = nil,
      importPath: TokenSyntax,
      _ unexpectedBetweenImportPathAndVersionInfo: UnexpectedNodesSyntax? = nil,
      versionInfo: CanImportVersionInfoSyntax? = nil,
      _ unexpectedBetweenVersionInfoAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCanImportKeyword, 
            canImportKeyword, 
            unexpectedBetweenCanImportKeywordAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndImportPath, 
            importPath, 
            unexpectedBetweenImportPathAndVersionInfo, 
            versionInfo, 
            unexpectedBetweenVersionInfoAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCanImportKeyword?.raw, 
          canImportKeyword.raw, 
          unexpectedBetweenCanImportKeywordAndLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndImportPath?.raw, 
          importPath.raw, 
          unexpectedBetweenImportPathAndVersionInfo?.raw, 
          versionInfo?.raw, 
          unexpectedBetweenVersionInfoAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.canImportExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCanImportKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var canImportKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCanImportKeywordAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndImportPath: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var importPath: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenImportPathAndVersionInfo: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var versionInfo: CanImportVersionInfoSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(CanImportVersionInfoSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenVersionInfoAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCanImportKeyword, 
          \Self.canImportKeyword, 
          \Self.unexpectedBetweenCanImportKeywordAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndImportPath, 
          \Self.importPath, 
          \Self.unexpectedBetweenImportPathAndVersionInfo, 
          \Self.versionInfo, 
          \Self.unexpectedBetweenVersionInfoAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - CanImportVersionInfoSyntax

/// ### Children
/// 
///  - `comma`: `','`
///  - `label`: (`'_version'` | `'_underlyingVersion'`)
///  - `colon`: `':'`
///  - `version`: ``VersionTupleSyntax``
public struct CanImportVersionInfoSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .canImportVersionInfo else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CanImportVersionInfoSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .canImportVersionInfo)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax = .commaToken(),
      _ unexpectedBetweenCommaAndLabel: UnexpectedNodesSyntax? = nil,
      label: TokenSyntax,
      _ unexpectedBetweenLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndVersion: UnexpectedNodesSyntax? = nil,
      version: VersionTupleSyntax,
      _ unexpectedAfterVersion: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeComma, 
            comma, 
            unexpectedBetweenCommaAndLabel, 
            label, 
            unexpectedBetweenLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndVersion, 
            version, 
            unexpectedAfterVersion
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeComma?.raw, 
          comma.raw, 
          unexpectedBetweenCommaAndLabel?.raw, 
          label.raw, 
          unexpectedBetweenLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndVersion?.raw, 
          version.raw, 
          unexpectedAfterVersion?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.canImportVersionInfo,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var comma: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCommaAndLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var label: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndVersion: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var version: VersionTupleSyntax {
    get {
      return VersionTupleSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterVersion: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CanImportVersionInfoSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeComma, 
          \Self.comma, 
          \Self.unexpectedBetweenCommaAndLabel, 
          \Self.label, 
          \Self.unexpectedBetweenLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndVersion, 
          \Self.version, 
          \Self.unexpectedAfterVersion
        ])
  }
}

// MARK: - ClosureExprSyntax

/// ### Children
/// 
///  - `leftBrace`: `'{'`
///  - `signature`: ``ClosureSignatureSyntax``?
///  - `statements`: ``CodeBlockItemListSyntax``
///  - `rightBrace`: `'}'`
public struct ClosureExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClosureExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .closureExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftBrace: UnexpectedNodesSyntax? = nil,
      leftBrace: TokenSyntax = .leftBraceToken(),
      _ unexpectedBetweenLeftBraceAndSignature: UnexpectedNodesSyntax? = nil,
      signature: ClosureSignatureSyntax? = nil,
      _ unexpectedBetweenSignatureAndStatements: UnexpectedNodesSyntax? = nil,
      statements: CodeBlockItemListSyntax,
      _ unexpectedBetweenStatementsAndRightBrace: UnexpectedNodesSyntax? = nil,
      rightBrace: TokenSyntax = .rightBraceToken(),
      _ unexpectedAfterRightBrace: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftBrace, 
            leftBrace, 
            unexpectedBetweenLeftBraceAndSignature, 
            signature, 
            unexpectedBetweenSignatureAndStatements, 
            statements, 
            unexpectedBetweenStatementsAndRightBrace, 
            rightBrace, 
            unexpectedAfterRightBrace
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftBrace?.raw, 
          leftBrace.raw, 
          unexpectedBetweenLeftBraceAndSignature?.raw, 
          signature?.raw, 
          unexpectedBetweenSignatureAndStatements?.raw, 
          statements.raw, 
          unexpectedBetweenStatementsAndRightBrace?.raw, 
          rightBrace.raw, 
          unexpectedAfterRightBrace?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.closureExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftBraceAndSignature: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var signature: ClosureSignatureSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(ClosureSignatureSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSignatureAndStatements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var statements: CodeBlockItemListSyntax {
    get {
      return CodeBlockItemListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `statements`
  /// collection.
  /// - param element: The new `Statement` to add to the node's
  ///                  `statements` collection.
  /// - returns: A copy of the receiver with the provided `Statement`
  ///            appended to its `statements` collection.
  public func addStatement(_ element: CodeBlockItemSyntax) -> ClosureExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.codeBlockItemList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClosureExprSyntax(newData)
  }
  
  public var unexpectedBetweenStatementsAndRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClosureExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftBrace, 
          \Self.leftBrace, 
          \Self.unexpectedBetweenLeftBraceAndSignature, 
          \Self.signature, 
          \Self.unexpectedBetweenSignatureAndStatements, 
          \Self.statements, 
          \Self.unexpectedBetweenStatementsAndRightBrace, 
          \Self.rightBrace, 
          \Self.unexpectedAfterRightBrace
        ])
  }
}

// MARK: - CopyExprSyntax

/// ### Children
/// 
///  - `copyKeyword`: `'copy'`
///  - `expression`: ``ExprSyntax``
public struct CopyExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .copyExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``CopyExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .copyExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCopyKeyword: UnexpectedNodesSyntax? = nil,
      copyKeyword: TokenSyntax = .keyword(.copy),
      _ unexpectedBetweenCopyKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCopyKeyword, 
            copyKeyword, 
            unexpectedBetweenCopyKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCopyKeyword?.raw, 
          copyKeyword.raw, 
          unexpectedBetweenCopyKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.copyExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCopyKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var copyKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCopyKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = CopyExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCopyKeyword, 
          \Self.copyKeyword, 
          \Self.unexpectedBetweenCopyKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - DictionaryExprSyntax

/// ### Children
/// 
///  - `leftSquare`: `'['`
///  - `content`: (`':'` | ``DictionaryElementListSyntax``)
///  - `rightSquare`: `']'`
public struct DictionaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public enum Content: SyntaxChildChoices {
    case `colon`(TokenSyntax)
    case `elements`(DictionaryElementListSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .colon(let node):
        return node._syntaxNode
      case .elements(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: TokenSyntax) {
      self = .colon(node)
    }
    
    public init(_ node: DictionaryElementListSyntax) {
      self = .elements(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(TokenSyntax.self) {
        self = .colon(node)
        return
      }
      if let node = node.as(DictionaryElementListSyntax.self) {
        self = .elements(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(TokenSyntax.self), .node(DictionaryElementListSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .dictionaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DictionaryExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .dictionaryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? = nil,
      leftSquare: TokenSyntax = .leftSquareToken(),
      _ unexpectedBetweenLeftSquareAndContent: UnexpectedNodesSyntax? = nil,
      content: Content,
      _ unexpectedBetweenContentAndRightSquare: UnexpectedNodesSyntax? = nil,
      rightSquare: TokenSyntax = .rightSquareToken(),
      _ unexpectedAfterRightSquare: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftSquare, 
            leftSquare, 
            unexpectedBetweenLeftSquareAndContent, 
            content, 
            unexpectedBetweenContentAndRightSquare, 
            rightSquare, 
            unexpectedAfterRightSquare
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftSquare?.raw, 
          leftSquare.raw, 
          unexpectedBetweenLeftSquareAndContent?.raw, 
          content.raw, 
          unexpectedBetweenContentAndRightSquare?.raw, 
          rightSquare.raw, 
          unexpectedAfterRightSquare?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.dictionaryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftSquareAndContent: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var content: Content {
    get {
      return Content(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenContentAndRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftSquare, 
          \Self.leftSquare, 
          \Self.unexpectedBetweenLeftSquareAndContent, 
          \Self.content, 
          \Self.unexpectedBetweenContentAndRightSquare, 
          \Self.rightSquare, 
          \Self.unexpectedAfterRightSquare
        ])
  }
}

// MARK: - DiscardAssignmentExprSyntax

/// ### Children
/// 
///  - `wildcard`: `'_'`
public struct DiscardAssignmentExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .discardAssignmentExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DiscardAssignmentExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .discardAssignmentExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWildcard: UnexpectedNodesSyntax? = nil,
      wildcard: TokenSyntax = .wildcardToken(),
      _ unexpectedAfterWildcard: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeWildcard, wildcard, unexpectedAfterWildcard))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeWildcard?.raw, wildcard.raw, unexpectedAfterWildcard?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.discardAssignmentExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeWildcard: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DiscardAssignmentExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var wildcard: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DiscardAssignmentExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterWildcard: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DiscardAssignmentExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeWildcard, \Self.wildcard, \Self.unexpectedAfterWildcard])
  }
}

// MARK: - EditorPlaceholderExprSyntax

/// ### Children
/// 
///  - `identifier`: `<identifier>`
public struct EditorPlaceholderExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .editorPlaceholderExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EditorPlaceholderExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .editorPlaceholderExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIdentifier: UnexpectedNodesSyntax? = nil,
      identifier: TokenSyntax,
      _ unexpectedAfterIdentifier: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeIdentifier, identifier, unexpectedAfterIdentifier))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeIdentifier?.raw, identifier.raw, unexpectedAfterIdentifier?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.editorPlaceholderExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIdentifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var identifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = EditorPlaceholderExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterIdentifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeIdentifier, \Self.identifier, \Self.unexpectedAfterIdentifier])
  }
}

// MARK: - FloatLiteralExprSyntax

/// ### Children
/// 
///  - `digits`: `<floatingLiteral>`
public struct FloatLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .floatLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FloatLiteralExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .floatLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeDigits: UnexpectedNodesSyntax? = nil,
      digits: TokenSyntax,
      _ unexpectedAfterDigits: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeDigits, digits, unexpectedAfterDigits))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeDigits?.raw, digits.raw, unexpectedAfterDigits?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.floatLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeDigits: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FloatLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var digits: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FloatLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDigits: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FloatLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeDigits, \Self.digits, \Self.unexpectedAfterDigits])
  }
}

// MARK: - ForcedValueExprSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `exclamationMark`: `'!'`
public struct ForcedValueExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .forcedValueExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ForcedValueExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .forcedValueExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndExclamationMark: UnexpectedNodesSyntax? = nil,
      exclamationMark: TokenSyntax = .exclamationMarkToken(),
      _ unexpectedAfterExclamationMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndExclamationMark, 
            exclamationMark, 
            unexpectedAfterExclamationMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndExclamationMark?.raw, 
          exclamationMark.raw, 
          unexpectedAfterExclamationMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.forcedValueExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var exclamationMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForcedValueExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndExclamationMark, 
          \Self.exclamationMark, 
          \Self.unexpectedAfterExclamationMark
        ])
  }
}

// MARK: - FunctionCallExprSyntax

/// ### Children
/// 
///  - `calledExpression`: ``ExprSyntax``
///  - `leftParen`: `'('`?
///  - `argumentList`: ``TupleExprElementListSyntax``
///  - `rightParen`: `')'`?
///  - `trailingClosure`: ``ClosureExprSyntax``?
///  - `additionalTrailingClosures`: ``MultipleTrailingClosureElementListSyntax``
public struct FunctionCallExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionCallExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FunctionCallExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionCallExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? = nil,
      calledExpression: some ExprSyntaxProtocol,
      _ unexpectedBetweenCalledExpressionAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax? = nil,
      _ unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodesSyntax? = nil,
      argumentList: TupleExprElementListSyntax,
      _ unexpectedBetweenArgumentListAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax? = nil,
      _ unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? = nil,
      trailingClosure: ClosureExprSyntax? = nil,
      _ unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? = nil,
      _ unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCalledExpression, 
            calledExpression, 
            unexpectedBetweenCalledExpressionAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArgumentList, 
            argumentList, 
            unexpectedBetweenArgumentListAndRightParen, 
            rightParen, 
            unexpectedBetweenRightParenAndTrailingClosure, 
            trailingClosure, 
            unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
            additionalTrailingClosures, 
            unexpectedAfterAdditionalTrailingClosures
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCalledExpression?.raw, 
          calledExpression.raw, 
          unexpectedBetweenCalledExpressionAndLeftParen?.raw, 
          leftParen?.raw, 
          unexpectedBetweenLeftParenAndArgumentList?.raw, 
          argumentList.raw, 
          unexpectedBetweenArgumentListAndRightParen?.raw, 
          rightParen?.raw, 
          unexpectedBetweenRightParenAndTrailingClosure?.raw, 
          trailingClosure?.raw, 
          unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.raw, 
          additionalTrailingClosures?.raw, 
          unexpectedAfterAdditionalTrailingClosures?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionCallExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var calledExpression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCalledExpressionAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var argumentList: TupleExprElementListSyntax {
    get {
      return TupleExprElementListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `argumentList`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `argumentList` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> FunctionCallExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleExprElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionCallExprSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentListAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingClosure: ClosureExprSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(ClosureExprSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(MultipleTrailingClosureElementListSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `additionalTrailingClosures`
  /// collection.
  /// - param element: The new `AdditionalTrailingClosure` to add to the node's
  ///                  `additionalTrailingClosures` collection.
  /// - returns: A copy of the receiver with the provided `AdditionalTrailingClosure`
  ///            appended to its `additionalTrailingClosures` collection.
  public func addAdditionalTrailingClosure(_ element: MultipleTrailingClosureElementSyntax) -> FunctionCallExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[11] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.multipleTrailingClosureElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 11, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionCallExprSyntax(newData)
  }
  
  public var unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCalledExpression, 
          \Self.calledExpression, 
          \Self.unexpectedBetweenCalledExpressionAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArgumentList, 
          \Self.argumentList, 
          \Self.unexpectedBetweenArgumentListAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedBetweenRightParenAndTrailingClosure, 
          \Self.trailingClosure, 
          \Self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
          \Self.additionalTrailingClosures, 
          \Self.unexpectedAfterAdditionalTrailingClosures
        ])
  }
}

// MARK: - IdentifierExprSyntax

/// ### Children
/// 
///  - `identifier`: (`<identifier>` | `'self'` | `'Self'` | `'init'` | `<dollarIdentifier>` | `<binaryOperator>`)
///  - `declNameArguments`: ``DeclNameArgumentsSyntax``?
public struct IdentifierExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .identifierExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IdentifierExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .identifierExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIdentifier: UnexpectedNodesSyntax? = nil,
      identifier: TokenSyntax,
      _ unexpectedBetweenIdentifierAndDeclNameArguments: UnexpectedNodesSyntax? = nil,
      declNameArguments: DeclNameArgumentsSyntax? = nil,
      _ unexpectedAfterDeclNameArguments: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeIdentifier, 
            identifier, 
            unexpectedBetweenIdentifierAndDeclNameArguments, 
            declNameArguments, 
            unexpectedAfterDeclNameArguments
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeIdentifier?.raw, 
          identifier.raw, 
          unexpectedBetweenIdentifierAndDeclNameArguments?.raw, 
          declNameArguments?.raw, 
          unexpectedAfterDeclNameArguments?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.identifierExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIdentifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var identifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenIdentifierAndDeclNameArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var declNameArguments: DeclNameArgumentsSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclNameArgumentsSyntax.init)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDeclNameArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeIdentifier, 
          \Self.identifier, 
          \Self.unexpectedBetweenIdentifierAndDeclNameArguments, 
          \Self.declNameArguments, 
          \Self.unexpectedAfterDeclNameArguments
        ])
  }
}

// MARK: - IfExprSyntax

/// ### Children
/// 
///  - `ifKeyword`: `'if'`
///  - `conditions`: ``ConditionElementListSyntax``
///  - `body`: ``CodeBlockSyntax``
///  - `elseKeyword`: `'else'`?
///  - `elseBody`: (``IfExprSyntax`` | ``CodeBlockSyntax``)?
public struct IfExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public enum ElseBody: SyntaxChildChoices {
    case `ifExpr`(IfExprSyntax)
    case `codeBlock`(CodeBlockSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .ifExpr(let node):
        return node._syntaxNode
      case .codeBlock(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: IfExprSyntax) {
      self = .ifExpr(node)
    }
    
    public init(_ node: CodeBlockSyntax) {
      self = .codeBlock(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(IfExprSyntax.self) {
        self = .ifExpr(node)
        return
      }
      if let node = node.as(CodeBlockSyntax.self) {
        self = .codeBlock(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(IfExprSyntax.self), .node(CodeBlockSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .ifExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IfExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .ifExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIfKeyword: UnexpectedNodesSyntax? = nil,
      ifKeyword: TokenSyntax = .keyword(.if),
      _ unexpectedBetweenIfKeywordAndConditions: UnexpectedNodesSyntax? = nil,
      conditions: ConditionElementListSyntax,
      _ unexpectedBetweenConditionsAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax,
      _ unexpectedBetweenBodyAndElseKeyword: UnexpectedNodesSyntax? = nil,
      elseKeyword: TokenSyntax? = nil,
      _ unexpectedBetweenElseKeywordAndElseBody: UnexpectedNodesSyntax? = nil,
      elseBody: ElseBody? = nil,
      _ unexpectedAfterElseBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeIfKeyword, 
            ifKeyword, 
            unexpectedBetweenIfKeywordAndConditions, 
            conditions, 
            unexpectedBetweenConditionsAndBody, 
            body, 
            unexpectedBetweenBodyAndElseKeyword, 
            elseKeyword, 
            unexpectedBetweenElseKeywordAndElseBody, 
            elseBody, 
            unexpectedAfterElseBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeIfKeyword?.raw, 
          ifKeyword.raw, 
          unexpectedBetweenIfKeywordAndConditions?.raw, 
          conditions.raw, 
          unexpectedBetweenConditionsAndBody?.raw, 
          body.raw, 
          unexpectedBetweenBodyAndElseKeyword?.raw, 
          elseKeyword?.raw, 
          unexpectedBetweenElseKeywordAndElseBody?.raw, 
          elseBody?.raw, 
          unexpectedAfterElseBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.ifExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIfKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var ifKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenIfKeywordAndConditions: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var conditions: ConditionElementListSyntax {
    get {
      return ConditionElementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `conditions`
  /// collection.
  /// - param element: The new `Condition` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `Condition`
  ///            appended to its `conditions` collection.
  public func addCondition(_ element: ConditionElementSyntax) -> IfExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.conditionElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return IfExprSyntax(newData)
  }
  
  public var unexpectedBetweenConditionsAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax {
    get {
      return CodeBlockSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBodyAndElseKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elseKeyword: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenElseKeywordAndElseBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elseBody: ElseBody? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(ElseBody.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterElseBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeIfKeyword, 
          \Self.ifKeyword, 
          \Self.unexpectedBetweenIfKeywordAndConditions, 
          \Self.conditions, 
          \Self.unexpectedBetweenConditionsAndBody, 
          \Self.body, 
          \Self.unexpectedBetweenBodyAndElseKeyword, 
          \Self.elseKeyword, 
          \Self.unexpectedBetweenElseKeywordAndElseBody, 
          \Self.elseBody, 
          \Self.unexpectedAfterElseBody
        ])
  }
}

// MARK: - InOutExprSyntax

/// ### Children
/// 
///  - `ampersand`: `'&'`
///  - `expression`: ``ExprSyntax``
public struct InOutExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .inOutExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``InOutExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .inOutExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAmpersand: UnexpectedNodesSyntax? = nil,
      ampersand: TokenSyntax = .prefixAmpersandToken(),
      _ unexpectedBetweenAmpersandAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAmpersand, 
            ampersand, 
            unexpectedBetweenAmpersandAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAmpersand?.raw, 
          ampersand.raw, 
          unexpectedBetweenAmpersandAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.inOutExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAmpersand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var ampersand: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAmpersandAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAmpersand, 
          \Self.ampersand, 
          \Self.unexpectedBetweenAmpersandAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - InfixOperatorExprSyntax

/// ### Children
/// 
///  - `leftOperand`: ``ExprSyntax``
///  - `operatorOperand`: ``ExprSyntax``
///  - `rightOperand`: ``ExprSyntax``
public struct InfixOperatorExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .infixOperatorExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``InfixOperatorExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .infixOperatorExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftOperand: UnexpectedNodesSyntax? = nil,
      leftOperand: some ExprSyntaxProtocol,
      _ unexpectedBetweenLeftOperandAndOperatorOperand: UnexpectedNodesSyntax? = nil,
      operatorOperand: some ExprSyntaxProtocol,
      _ unexpectedBetweenOperatorOperandAndRightOperand: UnexpectedNodesSyntax? = nil,
      rightOperand: some ExprSyntaxProtocol,
      _ unexpectedAfterRightOperand: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftOperand, 
            leftOperand, 
            unexpectedBetweenLeftOperandAndOperatorOperand, 
            operatorOperand, 
            unexpectedBetweenOperatorOperandAndRightOperand, 
            rightOperand, 
            unexpectedAfterRightOperand
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftOperand?.raw, 
          leftOperand.raw, 
          unexpectedBetweenLeftOperandAndOperatorOperand?.raw, 
          operatorOperand.raw, 
          unexpectedBetweenOperatorOperandAndRightOperand?.raw, 
          rightOperand.raw, 
          unexpectedAfterRightOperand?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.infixOperatorExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftOperand: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftOperandAndOperatorOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var operatorOperand: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOperatorOperandAndRightOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightOperand: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftOperand, 
          \Self.leftOperand, 
          \Self.unexpectedBetweenLeftOperandAndOperatorOperand, 
          \Self.operatorOperand, 
          \Self.unexpectedBetweenOperatorOperandAndRightOperand, 
          \Self.rightOperand, 
          \Self.unexpectedAfterRightOperand
        ])
  }
}

// MARK: - IntegerLiteralExprSyntax

/// ### Children
/// 
///  - `digits`: `<integerLiteral>`
public struct IntegerLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .integerLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IntegerLiteralExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .integerLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeDigits: UnexpectedNodesSyntax? = nil,
      digits: TokenSyntax,
      _ unexpectedAfterDigits: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeDigits, digits, unexpectedAfterDigits))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeDigits?.raw, digits.raw, unexpectedAfterDigits?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.integerLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeDigits: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IntegerLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var digits: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IntegerLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDigits: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IntegerLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeDigits, \Self.digits, \Self.unexpectedAfterDigits])
  }
}

// MARK: - IsExprSyntax

/// An `is` expression like the following.
/// 
/// ```swift
/// value is Double
/// ```
/// 
/// This node is only generated after operators are folded using the `SwiftOperators` library. Beforehand, the parser does not know the precedences of operators and thus represents `is` by an `UnresolvedIsExpr`.
///
/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `isKeyword`: `'is'`
///  - `typeName`: ``TypeSyntax``
public struct IsExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .isExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IsExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .isExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - expression: The expression which will be checked to determine whether it can be cast to a specific type.
  ///   - isKeyword: The `is` keyword for this expression.
  ///   - typeName: The type against which the expression will be checked to see if the expression can be cast to it.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndIsKeyword: UnexpectedNodesSyntax? = nil,
      isKeyword: TokenSyntax = .keyword(.is),
      _ unexpectedBetweenIsKeywordAndTypeName: UnexpectedNodesSyntax? = nil,
      typeName: some TypeSyntaxProtocol,
      _ unexpectedAfterTypeName: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndIsKeyword, 
            isKeyword, 
            unexpectedBetweenIsKeywordAndTypeName, 
            typeName, 
            unexpectedAfterTypeName
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndIsKeyword?.raw, 
          isKeyword.raw, 
          unexpectedBetweenIsKeywordAndTypeName?.raw, 
          typeName.raw, 
          unexpectedAfterTypeName?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.isExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The expression which will be checked to determine whether it can be cast to a specific type.
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndIsKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `is` keyword for this expression.
  public var isKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenIsKeywordAndTypeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The type against which the expression will be checked to see if the expression can be cast to it.
  public var typeName: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTypeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndIsKeyword, 
          \Self.isKeyword, 
          \Self.unexpectedBetweenIsKeywordAndTypeName, 
          \Self.typeName, 
          \Self.unexpectedAfterTypeName
        ])
  }
}

// MARK: - KeyPathExprSyntax

/// ### Children
/// 
///  - `backslash`: `'\'`
///  - `root`: ``TypeSyntax``?
///  - `components`: ``KeyPathComponentListSyntax``
public struct KeyPathExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .keyPathExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``KeyPathExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .keyPathExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBackslash: UnexpectedNodesSyntax? = nil,
      backslash: TokenSyntax = .backslashToken(),
      _ unexpectedBetweenBackslashAndRoot: UnexpectedNodesSyntax? = nil,
      root: (some TypeSyntaxProtocol)? = TypeSyntax?.none,
      _ unexpectedBetweenRootAndComponents: UnexpectedNodesSyntax? = nil,
      components: KeyPathComponentListSyntax,
      _ unexpectedAfterComponents: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBackslash, 
            backslash, 
            unexpectedBetweenBackslashAndRoot, 
            root, 
            unexpectedBetweenRootAndComponents, 
            components, 
            unexpectedAfterComponents
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBackslash?.raw, 
          backslash.raw, 
          unexpectedBetweenBackslashAndRoot?.raw, 
          root?.raw, 
          unexpectedBetweenRootAndComponents?.raw, 
          components.raw, 
          unexpectedAfterComponents?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.keyPathExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBackslash: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var backslash: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBackslashAndRoot: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var root: TypeSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TypeSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRootAndComponents: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var components: KeyPathComponentListSyntax {
    get {
      return KeyPathComponentListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `components`
  /// collection.
  /// - param element: The new `KeyPathComponent` to add to the node's
  ///                  `components` collection.
  /// - returns: A copy of the receiver with the provided `KeyPathComponent`
  ///            appended to its `components` collection.
  public func addKeyPathComponent(_ element: KeyPathComponentSyntax) -> KeyPathExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.keyPathComponentList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return KeyPathExprSyntax(newData)
  }
  
  public var unexpectedAfterComponents: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = KeyPathExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBackslash, 
          \Self.backslash, 
          \Self.unexpectedBetweenBackslashAndRoot, 
          \Self.root, 
          \Self.unexpectedBetweenRootAndComponents, 
          \Self.components, 
          \Self.unexpectedAfterComponents
        ])
  }
}

// MARK: - MacroExpansionExprSyntax

/// ### Children
/// 
///  - `pound`: `'#'`
///  - `macro`: `<identifier>`
///  - `genericArgumentClause`: ``GenericArgumentClauseSyntax``?
///  - `leftParen`: `'('`?
///  - `argumentList`: ``TupleExprElementListSyntax``
///  - `rightParen`: `')'`?
///  - `trailingClosure`: ``ClosureExprSyntax``?
///  - `additionalTrailingClosures`: ``MultipleTrailingClosureElementListSyntax``
public struct MacroExpansionExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .macroExpansionExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``MacroExpansionExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .macroExpansionExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - pound: The `#` sign.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePound: UnexpectedNodesSyntax? = nil,
      pound: TokenSyntax = .poundToken(),
      _ unexpectedBetweenPoundAndMacro: UnexpectedNodesSyntax? = nil,
      macro: TokenSyntax,
      _ unexpectedBetweenMacroAndGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      genericArgumentClause: GenericArgumentClauseSyntax? = nil,
      _ unexpectedBetweenGenericArgumentClauseAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax? = nil,
      _ unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodesSyntax? = nil,
      argumentList: TupleExprElementListSyntax,
      _ unexpectedBetweenArgumentListAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax? = nil,
      _ unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? = nil,
      trailingClosure: ClosureExprSyntax? = nil,
      _ unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? = nil,
      _ unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforePound, 
            pound, 
            unexpectedBetweenPoundAndMacro, 
            macro, 
            unexpectedBetweenMacroAndGenericArgumentClause, 
            genericArgumentClause, 
            unexpectedBetweenGenericArgumentClauseAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArgumentList, 
            argumentList, 
            unexpectedBetweenArgumentListAndRightParen, 
            rightParen, 
            unexpectedBetweenRightParenAndTrailingClosure, 
            trailingClosure, 
            unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
            additionalTrailingClosures, 
            unexpectedAfterAdditionalTrailingClosures
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforePound?.raw, 
          pound.raw, 
          unexpectedBetweenPoundAndMacro?.raw, 
          macro.raw, 
          unexpectedBetweenMacroAndGenericArgumentClause?.raw, 
          genericArgumentClause?.raw, 
          unexpectedBetweenGenericArgumentClauseAndLeftParen?.raw, 
          leftParen?.raw, 
          unexpectedBetweenLeftParenAndArgumentList?.raw, 
          argumentList.raw, 
          unexpectedBetweenArgumentListAndRightParen?.raw, 
          rightParen?.raw, 
          unexpectedBetweenRightParenAndTrailingClosure?.raw, 
          trailingClosure?.raw, 
          unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.raw, 
          additionalTrailingClosures?.raw, 
          unexpectedAfterAdditionalTrailingClosures?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.macroExpansionExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePound: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `#` sign.
  public var pound: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPoundAndMacro: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var macro: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenMacroAndGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var genericArgumentClause: GenericArgumentClauseSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(GenericArgumentClauseSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericArgumentClauseAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var argumentList: TupleExprElementListSyntax {
    get {
      return TupleExprElementListSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `argumentList`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `argumentList` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> MacroExpansionExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[9] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleExprElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 9, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MacroExpansionExprSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentListAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingClosure: ClosureExprSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(ClosureExprSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(MultipleTrailingClosureElementListSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `additionalTrailingClosures`
  /// collection.
  /// - param element: The new `AdditionalTrailingClosure` to add to the node's
  ///                  `additionalTrailingClosures` collection.
  /// - returns: A copy of the receiver with the provided `AdditionalTrailingClosure`
  ///            appended to its `additionalTrailingClosures` collection.
  public func addAdditionalTrailingClosure(_ element: MultipleTrailingClosureElementSyntax) -> MacroExpansionExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[15] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.multipleTrailingClosureElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 15, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MacroExpansionExprSyntax(newData)
  }
  
  public var unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionExprSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforePound, 
          \Self.pound, 
          \Self.unexpectedBetweenPoundAndMacro, 
          \Self.macro, 
          \Self.unexpectedBetweenMacroAndGenericArgumentClause, 
          \Self.genericArgumentClause, 
          \Self.unexpectedBetweenGenericArgumentClauseAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArgumentList, 
          \Self.argumentList, 
          \Self.unexpectedBetweenArgumentListAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedBetweenRightParenAndTrailingClosure, 
          \Self.trailingClosure, 
          \Self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
          \Self.additionalTrailingClosures, 
          \Self.unexpectedAfterAdditionalTrailingClosures
        ])
  }
}

// MARK: - MemberAccessExprSyntax

/// ### Children
/// 
///  - `base`: ``ExprSyntax``?
///  - `period`: `'.'`
///  - `name`: ``TokenSyntax``
///  - `declNameArguments`: ``DeclNameArgumentsSyntax``?
public struct MemberAccessExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .memberAccessExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``MemberAccessExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .memberAccessExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBase: UnexpectedNodesSyntax? = nil,
      base: (some ExprSyntaxProtocol)? = ExprSyntax?.none,
      _ unexpectedBetweenBaseAndPeriod: UnexpectedNodesSyntax? = nil,
      period: TokenSyntax = .periodToken(),
      _ unexpectedBetweenPeriodAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndDeclNameArguments: UnexpectedNodesSyntax? = nil,
      declNameArguments: DeclNameArgumentsSyntax? = nil,
      _ unexpectedAfterDeclNameArguments: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBase, 
            base, 
            unexpectedBetweenBaseAndPeriod, 
            period, 
            unexpectedBetweenPeriodAndName, 
            name, 
            unexpectedBetweenNameAndDeclNameArguments, 
            declNameArguments, 
            unexpectedAfterDeclNameArguments
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBase?.raw, 
          base?.raw, 
          unexpectedBetweenBaseAndPeriod?.raw, 
          period.raw, 
          unexpectedBetweenPeriodAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndDeclNameArguments?.raw, 
          declNameArguments?.raw, 
          unexpectedAfterDeclNameArguments?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.memberAccessExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBase: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var base: ExprSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(ExprSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBaseAndPeriod: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var period: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPeriodAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndDeclNameArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var declNameArguments: DeclNameArgumentsSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(DeclNameArgumentsSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDeclNameArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MemberAccessExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBase, 
          \Self.base, 
          \Self.unexpectedBetweenBaseAndPeriod, 
          \Self.period, 
          \Self.unexpectedBetweenPeriodAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndDeclNameArguments, 
          \Self.declNameArguments, 
          \Self.unexpectedAfterDeclNameArguments
        ])
  }
}

// MARK: - MissingExprSyntax

/// In case the source code is missing an expression, this node stands in place of the missing expression.
///
/// ### Children
/// 
///  - `placeholder`: `<identifier>`
public struct MissingExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .missingExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``MissingExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .missingExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - placeholder: A placeholder, i.e. `<#expression#>`, that can be inserted into the source code to represent the missing expression.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePlaceholder: UnexpectedNodesSyntax? = nil,
      placeholder: TokenSyntax,
      _ unexpectedAfterPlaceholder: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforePlaceholder, placeholder, unexpectedAfterPlaceholder))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforePlaceholder?.raw, placeholder.raw, unexpectedAfterPlaceholder?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.missingExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MissingExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A placeholder, i.e. `<#expression#>`, that can be inserted into the source code to represent the missing expression./// This token should always have `presence = .missing`.
  public var placeholder: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = MissingExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MissingExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforePlaceholder, \Self.placeholder, \Self.unexpectedAfterPlaceholder])
  }
}

// MARK: - MoveExprSyntax

/// ### Children
/// 
///  - `consumeKeyword`: (`'_move'` | `'consume'`)
///  - `expression`: ``ExprSyntax``
public struct MoveExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .moveExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``MoveExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .moveExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeConsumeKeyword: UnexpectedNodesSyntax? = nil,
      consumeKeyword: TokenSyntax,
      _ unexpectedBetweenConsumeKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeConsumeKeyword, 
            consumeKeyword, 
            unexpectedBetweenConsumeKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeConsumeKeyword?.raw, 
          consumeKeyword.raw, 
          unexpectedBetweenConsumeKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.moveExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeConsumeKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var consumeKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenConsumeKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MoveExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeConsumeKeyword, 
          \Self.consumeKeyword, 
          \Self.unexpectedBetweenConsumeKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - NilLiteralExprSyntax

/// ### Children
/// 
///  - `nilKeyword`: `'nil'`
public struct NilLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .nilLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``NilLiteralExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .nilLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeNilKeyword: UnexpectedNodesSyntax? = nil,
      nilKeyword: TokenSyntax = .keyword(.nil),
      _ unexpectedAfterNilKeyword: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeNilKeyword, nilKeyword, unexpectedAfterNilKeyword))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeNilKeyword?.raw, nilKeyword.raw, unexpectedAfterNilKeyword?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.nilLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeNilKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = NilLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var nilKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = NilLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterNilKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = NilLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeNilKeyword, \Self.nilKeyword, \Self.unexpectedAfterNilKeyword])
  }
}

// MARK: - OptionalChainingExprSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `questionMark`: `'?'`
public struct OptionalChainingExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .optionalChainingExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``OptionalChainingExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .optionalChainingExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .postfixQuestionMarkToken(),
      _ unexpectedAfterQuestionMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndQuestionMark, 
            questionMark, 
            unexpectedAfterQuestionMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndQuestionMark?.raw, 
          questionMark.raw, 
          unexpectedAfterQuestionMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.optionalChainingExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OptionalChainingExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndQuestionMark, 
          \Self.questionMark, 
          \Self.unexpectedAfterQuestionMark
        ])
  }
}

// MARK: - PackElementExprSyntax

/// ### Children
/// 
///  - `eachKeyword`: `'each'`
///  - `packRefExpr`: ``ExprSyntax``
public struct PackElementExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .packElementExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PackElementExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .packElementExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeEachKeyword: UnexpectedNodesSyntax? = nil,
      eachKeyword: TokenSyntax = .keyword(.each),
      _ unexpectedBetweenEachKeywordAndPackRefExpr: UnexpectedNodesSyntax? = nil,
      packRefExpr: some ExprSyntaxProtocol,
      _ unexpectedAfterPackRefExpr: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeEachKeyword, 
            eachKeyword, 
            unexpectedBetweenEachKeywordAndPackRefExpr, 
            packRefExpr, 
            unexpectedAfterPackRefExpr
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeEachKeyword?.raw, 
          eachKeyword.raw, 
          unexpectedBetweenEachKeywordAndPackRefExpr?.raw, 
          packRefExpr.raw, 
          unexpectedAfterPackRefExpr?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.packElementExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeEachKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var eachKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEachKeywordAndPackRefExpr: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var packRefExpr: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPackRefExpr: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackElementExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeEachKeyword, 
          \Self.eachKeyword, 
          \Self.unexpectedBetweenEachKeywordAndPackRefExpr, 
          \Self.packRefExpr, 
          \Self.unexpectedAfterPackRefExpr
        ])
  }
}

// MARK: - PackExpansionExprSyntax

/// ### Children
/// 
///  - `repeatKeyword`: `'repeat'`
///  - `patternExpr`: ``ExprSyntax``
public struct PackExpansionExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .packExpansionExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PackExpansionExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .packExpansionExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeRepeatKeyword: UnexpectedNodesSyntax? = nil,
      repeatKeyword: TokenSyntax = .keyword(.repeat),
      _ unexpectedBetweenRepeatKeywordAndPatternExpr: UnexpectedNodesSyntax? = nil,
      patternExpr: some ExprSyntaxProtocol,
      _ unexpectedAfterPatternExpr: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeRepeatKeyword, 
            repeatKeyword, 
            unexpectedBetweenRepeatKeywordAndPatternExpr, 
            patternExpr, 
            unexpectedAfterPatternExpr
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeRepeatKeyword?.raw, 
          repeatKeyword.raw, 
          unexpectedBetweenRepeatKeywordAndPatternExpr?.raw, 
          patternExpr.raw, 
          unexpectedAfterPatternExpr?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.packExpansionExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeRepeatKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var repeatKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRepeatKeywordAndPatternExpr: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var patternExpr: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPatternExpr: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PackExpansionExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeRepeatKeyword, 
          \Self.repeatKeyword, 
          \Self.unexpectedBetweenRepeatKeywordAndPatternExpr, 
          \Self.patternExpr, 
          \Self.unexpectedAfterPatternExpr
        ])
  }
}

// MARK: - PostfixIfConfigExprSyntax

/// ### Children
/// 
///  - `base`: ``ExprSyntax``?
///  - `config`: ``IfConfigDeclSyntax``
public struct PostfixIfConfigExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .postfixIfConfigExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PostfixIfConfigExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .postfixIfConfigExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBase: UnexpectedNodesSyntax? = nil,
      base: (some ExprSyntaxProtocol)? = ExprSyntax?.none,
      _ unexpectedBetweenBaseAndConfig: UnexpectedNodesSyntax? = nil,
      config: IfConfigDeclSyntax,
      _ unexpectedAfterConfig: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBase, 
            base, 
            unexpectedBetweenBaseAndConfig, 
            config, 
            unexpectedAfterConfig
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBase?.raw, 
          base?.raw, 
          unexpectedBetweenBaseAndConfig?.raw, 
          config.raw, 
          unexpectedAfterConfig?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.postfixIfConfigExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBase: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var base: ExprSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(ExprSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBaseAndConfig: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var config: IfConfigDeclSyntax {
    get {
      return IfConfigDeclSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterConfig: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixIfConfigExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBase, 
          \Self.base, 
          \Self.unexpectedBetweenBaseAndConfig, 
          \Self.config, 
          \Self.unexpectedAfterConfig
        ])
  }
}

// MARK: - PostfixUnaryExprSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `operator`: `<postfixOperator>`
public struct PostfixUnaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .postfixUnaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PostfixUnaryExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .postfixUnaryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndOperator: UnexpectedNodesSyntax? = nil,
      operator: TokenSyntax,
      _ unexpectedAfterOperator: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndOperator, 
            `operator`, 
            unexpectedAfterOperator
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndOperator?.raw, 
          `operator`.raw, 
          unexpectedAfterOperator?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.postfixUnaryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndOperator: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var `operator`: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterOperator: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PostfixUnaryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndOperator, 
          \Self.operator, 
          \Self.unexpectedAfterOperator
        ])
  }
}

// MARK: - PrefixOperatorExprSyntax

/// ### Children
/// 
///  - `operator`: `<prefixOperator>`?
///  - `postfixExpression`: ``ExprSyntax``
public struct PrefixOperatorExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .prefixOperatorExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrefixOperatorExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .prefixOperatorExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOperator: UnexpectedNodesSyntax? = nil,
      operator: TokenSyntax? = nil,
      _ unexpectedBetweenOperatorAndPostfixExpression: UnexpectedNodesSyntax? = nil,
      postfixExpression: some ExprSyntaxProtocol,
      _ unexpectedAfterPostfixExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeOperator, 
            `operator`, 
            unexpectedBetweenOperatorAndPostfixExpression, 
            postfixExpression, 
            unexpectedAfterPostfixExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeOperator?.raw, 
          `operator`?.raw, 
          unexpectedBetweenOperatorAndPostfixExpression?.raw, 
          postfixExpression.raw, 
          unexpectedAfterPostfixExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.prefixOperatorExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOperator: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var `operator`: TokenSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOperatorAndPostfixExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var postfixExpression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPostfixExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrefixOperatorExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeOperator, 
          \Self.operator, 
          \Self.unexpectedBetweenOperatorAndPostfixExpression, 
          \Self.postfixExpression, 
          \Self.unexpectedAfterPostfixExpression
        ])
  }
}

// MARK: - RegexLiteralExprSyntax

/// ### Children
/// 
///  - `openingPounds`: `<extendedRegexDelimiter>`?
///  - `openSlash`: `'/'`
///  - `regexPattern`: `<regexLiteralPattern>`
///  - `closeSlash`: `'/'`
///  - `closingPounds`: `<extendedRegexDelimiter>`?
public struct RegexLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .regexLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``RegexLiteralExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .regexLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOpeningPounds: UnexpectedNodesSyntax? = nil,
      openingPounds: TokenSyntax? = nil,
      _ unexpectedBetweenOpeningPoundsAndOpenSlash: UnexpectedNodesSyntax? = nil,
      openSlash: TokenSyntax = .regexSlashToken(),
      _ unexpectedBetweenOpenSlashAndRegexPattern: UnexpectedNodesSyntax? = nil,
      regexPattern: TokenSyntax,
      _ unexpectedBetweenRegexPatternAndCloseSlash: UnexpectedNodesSyntax? = nil,
      closeSlash: TokenSyntax = .regexSlashToken(),
      _ unexpectedBetweenCloseSlashAndClosingPounds: UnexpectedNodesSyntax? = nil,
      closingPounds: TokenSyntax? = nil,
      _ unexpectedAfterClosingPounds: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeOpeningPounds, 
            openingPounds, 
            unexpectedBetweenOpeningPoundsAndOpenSlash, 
            openSlash, 
            unexpectedBetweenOpenSlashAndRegexPattern, 
            regexPattern, 
            unexpectedBetweenRegexPatternAndCloseSlash, 
            closeSlash, 
            unexpectedBetweenCloseSlashAndClosingPounds, 
            closingPounds, 
            unexpectedAfterClosingPounds
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeOpeningPounds?.raw, 
          openingPounds?.raw, 
          unexpectedBetweenOpeningPoundsAndOpenSlash?.raw, 
          openSlash.raw, 
          unexpectedBetweenOpenSlashAndRegexPattern?.raw, 
          regexPattern.raw, 
          unexpectedBetweenRegexPatternAndCloseSlash?.raw, 
          closeSlash.raw, 
          unexpectedBetweenCloseSlashAndClosingPounds?.raw, 
          closingPounds?.raw, 
          unexpectedAfterClosingPounds?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.regexLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOpeningPounds: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var openingPounds: TokenSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOpeningPoundsAndOpenSlash: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var openSlash: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOpenSlashAndRegexPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var regexPattern: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRegexPatternAndCloseSlash: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var closeSlash: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCloseSlashAndClosingPounds: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var closingPounds: TokenSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterClosingPounds: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = RegexLiteralExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeOpeningPounds, 
          \Self.openingPounds, 
          \Self.unexpectedBetweenOpeningPoundsAndOpenSlash, 
          \Self.openSlash, 
          \Self.unexpectedBetweenOpenSlashAndRegexPattern, 
          \Self.regexPattern, 
          \Self.unexpectedBetweenRegexPatternAndCloseSlash, 
          \Self.closeSlash, 
          \Self.unexpectedBetweenCloseSlashAndClosingPounds, 
          \Self.closingPounds, 
          \Self.unexpectedAfterClosingPounds
        ])
  }
}

// MARK: - SequenceExprSyntax

/// ### Children
/// 
///  - `elements`: ``ExprListSyntax``
public struct SequenceExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .sequenceExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``SequenceExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .sequenceExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeElements: UnexpectedNodesSyntax? = nil,
      elements: ExprListSyntax,
      _ unexpectedAfterElements: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeElements, elements, unexpectedAfterElements))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeElements?.raw, elements.raw, unexpectedAfterElements?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.sequenceExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SequenceExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elements: ExprListSyntax {
    get {
      return ExprListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SequenceExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: ExprSyntax) -> SequenceExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.exprList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return SequenceExprSyntax(newData)
  }
  
  public var unexpectedAfterElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SequenceExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeElements, \Self.elements, \Self.unexpectedAfterElements])
  }
}

// MARK: - SpecializeExprSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `genericArgumentClause`: ``GenericArgumentClauseSyntax``
public struct SpecializeExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .specializeExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``SpecializeExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .specializeExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      genericArgumentClause: GenericArgumentClauseSyntax,
      _ unexpectedAfterGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndGenericArgumentClause, 
            genericArgumentClause, 
            unexpectedAfterGenericArgumentClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndGenericArgumentClause?.raw, 
          genericArgumentClause.raw, 
          unexpectedAfterGenericArgumentClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.specializeExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var genericArgumentClause: GenericArgumentClauseSyntax {
    get {
      return GenericArgumentClauseSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SpecializeExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndGenericArgumentClause, 
          \Self.genericArgumentClause, 
          \Self.unexpectedAfterGenericArgumentClause
        ])
  }
}

// MARK: - StringLiteralExprSyntax

/// ### Children
/// 
///  - `openDelimiter`: `<rawStringDelimiter>`?
///  - `openQuote`: (`'"'` | `'"""'` | `'''`)
///  - `segments`: ``StringLiteralSegmentsSyntax``
///  - `closeQuote`: (`'"'` | `'"""'` | `'''`)
///  - `closeDelimiter`: `<rawStringDelimiter>`?
public struct StringLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .stringLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``StringLiteralExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .stringLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOpenDelimiter: UnexpectedNodesSyntax? = nil,
      openDelimiter: TokenSyntax? = nil,
      _ unexpectedBetweenOpenDelimiterAndOpenQuote: UnexpectedNodesSyntax? = nil,
      openQuote: TokenSyntax,
      _ unexpectedBetweenOpenQuoteAndSegments: UnexpectedNodesSyntax? = nil,
      segments: StringLiteralSegmentsSyntax,
      _ unexpectedBetweenSegmentsAndCloseQuote: UnexpectedNodesSyntax? = nil,
      closeQuote: TokenSyntax,
      _ unexpectedBetweenCloseQuoteAndCloseDelimiter: UnexpectedNodesSyntax? = nil,
      closeDelimiter: TokenSyntax? = nil,
      _ unexpectedAfterCloseDelimiter: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeOpenDelimiter, 
            openDelimiter, 
            unexpectedBetweenOpenDelimiterAndOpenQuote, 
            openQuote, 
            unexpectedBetweenOpenQuoteAndSegments, 
            segments, 
            unexpectedBetweenSegmentsAndCloseQuote, 
            closeQuote, 
            unexpectedBetweenCloseQuoteAndCloseDelimiter, 
            closeDelimiter, 
            unexpectedAfterCloseDelimiter
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeOpenDelimiter?.raw, 
          openDelimiter?.raw, 
          unexpectedBetweenOpenDelimiterAndOpenQuote?.raw, 
          openQuote.raw, 
          unexpectedBetweenOpenQuoteAndSegments?.raw, 
          segments.raw, 
          unexpectedBetweenSegmentsAndCloseQuote?.raw, 
          closeQuote.raw, 
          unexpectedBetweenCloseQuoteAndCloseDelimiter?.raw, 
          closeDelimiter?.raw, 
          unexpectedAfterCloseDelimiter?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.stringLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOpenDelimiter: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var openDelimiter: TokenSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOpenDelimiterAndOpenQuote: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var openQuote: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOpenQuoteAndSegments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var segments: StringLiteralSegmentsSyntax {
    get {
      return StringLiteralSegmentsSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `segments`
  /// collection.
  /// - param element: The new `Segment` to add to the node's
  ///                  `segments` collection.
  /// - returns: A copy of the receiver with the provided `Segment`
  ///            appended to its `segments` collection.
  public func addSegment(_ element: Syntax) -> StringLiteralExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.stringLiteralSegments,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return StringLiteralExprSyntax(newData)
  }
  
  public var unexpectedBetweenSegmentsAndCloseQuote: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var closeQuote: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCloseQuoteAndCloseDelimiter: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var closeDelimiter: TokenSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterCloseDelimiter: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StringLiteralExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeOpenDelimiter, 
          \Self.openDelimiter, 
          \Self.unexpectedBetweenOpenDelimiterAndOpenQuote, 
          \Self.openQuote, 
          \Self.unexpectedBetweenOpenQuoteAndSegments, 
          \Self.segments, 
          \Self.unexpectedBetweenSegmentsAndCloseQuote, 
          \Self.closeQuote, 
          \Self.unexpectedBetweenCloseQuoteAndCloseDelimiter, 
          \Self.closeDelimiter, 
          \Self.unexpectedAfterCloseDelimiter
        ])
  }
}

// MARK: - SubscriptExprSyntax

/// ### Children
/// 
///  - `calledExpression`: ``ExprSyntax``
///  - `leftSquare`: `'['`
///  - `argumentList`: ``TupleExprElementListSyntax``
///  - `rightSquare`: `']'`
///  - `trailingClosure`: ``ClosureExprSyntax``?
///  - `additionalTrailingClosures`: ``MultipleTrailingClosureElementListSyntax``
public struct SubscriptExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .subscriptExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``SubscriptExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .subscriptExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? = nil,
      calledExpression: some ExprSyntaxProtocol,
      _ unexpectedBetweenCalledExpressionAndLeftSquare: UnexpectedNodesSyntax? = nil,
      leftSquare: TokenSyntax = .leftSquareToken(),
      _ unexpectedBetweenLeftSquareAndArgumentList: UnexpectedNodesSyntax? = nil,
      argumentList: TupleExprElementListSyntax,
      _ unexpectedBetweenArgumentListAndRightSquare: UnexpectedNodesSyntax? = nil,
      rightSquare: TokenSyntax = .rightSquareToken(),
      _ unexpectedBetweenRightSquareAndTrailingClosure: UnexpectedNodesSyntax? = nil,
      trailingClosure: ClosureExprSyntax? = nil,
      _ unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? = nil,
      _ unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCalledExpression, 
            calledExpression, 
            unexpectedBetweenCalledExpressionAndLeftSquare, 
            leftSquare, 
            unexpectedBetweenLeftSquareAndArgumentList, 
            argumentList, 
            unexpectedBetweenArgumentListAndRightSquare, 
            rightSquare, 
            unexpectedBetweenRightSquareAndTrailingClosure, 
            trailingClosure, 
            unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
            additionalTrailingClosures, 
            unexpectedAfterAdditionalTrailingClosures
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCalledExpression?.raw, 
          calledExpression.raw, 
          unexpectedBetweenCalledExpressionAndLeftSquare?.raw, 
          leftSquare.raw, 
          unexpectedBetweenLeftSquareAndArgumentList?.raw, 
          argumentList.raw, 
          unexpectedBetweenArgumentListAndRightSquare?.raw, 
          rightSquare.raw, 
          unexpectedBetweenRightSquareAndTrailingClosure?.raw, 
          trailingClosure?.raw, 
          unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.raw, 
          additionalTrailingClosures?.raw, 
          unexpectedAfterAdditionalTrailingClosures?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.subscriptExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var calledExpression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCalledExpressionAndLeftSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftSquareAndArgumentList: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var argumentList: TupleExprElementListSyntax {
    get {
      return TupleExprElementListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `argumentList`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `argumentList` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `argumentList` collection.
  public func addArgument(_ element: TupleExprElementSyntax) -> SubscriptExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleExprElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return SubscriptExprSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentListAndRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRightSquareAndTrailingClosure: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingClosure: ClosureExprSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(ClosureExprSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(MultipleTrailingClosureElementListSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `additionalTrailingClosures`
  /// collection.
  /// - param element: The new `AdditionalTrailingClosure` to add to the node's
  ///                  `additionalTrailingClosures` collection.
  /// - returns: A copy of the receiver with the provided `AdditionalTrailingClosure`
  ///            appended to its `additionalTrailingClosures` collection.
  public func addAdditionalTrailingClosure(_ element: MultipleTrailingClosureElementSyntax) -> SubscriptExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[11] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.multipleTrailingClosureElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 11, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return SubscriptExprSyntax(newData)
  }
  
  public var unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptExprSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCalledExpression, 
          \Self.calledExpression, 
          \Self.unexpectedBetweenCalledExpressionAndLeftSquare, 
          \Self.leftSquare, 
          \Self.unexpectedBetweenLeftSquareAndArgumentList, 
          \Self.argumentList, 
          \Self.unexpectedBetweenArgumentListAndRightSquare, 
          \Self.rightSquare, 
          \Self.unexpectedBetweenRightSquareAndTrailingClosure, 
          \Self.trailingClosure, 
          \Self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
          \Self.additionalTrailingClosures, 
          \Self.unexpectedAfterAdditionalTrailingClosures
        ])
  }
}

// MARK: - SuperRefExprSyntax

/// ### Children
/// 
///  - `superKeyword`: `'super'`
public struct SuperRefExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .superRefExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``SuperRefExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .superRefExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeSuperKeyword: UnexpectedNodesSyntax? = nil,
      superKeyword: TokenSyntax = .keyword(.super),
      _ unexpectedAfterSuperKeyword: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeSuperKeyword, superKeyword, unexpectedAfterSuperKeyword))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeSuperKeyword?.raw, superKeyword.raw, unexpectedAfterSuperKeyword?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.superRefExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeSuperKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SuperRefExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var superKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SuperRefExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterSuperKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SuperRefExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeSuperKeyword, \Self.superKeyword, \Self.unexpectedAfterSuperKeyword])
  }
}

// MARK: - SwitchExprSyntax

/// ### Children
/// 
///  - `switchKeyword`: `'switch'`
///  - `expression`: ``ExprSyntax``
///  - `leftBrace`: `'{'`
///  - `cases`: ``SwitchCaseListSyntax``
///  - `rightBrace`: `'}'`
public struct SwitchExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .switchExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``SwitchExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .switchExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeSwitchKeyword: UnexpectedNodesSyntax? = nil,
      switchKeyword: TokenSyntax = .keyword(.switch),
      _ unexpectedBetweenSwitchKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndLeftBrace: UnexpectedNodesSyntax? = nil,
      leftBrace: TokenSyntax = .leftBraceToken(),
      _ unexpectedBetweenLeftBraceAndCases: UnexpectedNodesSyntax? = nil,
      cases: SwitchCaseListSyntax,
      _ unexpectedBetweenCasesAndRightBrace: UnexpectedNodesSyntax? = nil,
      rightBrace: TokenSyntax = .rightBraceToken(),
      _ unexpectedAfterRightBrace: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeSwitchKeyword, 
            switchKeyword, 
            unexpectedBetweenSwitchKeywordAndExpression, 
            expression, 
            unexpectedBetweenExpressionAndLeftBrace, 
            leftBrace, 
            unexpectedBetweenLeftBraceAndCases, 
            cases, 
            unexpectedBetweenCasesAndRightBrace, 
            rightBrace, 
            unexpectedAfterRightBrace
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeSwitchKeyword?.raw, 
          switchKeyword.raw, 
          unexpectedBetweenSwitchKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndLeftBrace?.raw, 
          leftBrace.raw, 
          unexpectedBetweenLeftBraceAndCases?.raw, 
          cases.raw, 
          unexpectedBetweenCasesAndRightBrace?.raw, 
          rightBrace.raw, 
          unexpectedAfterRightBrace?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.switchExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeSwitchKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var switchKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSwitchKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndLeftBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftBraceAndCases: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var cases: SwitchCaseListSyntax {
    get {
      return SwitchCaseListSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `cases`
  /// collection.
  /// - param element: The new `Case` to add to the node's
  ///                  `cases` collection.
  /// - returns: A copy of the receiver with the provided `Case`
  ///            appended to its `cases` collection.
  public func addCase(_ element: Syntax) -> SwitchExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[7] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.switchCaseList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 7, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return SwitchExprSyntax(newData)
  }
  
  public var unexpectedBetweenCasesAndRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SwitchExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeSwitchKeyword, 
          \Self.switchKeyword, 
          \Self.unexpectedBetweenSwitchKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndLeftBrace, 
          \Self.leftBrace, 
          \Self.unexpectedBetweenLeftBraceAndCases, 
          \Self.cases, 
          \Self.unexpectedBetweenCasesAndRightBrace, 
          \Self.rightBrace, 
          \Self.unexpectedAfterRightBrace
        ])
  }
}

// MARK: - TernaryExprSyntax

/// ### Children
/// 
///  - `conditionExpression`: ``ExprSyntax``
///  - `questionMark`: `'?'`
///  - `firstChoice`: ``ExprSyntax``
///  - `colon`: `':'`
///  - `secondChoice`: ``ExprSyntax``
public struct TernaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .ternaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``TernaryExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .ternaryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeConditionExpression: UnexpectedNodesSyntax? = nil,
      conditionExpression: some ExprSyntaxProtocol,
      _ unexpectedBetweenConditionExpressionAndQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .infixQuestionMarkToken(),
      _ unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodesSyntax? = nil,
      firstChoice: some ExprSyntaxProtocol,
      _ unexpectedBetweenFirstChoiceAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndSecondChoice: UnexpectedNodesSyntax? = nil,
      secondChoice: some ExprSyntaxProtocol,
      _ unexpectedAfterSecondChoice: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeConditionExpression, 
            conditionExpression, 
            unexpectedBetweenConditionExpressionAndQuestionMark, 
            questionMark, 
            unexpectedBetweenQuestionMarkAndFirstChoice, 
            firstChoice, 
            unexpectedBetweenFirstChoiceAndColon, 
            colon, 
            unexpectedBetweenColonAndSecondChoice, 
            secondChoice, 
            unexpectedAfterSecondChoice
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeConditionExpression?.raw, 
          conditionExpression.raw, 
          unexpectedBetweenConditionExpressionAndQuestionMark?.raw, 
          questionMark.raw, 
          unexpectedBetweenQuestionMarkAndFirstChoice?.raw, 
          firstChoice.raw, 
          unexpectedBetweenFirstChoiceAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndSecondChoice?.raw, 
          secondChoice.raw, 
          unexpectedAfterSecondChoice?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.ternaryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeConditionExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var conditionExpression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenConditionExpressionAndQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var firstChoice: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFirstChoiceAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndSecondChoice: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var secondChoice: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterSecondChoice: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TernaryExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeConditionExpression, 
          \Self.conditionExpression, 
          \Self.unexpectedBetweenConditionExpressionAndQuestionMark, 
          \Self.questionMark, 
          \Self.unexpectedBetweenQuestionMarkAndFirstChoice, 
          \Self.firstChoice, 
          \Self.unexpectedBetweenFirstChoiceAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndSecondChoice, 
          \Self.secondChoice, 
          \Self.unexpectedAfterSecondChoice
        ])
  }
}

// MARK: - TryExprSyntax

/// ### Children
/// 
///  - `tryKeyword`: `'try'`
///  - `questionOrExclamationMark`: (`'?'` | `'!'`)?
///  - `expression`: ``ExprSyntax``
public struct TryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .tryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``TryExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .tryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeTryKeyword: UnexpectedNodesSyntax? = nil,
      tryKeyword: TokenSyntax = .keyword(.try),
      _ unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      questionOrExclamationMark: TokenSyntax? = nil,
      _ unexpectedBetweenQuestionOrExclamationMarkAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeTryKeyword, 
            tryKeyword, 
            unexpectedBetweenTryKeywordAndQuestionOrExclamationMark, 
            questionOrExclamationMark, 
            unexpectedBetweenQuestionOrExclamationMarkAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeTryKeyword?.raw, 
          tryKeyword.raw, 
          unexpectedBetweenTryKeywordAndQuestionOrExclamationMark?.raw, 
          questionOrExclamationMark?.raw, 
          unexpectedBetweenQuestionOrExclamationMarkAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeTryKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var tryKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenQuestionOrExclamationMarkAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TryExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeTryKeyword, 
          \Self.tryKeyword, 
          \Self.unexpectedBetweenTryKeywordAndQuestionOrExclamationMark, 
          \Self.questionOrExclamationMark, 
          \Self.unexpectedBetweenQuestionOrExclamationMarkAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - TupleExprSyntax

/// ### Children
/// 
///  - `leftParen`: `'('`
///  - `elements`: ``TupleExprElementListSyntax``
///  - `rightParen`: `')'`
public struct TupleExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .tupleExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``TupleExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .tupleExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? = nil,
      elements: TupleExprElementListSyntax,
      _ unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndElements, 
            elements, 
            unexpectedBetweenElementsAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndElements?.raw, 
          elements.raw, 
          unexpectedBetweenElementsAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.tupleExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elements: TupleExprElementListSyntax {
    get {
      return TupleExprElementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: TupleExprElementSyntax) -> TupleExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleExprElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return TupleExprSyntax(newData)
  }
  
  public var unexpectedBetweenElementsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TupleExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndElements, 
          \Self.elements, 
          \Self.unexpectedBetweenElementsAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - TypeExprSyntax

/// ### Children
/// 
///  - `type`: ``TypeSyntax``
public struct TypeExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .typeExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``TypeExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .typeExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedAfterType: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeType, type, unexpectedAfterType))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeType?.raw, type.raw, unexpectedAfterType?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.typeExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var type: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = TypeExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeType, \Self.type, \Self.unexpectedAfterType])
  }
}

// MARK: - UnresolvedAsExprSyntax

/// ### Children
/// 
///  - `asKeyword`: `'as'`
///  - `questionOrExclamationMark`: (`'?'` | `'!'`)?
public struct UnresolvedAsExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .unresolvedAsExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``UnresolvedAsExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .unresolvedAsExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAsKeyword: UnexpectedNodesSyntax? = nil,
      asKeyword: TokenSyntax = .keyword(.as),
      _ unexpectedBetweenAsKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      questionOrExclamationMark: TokenSyntax? = nil,
      _ unexpectedAfterQuestionOrExclamationMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAsKeyword, 
            asKeyword, 
            unexpectedBetweenAsKeywordAndQuestionOrExclamationMark, 
            questionOrExclamationMark, 
            unexpectedAfterQuestionOrExclamationMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAsKeyword?.raw, 
          asKeyword.raw, 
          unexpectedBetweenAsKeywordAndQuestionOrExclamationMark?.raw, 
          questionOrExclamationMark?.raw, 
          unexpectedAfterQuestionOrExclamationMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedAsExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAsKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var asKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAsKeywordAndQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionOrExclamationMark: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterQuestionOrExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedAsExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAsKeyword, 
          \Self.asKeyword, 
          \Self.unexpectedBetweenAsKeywordAndQuestionOrExclamationMark, 
          \Self.questionOrExclamationMark, 
          \Self.unexpectedAfterQuestionOrExclamationMark
        ])
  }
}

// MARK: - UnresolvedIsExprSyntax

/// ### Children
/// 
///  - `isKeyword`: `'is'`
public struct UnresolvedIsExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .unresolvedIsExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``UnresolvedIsExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .unresolvedIsExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIsKeyword: UnexpectedNodesSyntax? = nil,
      isKeyword: TokenSyntax = .keyword(.is),
      _ unexpectedAfterIsKeyword: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeIsKeyword, isKeyword, unexpectedAfterIsKeyword))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeIsKeyword?.raw, isKeyword.raw, unexpectedAfterIsKeyword?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedIsExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIsKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedIsExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var isKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedIsExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterIsKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedIsExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeIsKeyword, \Self.isKeyword, \Self.unexpectedAfterIsKeyword])
  }
}

// MARK: - UnresolvedPatternExprSyntax

/// ### Children
/// 
///  - `pattern`: ``PatternSyntax``
public struct UnresolvedPatternExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .unresolvedPatternExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``UnresolvedPatternExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .unresolvedPatternExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePattern: UnexpectedNodesSyntax? = nil,
      pattern: some PatternSyntaxProtocol,
      _ unexpectedAfterPattern: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforePattern, pattern, unexpectedAfterPattern))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforePattern?.raw, pattern.raw, unexpectedAfterPattern?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedPatternExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedPatternExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var pattern: PatternSyntax {
    get {
      return PatternSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedPatternExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedPatternExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforePattern, \Self.pattern, \Self.unexpectedAfterPattern])
  }
}

// MARK: - UnresolvedTernaryExprSyntax

/// ### Children
/// 
///  - `questionMark`: `'?'`
///  - `firstChoice`: ``ExprSyntax``
///  - `colon`: `':'`
public struct UnresolvedTernaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .unresolvedTernaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``UnresolvedTernaryExprSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .unresolvedTernaryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeQuestionMark: UnexpectedNodesSyntax? = nil,
      questionMark: TokenSyntax = .infixQuestionMarkToken(),
      _ unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodesSyntax? = nil,
      firstChoice: some ExprSyntaxProtocol,
      _ unexpectedBetweenFirstChoiceAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedAfterColon: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeQuestionMark, 
            questionMark, 
            unexpectedBetweenQuestionMarkAndFirstChoice, 
            firstChoice, 
            unexpectedBetweenFirstChoiceAndColon, 
            colon, 
            unexpectedAfterColon
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeQuestionMark?.raw, 
          questionMark.raw, 
          unexpectedBetweenQuestionMarkAndFirstChoice?.raw, 
          firstChoice.raw, 
          unexpectedBetweenFirstChoiceAndColon?.raw, 
          colon.raw, 
          unexpectedAfterColon?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.unresolvedTernaryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeQuestionMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var questionMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var firstChoice: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFirstChoiceAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = UnresolvedTernaryExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeQuestionMark, 
          \Self.questionMark, 
          \Self.unexpectedBetweenQuestionMarkAndFirstChoice, 
          \Self.firstChoice, 
          \Self.unexpectedBetweenFirstChoiceAndColon, 
          \Self.colon, 
          \Self.unexpectedAfterColon
        ])
  }
}
