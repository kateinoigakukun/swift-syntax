//// Automatically generated by generate-swiftsyntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - AccessorDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifier`: ``DeclModifierSyntax``?
///  - `accessorSpecifier`: (`'get'` | `'set'` | `'didSet'` | `'willSet'` | `'unsafeAddress'` | `'addressWithOwner'` | `'addressWithNativeOwner'` | `'unsafeMutableAddress'` | `'mutableAddressWithOwner'` | `'mutableAddressWithNativeOwner'` | `'_read'` | `'_modify'` | `'init'`)
///  - `parameters`: ``AccessorParametersSyntax``?
///  - `effectSpecifiers`: ``AccessorEffectSpecifiersSyntax``?
///  - `body`: ``CodeBlockSyntax``?
///
/// ### Contained in
/// 
///  - ``AccessorDeclListSyntax``
public struct AccessorDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .accessorDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``AccessorDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .accessorDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifier: UnexpectedNodesSyntax? = nil,
      modifier: DeclModifierSyntax? = nil,
      _ unexpectedBetweenModifierAndAccessorSpecifier: UnexpectedNodesSyntax? = nil,
      accessorSpecifier: TokenSyntax,
      _ unexpectedBetweenAccessorSpecifierAndParameters: UnexpectedNodesSyntax? = nil,
      parameters: AccessorParametersSyntax? = nil,
      _ unexpectedBetweenParametersAndEffectSpecifiers: UnexpectedNodesSyntax? = nil,
      effectSpecifiers: AccessorEffectSpecifiersSyntax? = nil,
      _ unexpectedBetweenEffectSpecifiersAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax? = nil,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifier, 
            modifier, 
            unexpectedBetweenModifierAndAccessorSpecifier, 
            accessorSpecifier, 
            unexpectedBetweenAccessorSpecifierAndParameters, 
            parameters, 
            unexpectedBetweenParametersAndEffectSpecifiers, 
            effectSpecifiers, 
            unexpectedBetweenEffectSpecifiersAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifier?.raw, 
          modifier?.raw, 
          unexpectedBetweenModifierAndAccessorSpecifier?.raw, 
          accessorSpecifier.raw, 
          unexpectedBetweenAccessorSpecifierAndParameters?.raw, 
          parameters?.raw, 
          unexpectedBetweenParametersAndEffectSpecifiers?.raw, 
          effectSpecifiers?.raw, 
          unexpectedBetweenEffectSpecifiersAndBody?.raw, 
          body?.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.accessorDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> AccessorDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return AccessorDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifier: DeclModifierSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenModifierAndAccessorSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var accessorSpecifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAccessorSpecifierAndParameters: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var parameters: AccessorParametersSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(AccessorParametersSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenParametersAndEffectSpecifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var effectSpecifiers: AccessorEffectSpecifiersSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(AccessorEffectSpecifiersSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEffectSpecifiersAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(CodeBlockSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AccessorDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifier, 
          \Self.modifier, 
          \Self.unexpectedBetweenModifierAndAccessorSpecifier, 
          \Self.accessorSpecifier, 
          \Self.unexpectedBetweenAccessorSpecifierAndParameters, 
          \Self.parameters, 
          \Self.unexpectedBetweenParametersAndEffectSpecifiers, 
          \Self.effectSpecifiers, 
          \Self.unexpectedBetweenEffectSpecifiersAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - ActorDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `actorKeyword`: `'actor'`
///  - `name`: `<identifier>`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct ActorDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .actorDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ActorDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .actorDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - genericParameterClause: The parameter clause that defines the generic parameters.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndActorKeyword: UnexpectedNodesSyntax? = nil,
      actorKeyword: TokenSyntax = .keyword(.actor),
      _ unexpectedBetweenActorKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndActorKeyword, 
            actorKeyword, 
            unexpectedBetweenActorKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndActorKeyword?.raw, 
          actorKeyword.raw, 
          unexpectedBetweenActorKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.actorDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> ActorDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ActorDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ActorDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ActorDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndActorKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var actorKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenActorKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The parameter clause that defines the generic parameters.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 15, parent: Syntax(self))!)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 15, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ActorDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndActorKeyword, 
          \Self.actorKeyword, 
          \Self.unexpectedBetweenActorKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}

// MARK: - AssociatedTypeDeclSyntax

/// An associated type declaration like the following.
/// 
/// ```swift
/// associatedtype Item
/// ```
/// 
/// An associated type declaration may contain a type initializer clause which represents a default type assignment for the associated type.
/// 
/// ```swift
/// associatedtype Item = Int
/// ```
/// 
/// An associated type declaration may be declared with an inheritance clause which specifies the required conformances.
/// 
/// ```swift
/// associatedtype Iterator: IteratorProtocol
/// ```
/// 
/// A generic where clause may be present, here is an example which shows an associated type containing an inheritance clauses and a generic where clause.
/// 
/// ```swift
/// associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
/// ```
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `associatedtypeKeyword`: `'associatedtype'`
///  - `name`: `<identifier>`
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `initializer`: ``TypeInitializerClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
public struct AssociatedTypeDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .associatedTypeDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``AssociatedTypeDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .associatedTypeDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes attached to the associated type declaration.
  ///   - modifiers: Modifiers attached to the associated type declaration.
  ///   - associatedtypeKeyword: The `associatedtype` keyword for this declaration.
  ///   - name: The name of this associated type.
  ///   - inheritanceClause: The inheritance clause describing conformances for this associated type declaration.
  ///   - initializer: The type initializer clause for this associated type declaration which represents a default type assignment for the associated type.
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters of this associated type declaration.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndAssociatedtypeKeyword: UnexpectedNodesSyntax? = nil,
      associatedtypeKeyword: TokenSyntax = .keyword(.associatedtype),
      _ unexpectedBetweenAssociatedtypeKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndInitializer: UnexpectedNodesSyntax? = nil,
      initializer: TypeInitializerClauseSyntax? = nil,
      _ unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndAssociatedtypeKeyword, 
            associatedtypeKeyword, 
            unexpectedBetweenAssociatedtypeKeywordAndName, 
            name, 
            unexpectedBetweenNameAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndInitializer, 
            initializer, 
            unexpectedBetweenInitializerAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedAfterGenericWhereClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndAssociatedtypeKeyword?.raw, 
          associatedtypeKeyword.raw, 
          unexpectedBetweenAssociatedtypeKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndInitializer?.raw, 
          initializer?.raw, 
          unexpectedBetweenInitializerAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedAfterGenericWhereClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.associatedTypeDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes attached to the associated type declaration.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> AssociatedTypeDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return AssociatedTypeDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers attached to the associated type declaration.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> AssociatedTypeDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return AssociatedTypeDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndAssociatedtypeKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `associatedtype` keyword for this declaration.
  public var associatedtypeKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAssociatedtypeKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of this associated type.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The inheritance clause describing conformances for this associated type declaration.
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndInitializer: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The type initializer clause for this associated type declaration which represents a default type assignment for the associated type.
  public var initializer: TypeInitializerClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(TypeInitializerClauseSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `where` clause that applies to the generic parameters of this associated type declaration.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = AssociatedTypeDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndAssociatedtypeKeyword, 
          \Self.associatedtypeKeyword, 
          \Self.unexpectedBetweenAssociatedtypeKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndInitializer, 
          \Self.initializer, 
          \Self.unexpectedBetweenInitializerAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedAfterGenericWhereClause
        ])
  }
}

// MARK: - ClassDeclSyntax

/// A class declaration like the following.
/// 
/// ```swift
/// class SomeClass {
///   let someMember: String
/// 
///   init(someMember: String) {
///     self.someMember = someMember
///   }
/// 
///   func foo() {
///     print(someMember)
///   }
/// 
///   static func bar() -> Int {
///     return 1
///   }
/// }
/// ```
/// 
/// A class declaration may be declared without any members.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `classKeyword`: `'class'`
///  - `name`: `<identifier>`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct ClassDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .classDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ClassDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .classDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes attached to the class declaration, such as an `@available` attribute.
  ///   - modifiers: Modifiers attached to the class declaration, such as `public`.
  ///   - classKeyword: The `class` keyword for this declaration.
  ///   - name: The name of the class.
  ///   - genericParameterClause: The generic parameters, if any, of the class declaration.
  ///   - inheritanceClause: The inheritance clause describing one or more conformances for this class declaration.
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters of this class declaration.
  ///   - memberBlock: The members of the class declaration. As class extension declarations may declare additional members, the contents of this member block isn't guaranteed to be a complete list of members for this type.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndClassKeyword: UnexpectedNodesSyntax? = nil,
      classKeyword: TokenSyntax = .keyword(.class),
      _ unexpectedBetweenClassKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndClassKeyword, 
            classKeyword, 
            unexpectedBetweenClassKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndClassKeyword?.raw, 
          classKeyword.raw, 
          unexpectedBetweenClassKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.classDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes attached to the class declaration, such as an `@available` attribute.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> ClassDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClassDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers attached to the class declaration, such as `public`.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ClassDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ClassDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndClassKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `class` keyword for this declaration.
  public var classKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenClassKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of the class.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The generic parameters, if any, of the class declaration.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The inheritance clause describing one or more conformances for this class declaration.
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `where` clause that applies to the generic parameters of this class declaration.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The members of the class declaration. As class extension declarations may declare additional members, the contents of this member block isn't guaranteed to be a complete list of members for this type.
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 15, parent: Syntax(self))!)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 15, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ClassDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndClassKeyword, 
          \Self.classKeyword, 
          \Self.unexpectedBetweenClassKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}

// MARK: - DeinitializerDeclSyntax

/// A deinitializer declaration like the following.
/// 
/// ```swift
/// deinit {
/// }
/// ```
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `deinitKeyword`: `'deinit'`
///  - `effectSpecifiers`: ``DeinitializerEffectSpecifiersSyntax``?
///  - `body`: ``CodeBlockSyntax``?
public struct DeinitializerDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .deinitializerDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DeinitializerDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .deinitializerDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes that are attached to the deinitializer.
  ///   - modifiers: Modifiers that are attached to the deinitializer.
  ///   - deinitKeyword: The deinit keyword.
  ///   - body: The deinitializer's body.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndDeinitKeyword: UnexpectedNodesSyntax? = nil,
      deinitKeyword: TokenSyntax = .keyword(.deinit),
      _ unexpectedBetweenDeinitKeywordAndEffectSpecifiers: UnexpectedNodesSyntax? = nil,
      effectSpecifiers: DeinitializerEffectSpecifiersSyntax? = nil,
      _ unexpectedBetweenEffectSpecifiersAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax? = nil,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndDeinitKeyword, 
            deinitKeyword, 
            unexpectedBetweenDeinitKeywordAndEffectSpecifiers, 
            effectSpecifiers, 
            unexpectedBetweenEffectSpecifiersAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndDeinitKeyword?.raw, 
          deinitKeyword.raw, 
          unexpectedBetweenDeinitKeywordAndEffectSpecifiers?.raw, 
          effectSpecifiers?.raw, 
          unexpectedBetweenEffectSpecifiersAndBody?.raw, 
          body?.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.deinitializerDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes that are attached to the deinitializer.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> DeinitializerDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return DeinitializerDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers that are attached to the deinitializer.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> DeinitializerDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return DeinitializerDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndDeinitKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The deinit keyword.
  public var deinitKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDeinitKeywordAndEffectSpecifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var effectSpecifiers: DeinitializerEffectSpecifiersSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(DeinitializerEffectSpecifiersSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEffectSpecifiersAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The deinitializer's body.
  public var body: CodeBlockSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(CodeBlockSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndDeinitKeyword, 
          \Self.deinitKeyword, 
          \Self.unexpectedBetweenDeinitKeywordAndEffectSpecifiers, 
          \Self.effectSpecifiers, 
          \Self.unexpectedBetweenEffectSpecifiersAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - EditorPlaceholderDeclSyntax

/// An editor placeholder, e.g. `<#declaration#>` that is used in a position that expects a declaration.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `placeholder`: `<identifier>`
public struct EditorPlaceholderDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .editorPlaceholderDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EditorPlaceholderDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .editorPlaceholderDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: If there were attributes before the editor placeholder, the ``EditorPlaceholderDeclSyntax`` will contain these.
  ///   - modifiers: If there were modifiers before the editor placeholder, the `EditorPlaceholderDecl` will contain these.
  ///   - placeholder: The actual editor placeholder that starts with `<#` and ends with `#>`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndPlaceholder: UnexpectedNodesSyntax? = nil,
      placeholder: TokenSyntax,
      _ unexpectedAfterPlaceholder: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndPlaceholder, 
            placeholder, 
            unexpectedAfterPlaceholder
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndPlaceholder?.raw, 
          placeholder.raw, 
          unexpectedAfterPlaceholder?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.editorPlaceholderDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If there were attributes before the editor placeholder, the ``EditorPlaceholderDeclSyntax`` will contain these.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> EditorPlaceholderDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EditorPlaceholderDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If there were modifiers before the editor placeholder, the `EditorPlaceholderDecl` will contain these.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> EditorPlaceholderDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EditorPlaceholderDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndPlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The actual editor placeholder that starts with `<#` and ends with `#>`.
  public var placeholder: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndPlaceholder, 
          \Self.placeholder, 
          \Self.unexpectedAfterPlaceholder
        ])
  }
}

// MARK: - EnumCaseDeclSyntax

/// A `case` declaration of a Swift `enum`. It can have 1 or more `EnumCaseElement`s inside, each declaring a different case of the enum.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `caseKeyword`: `'case'`
///  - `elements`: ``EnumCaseElementListSyntax``
public struct EnumCaseDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .enumCaseDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EnumCaseDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .enumCaseDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: The attributes applied to the case declaration.
  ///   - modifiers: The declaration modifiers applied to the case declaration.
  ///   - caseKeyword: The `case` keyword for this case.
  ///   - elements: The elements this case declares.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndCaseKeyword: UnexpectedNodesSyntax? = nil,
      caseKeyword: TokenSyntax = .keyword(.case),
      _ unexpectedBetweenCaseKeywordAndElements: UnexpectedNodesSyntax? = nil,
      elements: EnumCaseElementListSyntax,
      _ unexpectedAfterElements: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndCaseKeyword, 
            caseKeyword, 
            unexpectedBetweenCaseKeywordAndElements, 
            elements, 
            unexpectedAfterElements
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndCaseKeyword?.raw, 
          caseKeyword.raw, 
          unexpectedBetweenCaseKeywordAndElements?.raw, 
          elements.raw, 
          unexpectedAfterElements?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.enumCaseDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The attributes applied to the case declaration.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumCaseDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The declaration modifiers applied to the case declaration.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumCaseDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndCaseKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `case` keyword for this case.
  public var caseKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCaseKeywordAndElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The elements this case declares.
  public var elements: EnumCaseElementListSyntax {
    get {
      return EnumCaseElementListSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  public func addElement(_ element: EnumCaseElementSyntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[7] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.enumCaseElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 7, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumCaseDeclSyntax(newData)
  }
  
  public var unexpectedAfterElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndCaseKeyword, 
          \Self.caseKeyword, 
          \Self.unexpectedBetweenCaseKeywordAndElements, 
          \Self.elements, 
          \Self.unexpectedAfterElements
        ])
  }
}

// MARK: - EnumDeclSyntax

/// A Swift `enum` declaration.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `enumKeyword`: `'enum'`
///  - `name`: `<identifier>`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct EnumDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .enumDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EnumDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .enumDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: The attributes applied to the enum declaration.
  ///   - modifiers: The declaration modifiers applied to the enum declaration.
  ///   - enumKeyword: The `enum` keyword for this declaration.
  ///   - name: Declares the name of this enum. If the name matches a reserved keyword use backticks to escape it.
  ///   - genericParameterClause: The generic parameters, if any, for this enum declaration.
  ///   - inheritanceClause: The inheritance clause describing conformances or raw values for this enum declaration.
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters of this enum declaration.
  ///   - memberBlock: The cases and other members associated with this enum declaration. Because enum extension declarations may declare additional members the contents of this member block isn't guaranteed to be a complete list of members for this type.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndEnumKeyword: UnexpectedNodesSyntax? = nil,
      enumKeyword: TokenSyntax = .keyword(.enum),
      _ unexpectedBetweenEnumKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndEnumKeyword, 
            enumKeyword, 
            unexpectedBetweenEnumKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndEnumKeyword?.raw, 
          enumKeyword.raw, 
          unexpectedBetweenEnumKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.enumDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The attributes applied to the enum declaration.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> EnumDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The declaration modifiers applied to the enum declaration.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> EnumDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndEnumKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `enum` keyword for this declaration.
  public var enumKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEnumKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Declares the name of this enum. If the name matches a reserved keyword use backticks to escape it.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The generic parameters, if any, for this enum declaration.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The inheritance clause describing conformances or raw values for this enum declaration.
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `where` clause that applies to the generic parameters of this enum declaration.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The cases and other members associated with this enum declaration. Because enum extension declarations may declare additional members the contents of this member block isn't guaranteed to be a complete list of members for this type.
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 15, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 15, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndEnumKeyword, 
          \Self.enumKeyword, 
          \Self.unexpectedBetweenEnumKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}

// MARK: - ExtensionDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `extensionKeyword`: `'extension'`
///  - `extendedType`: ``TypeSyntax``
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct ExtensionDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .extensionDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ExtensionDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .extensionDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndExtensionKeyword: UnexpectedNodesSyntax? = nil,
      extensionKeyword: TokenSyntax = .keyword(.extension),
      _ unexpectedBetweenExtensionKeywordAndExtendedType: UnexpectedNodesSyntax? = nil,
      extendedType: some TypeSyntaxProtocol,
      _ unexpectedBetweenExtendedTypeAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndExtensionKeyword, 
            extensionKeyword, 
            unexpectedBetweenExtensionKeywordAndExtendedType, 
            extendedType, 
            unexpectedBetweenExtendedTypeAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndExtensionKeyword?.raw, 
          extensionKeyword.raw, 
          unexpectedBetweenExtensionKeywordAndExtendedType?.raw, 
          extendedType.raw, 
          unexpectedBetweenExtendedTypeAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.extensionDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> ExtensionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ExtensionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ExtensionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ExtensionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndExtensionKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var extensionKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExtensionKeywordAndExtendedType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var extendedType: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExtendedTypeAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 13, parent: Syntax(self))!)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 13, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndExtensionKeyword, 
          \Self.extensionKeyword, 
          \Self.unexpectedBetweenExtensionKeywordAndExtendedType, 
          \Self.extendedType, 
          \Self.unexpectedBetweenExtendedTypeAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}

// MARK: - FunctionDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `funcKeyword`: `'func'`
///  - `name`: (`<identifier>` | `<binaryOperator>` | `<prefixOperator>` | `<postfixOperator>`)
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `signature`: ``FunctionSignatureSyntax``
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `body`: ``CodeBlockSyntax``?
public struct FunctionDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FunctionDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - genericParameterClause: The parameter clause that defines the generic parameters.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndFuncKeyword: UnexpectedNodesSyntax? = nil,
      funcKeyword: TokenSyntax = .keyword(.func),
      _ unexpectedBetweenFuncKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? = nil,
      signature: FunctionSignatureSyntax,
      _ unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax? = nil,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndFuncKeyword, 
            funcKeyword, 
            unexpectedBetweenFuncKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndSignature, 
            signature, 
            unexpectedBetweenSignatureAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndFuncKeyword?.raw, 
          funcKeyword.raw, 
          unexpectedBetweenFuncKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndSignature?.raw, 
          signature.raw, 
          unexpectedBetweenSignatureAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndBody?.raw, 
          body?.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> FunctionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> FunctionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndFuncKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var funcKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFuncKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The parameter clause that defines the generic parameters.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var signature: FunctionSignatureSyntax {
    get {
      return FunctionSignatureSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(CodeBlockSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndFuncKeyword, 
          \Self.funcKeyword, 
          \Self.unexpectedBetweenFuncKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndSignature, 
          \Self.signature, 
          \Self.unexpectedBetweenSignatureAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - IfConfigDeclSyntax

/// ### Children
/// 
///  - `clauses`: ``IfConfigClauseListSyntax``
///  - `poundEndif`: `'#endif'`
///
/// ### Contained in
/// 
///  - ``AttributeListSyntax``
///  - ``PostfixIfConfigExprSyntax``.``PostfixIfConfigExprSyntax/config``
///  - ``SwitchCaseListSyntax``
public struct IfConfigDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .ifConfigDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IfConfigDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .ifConfigDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeClauses: UnexpectedNodesSyntax? = nil,
      clauses: IfConfigClauseListSyntax,
      _ unexpectedBetweenClausesAndPoundEndif: UnexpectedNodesSyntax? = nil,
      poundEndif: TokenSyntax = .poundEndifToken(),
      _ unexpectedAfterPoundEndif: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeClauses, 
            clauses, 
            unexpectedBetweenClausesAndPoundEndif, 
            poundEndif, 
            unexpectedAfterPoundEndif
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeClauses?.raw, 
          clauses.raw, 
          unexpectedBetweenClausesAndPoundEndif?.raw, 
          poundEndif.raw, 
          unexpectedAfterPoundEndif?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.ifConfigDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeClauses: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var clauses: IfConfigClauseListSyntax {
    get {
      return IfConfigClauseListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `clauses`
  /// collection.
  /// - param element: The new `Clause` to add to the node's
  ///                  `clauses` collection.
  /// - returns: A copy of the receiver with the provided `Clause`
  ///            appended to its `clauses` collection.
  public func addClause(_ element: IfConfigClauseSyntax) -> IfConfigDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.ifConfigClauseList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return IfConfigDeclSyntax(newData)
  }
  
  public var unexpectedBetweenClausesAndPoundEndif: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var poundEndif: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPoundEndif: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeClauses, 
          \Self.clauses, 
          \Self.unexpectedBetweenClausesAndPoundEndif, 
          \Self.poundEndif, 
          \Self.unexpectedAfterPoundEndif
        ])
  }
}

// MARK: - ImportDeclSyntax

/// An import declaration like the following.
/// 
/// ```swift
/// import Foundation
/// ```
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `importKeyword`: `'import'`
///  - `importKindSpecifier`: (`'typealias'` | `'struct'` | `'class'` | `'enum'` | `'protocol'` | `'var'` | `'let'` | `'func'` | `'inout'`)?
///  - `path`: ``ImportPathComponentListSyntax``
public struct ImportDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .importDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ImportDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .importDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes attached to the import declaration, for example `@testable`.
  ///   - modifiers: Modifiers attached to the import declaration. Currently, no modifiers are supported by Swift.
  ///   - importKeyword: The `import` keyword for this declaration.
  ///   - importKindSpecifier: The kind of declaration being imported. For example, a struct can be imported from a specific module.
  ///   - path: The path to the module, submodule or symbol being imported.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndImportKeyword: UnexpectedNodesSyntax? = nil,
      importKeyword: TokenSyntax = .keyword(.import),
      _ unexpectedBetweenImportKeywordAndImportKindSpecifier: UnexpectedNodesSyntax? = nil,
      importKindSpecifier: TokenSyntax? = nil,
      _ unexpectedBetweenImportKindSpecifierAndPath: UnexpectedNodesSyntax? = nil,
      path: ImportPathComponentListSyntax,
      _ unexpectedAfterPath: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndImportKeyword, 
            importKeyword, 
            unexpectedBetweenImportKeywordAndImportKindSpecifier, 
            importKindSpecifier, 
            unexpectedBetweenImportKindSpecifierAndPath, 
            path, 
            unexpectedAfterPath
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndImportKeyword?.raw, 
          importKeyword.raw, 
          unexpectedBetweenImportKeywordAndImportKindSpecifier?.raw, 
          importKindSpecifier?.raw, 
          unexpectedBetweenImportKindSpecifierAndPath?.raw, 
          path.raw, 
          unexpectedAfterPath?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.importDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes attached to the import declaration, for example `@testable`.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ImportDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers attached to the import declaration. Currently, no modifiers are supported by Swift.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ImportDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndImportKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `import` keyword for this declaration.
  public var importKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenImportKeywordAndImportKindSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The kind of declaration being imported. For example, a struct can be imported from a specific module.
  public var importKindSpecifier: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenImportKindSpecifierAndPath: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The path to the module, submodule or symbol being imported.
  public var path: ImportPathComponentListSyntax {
    get {
      return ImportPathComponentListSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `path`
  /// collection.
  /// - param element: The new `PathComponent` to add to the node's
  ///                  `path` collection.
  /// - returns: A copy of the receiver with the provided `PathComponent`
  ///            appended to its `path` collection.
  public func addPathComponent(_ element: ImportPathComponentSyntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[9] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.importPathComponentList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 9, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ImportDeclSyntax(newData)
  }
  
  public var unexpectedAfterPath: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndImportKeyword, 
          \Self.importKeyword, 
          \Self.unexpectedBetweenImportKeywordAndImportKindSpecifier, 
          \Self.importKindSpecifier, 
          \Self.unexpectedBetweenImportKindSpecifierAndPath, 
          \Self.path, 
          \Self.unexpectedAfterPath
        ])
  }
}

// MARK: - InitializerDeclSyntax

/// An initializer declaration like the following.
/// 
/// ```swift
/// init(someParameter: Int) {
/// }
/// ```
/// 
/// The body is optional because this node also represents initializer requirements inside protocols.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `initKeyword`: `'init'`
///  - `optionalMark`: (`'?'` | `'?'` | `'!'`)?
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `signature`: ``FunctionSignatureSyntax``
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `body`: ``CodeBlockSyntax``?
public struct InitializerDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .initializerDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``InitializerDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .initializerDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes that are attached to the initializer.
  ///   - modifiers: Modifiers attached to the initializer
  ///   - initKeyword: The init keyword
  ///   - optionalMark: If the initializer is failable, a question mark to indicate that.
  ///   - genericParameterClause: Generic parameters of the initializer.
  ///   - signature: The arguments of the initializer. While the function signature allows specifying a return clause, doing so is not semantically valid.
  ///   - genericWhereClause: If the initializer had generic parameters, a where clause that can restrict those
  ///   - body: The initializer’s body. Missing if the initializer is a requirement of a protocol declaration.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndInitKeyword: UnexpectedNodesSyntax? = nil,
      initKeyword: TokenSyntax = .keyword(.`init`),
      _ unexpectedBetweenInitKeywordAndOptionalMark: UnexpectedNodesSyntax? = nil,
      optionalMark: TokenSyntax? = nil,
      _ unexpectedBetweenOptionalMarkAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? = nil,
      signature: FunctionSignatureSyntax,
      _ unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax? = nil,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndInitKeyword, 
            initKeyword, 
            unexpectedBetweenInitKeywordAndOptionalMark, 
            optionalMark, 
            unexpectedBetweenOptionalMarkAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndSignature, 
            signature, 
            unexpectedBetweenSignatureAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndInitKeyword?.raw, 
          initKeyword.raw, 
          unexpectedBetweenInitKeywordAndOptionalMark?.raw, 
          optionalMark?.raw, 
          unexpectedBetweenOptionalMarkAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndSignature?.raw, 
          signature.raw, 
          unexpectedBetweenSignatureAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndBody?.raw, 
          body?.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.initializerDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes that are attached to the initializer.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> InitializerDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return InitializerDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers attached to the initializer
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> InitializerDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return InitializerDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndInitKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The init keyword
  public var initKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInitKeywordAndOptionalMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the initializer is failable, a question mark to indicate that.
  public var optionalMark: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOptionalMarkAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Generic parameters of the initializer.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The arguments of the initializer. While the function signature allows specifying a return clause, doing so is not semantically valid.
  public var signature: FunctionSignatureSyntax {
    get {
      return FunctionSignatureSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the initializer had generic parameters, a where clause that can restrict those
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The initializer’s body. Missing if the initializer is a requirement of a protocol declaration.
  public var body: CodeBlockSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(CodeBlockSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndInitKeyword, 
          \Self.initKeyword, 
          \Self.unexpectedBetweenInitKeywordAndOptionalMark, 
          \Self.optionalMark, 
          \Self.unexpectedBetweenOptionalMarkAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndSignature, 
          \Self.signature, 
          \Self.unexpectedBetweenSignatureAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - MacroDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `macroKeyword`: `'macro'`
///  - `name`: `<identifier>`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `signature`: ``FunctionSignatureSyntax``
///  - `definition`: ``InitializerClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
public struct MacroDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .macroDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``MacroDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .macroDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - genericParameterClause: The parameter clause that defines the generic parameters.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndMacroKeyword: UnexpectedNodesSyntax? = nil,
      macroKeyword: TokenSyntax = .keyword(.macro),
      _ unexpectedBetweenMacroKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? = nil,
      signature: FunctionSignatureSyntax,
      _ unexpectedBetweenSignatureAndDefinition: UnexpectedNodesSyntax? = nil,
      definition: InitializerClauseSyntax? = nil,
      _ unexpectedBetweenDefinitionAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndMacroKeyword, 
            macroKeyword, 
            unexpectedBetweenMacroKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndSignature, 
            signature, 
            unexpectedBetweenSignatureAndDefinition, 
            definition, 
            unexpectedBetweenDefinitionAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedAfterGenericWhereClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndMacroKeyword?.raw, 
          macroKeyword.raw, 
          unexpectedBetweenMacroKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndSignature?.raw, 
          signature.raw, 
          unexpectedBetweenSignatureAndDefinition?.raw, 
          definition?.raw, 
          unexpectedBetweenDefinitionAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedAfterGenericWhereClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.macroDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> MacroDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MacroDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> MacroDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MacroDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndMacroKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var macroKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenMacroKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The parameter clause that defines the generic parameters.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var signature: FunctionSignatureSyntax {
    get {
      return FunctionSignatureSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSignatureAndDefinition: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var definition: InitializerClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(InitializerClauseSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDefinitionAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndMacroKeyword, 
          \Self.macroKeyword, 
          \Self.unexpectedBetweenMacroKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndSignature, 
          \Self.signature, 
          \Self.unexpectedBetweenSignatureAndDefinition, 
          \Self.definition, 
          \Self.unexpectedBetweenDefinitionAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedAfterGenericWhereClause
        ])
  }
}

// MARK: - MacroExpansionDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `pound`: `'#'`
///  - `macroName`: `<identifier>`
///  - `genericArgumentClause`: ``GenericArgumentClauseSyntax``?
///  - `leftParen`: `'('`?
///  - `arguments`: ``LabeledExprListSyntax``
///  - `rightParen`: `')'`?
///  - `trailingClosure`: ``ClosureExprSyntax``?
///  - `additionalTrailingClosures`: ``MultipleTrailingClosureElementListSyntax``
public struct MacroExpansionDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .macroExpansionDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``MacroExpansionDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .macroExpansionDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - pound: The `#` sign.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndPound: UnexpectedNodesSyntax? = nil,
      pound: TokenSyntax = .poundToken(),
      _ unexpectedBetweenPoundAndMacroName: UnexpectedNodesSyntax? = nil,
      macroName: TokenSyntax,
      _ unexpectedBetweenMacroNameAndGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      genericArgumentClause: GenericArgumentClauseSyntax? = nil,
      _ unexpectedBetweenGenericArgumentClauseAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax? = nil,
      _ unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: LabeledExprListSyntax,
      _ unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax? = nil,
      _ unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? = nil,
      trailingClosure: ClosureExprSyntax? = nil,
      _ unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? = nil,
      _ unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndPound, 
            pound, 
            unexpectedBetweenPoundAndMacroName, 
            macroName, 
            unexpectedBetweenMacroNameAndGenericArgumentClause, 
            genericArgumentClause, 
            unexpectedBetweenGenericArgumentClauseAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndRightParen, 
            rightParen, 
            unexpectedBetweenRightParenAndTrailingClosure, 
            trailingClosure, 
            unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
            additionalTrailingClosures, 
            unexpectedAfterAdditionalTrailingClosures
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndPound?.raw, 
          pound.raw, 
          unexpectedBetweenPoundAndMacroName?.raw, 
          macroName.raw, 
          unexpectedBetweenMacroNameAndGenericArgumentClause?.raw, 
          genericArgumentClause?.raw, 
          unexpectedBetweenGenericArgumentClauseAndLeftParen?.raw, 
          leftParen?.raw, 
          unexpectedBetweenLeftParenAndArguments?.raw, 
          arguments.raw, 
          unexpectedBetweenArgumentsAndRightParen?.raw, 
          rightParen?.raw, 
          unexpectedBetweenRightParenAndTrailingClosure?.raw, 
          trailingClosure?.raw, 
          unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.raw, 
          additionalTrailingClosures?.raw, 
          unexpectedAfterAdditionalTrailingClosures?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.macroExpansionDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> MacroExpansionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MacroExpansionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> MacroExpansionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MacroExpansionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndPound: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `#` sign.
  public var pound: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPoundAndMacroName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var macroName: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenMacroNameAndGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var genericArgumentClause: GenericArgumentClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericArgumentClauseSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericArgumentClauseAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arguments: LabeledExprListSyntax {
    get {
      return LabeledExprListSyntax(data.child(at: 13, parent: Syntax(self))!)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 13, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `arguments`
  /// collection.
  /// - param element: The new `Argument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `arguments` collection.
  public func addArgument(_ element: LabeledExprSyntax) -> MacroExpansionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[13] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.labeledExprList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 13, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MacroExpansionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingClosure: ClosureExprSyntax? {
    get {
      return data.child(at: 17, parent: Syntax(self)).map(ClosureExprSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 17, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 18, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 18, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var additionalTrailingClosures: MultipleTrailingClosureElementListSyntax? {
    get {
      return data.child(at: 19, parent: Syntax(self)).map(MultipleTrailingClosureElementListSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 19, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `additionalTrailingClosures`
  /// collection.
  /// - param element: The new `AdditionalTrailingClosure` to add to the node's
  ///                  `additionalTrailingClosures` collection.
  /// - returns: A copy of the receiver with the provided `AdditionalTrailingClosure`
  ///            appended to its `additionalTrailingClosures` collection.
  public func addAdditionalTrailingClosure(_ element: MultipleTrailingClosureElementSyntax) -> MacroExpansionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[19] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.multipleTrailingClosureElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 19, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MacroExpansionDeclSyntax(newData)
  }
  
  public var unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 20, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MacroExpansionDeclSyntax(data.replacingChild(at: 20, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndPound, 
          \Self.pound, 
          \Self.unexpectedBetweenPoundAndMacroName, 
          \Self.macroName, 
          \Self.unexpectedBetweenMacroNameAndGenericArgumentClause, 
          \Self.genericArgumentClause, 
          \Self.unexpectedBetweenGenericArgumentClauseAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedBetweenRightParenAndTrailingClosure, 
          \Self.trailingClosure, 
          \Self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
          \Self.additionalTrailingClosures, 
          \Self.unexpectedAfterAdditionalTrailingClosures
        ])
  }
}

// MARK: - MissingDeclSyntax

/// In case the source code is missing a declaration, this node stands in place of the missing declaration.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `placeholder`: `<identifier>`
public struct MissingDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .missingDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``MissingDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .missingDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: If there were standalone attributes without a declaration to attach them to, the ``MissingDeclSyntax`` will contain these.
  ///   - modifiers: If there were standalone modifiers without a declaration to attach them to, the ``MissingDeclSyntax`` will contain these.
  ///   - placeholder: A placeholder, i.e. `<#decl#>`, that can be inserted into the source code to represent the missing declaration.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndPlaceholder: UnexpectedNodesSyntax? = nil,
      placeholder: TokenSyntax,
      _ unexpectedAfterPlaceholder: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndPlaceholder, 
            placeholder, 
            unexpectedAfterPlaceholder
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndPlaceholder?.raw, 
          placeholder.raw, 
          unexpectedAfterPlaceholder?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.missingDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MissingDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If there were standalone attributes without a declaration to attach them to, the ``MissingDeclSyntax`` will contain these.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = MissingDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> MissingDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MissingDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MissingDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If there were standalone modifiers without a declaration to attach them to, the ``MissingDeclSyntax`` will contain these.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = MissingDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> MissingDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return MissingDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndPlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MissingDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A placeholder, i.e. `<#decl#>`, that can be inserted into the source code to represent the missing declaration.
  /// 
  /// This token should always have `presence = .missing`.
  public var placeholder: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = MissingDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = MissingDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndPlaceholder, 
          \Self.placeholder, 
          \Self.unexpectedAfterPlaceholder
        ])
  }
}

// MARK: - OperatorDeclSyntax

/// A Swift `operator` declaration.
///
/// ### Children
/// 
///  - `fixitySpecifier`: (`'prefix'` | `'postfix'` | `'infix'`)
///  - `operatorKeyword`: `'operator'`
///  - `name`: (`<binaryOperator>` | `<prefixOperator>` | `<postfixOperator>`)
///  - `operatorPrecedenceAndTypes`: ``OperatorPrecedenceAndTypesSyntax``?
public struct OperatorDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .operatorDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``OperatorDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .operatorDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - fixitySpecifier: The fixity applied to the 'operator' declaration.
  ///   - operatorPrecedenceAndTypes: Optionally specify a precedence group and designated types.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeFixitySpecifier: UnexpectedNodesSyntax? = nil,
      fixitySpecifier: TokenSyntax,
      _ unexpectedBetweenFixitySpecifierAndOperatorKeyword: UnexpectedNodesSyntax? = nil,
      operatorKeyword: TokenSyntax = .keyword(.operator),
      _ unexpectedBetweenOperatorKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndOperatorPrecedenceAndTypes: UnexpectedNodesSyntax? = nil,
      operatorPrecedenceAndTypes: OperatorPrecedenceAndTypesSyntax? = nil,
      _ unexpectedAfterOperatorPrecedenceAndTypes: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeFixitySpecifier, 
            fixitySpecifier, 
            unexpectedBetweenFixitySpecifierAndOperatorKeyword, 
            operatorKeyword, 
            unexpectedBetweenOperatorKeywordAndName, 
            name, 
            unexpectedBetweenNameAndOperatorPrecedenceAndTypes, 
            operatorPrecedenceAndTypes, 
            unexpectedAfterOperatorPrecedenceAndTypes
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeFixitySpecifier?.raw, 
          fixitySpecifier.raw, 
          unexpectedBetweenFixitySpecifierAndOperatorKeyword?.raw, 
          operatorKeyword.raw, 
          unexpectedBetweenOperatorKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndOperatorPrecedenceAndTypes?.raw, 
          operatorPrecedenceAndTypes?.raw, 
          unexpectedAfterOperatorPrecedenceAndTypes?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.operatorDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeFixitySpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The fixity applied to the 'operator' declaration.
  public var fixitySpecifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFixitySpecifierAndOperatorKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var operatorKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOperatorKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndOperatorPrecedenceAndTypes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Optionally specify a precedence group and designated types.
  public var operatorPrecedenceAndTypes: OperatorPrecedenceAndTypesSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(OperatorPrecedenceAndTypesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterOperatorPrecedenceAndTypes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = OperatorDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeFixitySpecifier, 
          \Self.fixitySpecifier, 
          \Self.unexpectedBetweenFixitySpecifierAndOperatorKeyword, 
          \Self.operatorKeyword, 
          \Self.unexpectedBetweenOperatorKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndOperatorPrecedenceAndTypes, 
          \Self.operatorPrecedenceAndTypes, 
          \Self.unexpectedAfterOperatorPrecedenceAndTypes
        ])
  }
}

// MARK: - PoundSourceLocationSyntax

/// ### Children
/// 
///  - `poundSourceLocation`: `'#sourceLocation'`
///  - `leftParen`: `'('`
///  - `arguments`: ``PoundSourceLocationArgumentsSyntax``?
///  - `rightParen`: `')'`
public struct PoundSourceLocationSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .poundSourceLocation else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PoundSourceLocationSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .poundSourceLocation)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePoundSourceLocation: UnexpectedNodesSyntax? = nil,
      poundSourceLocation: TokenSyntax = .poundSourceLocationToken(),
      _ unexpectedBetweenPoundSourceLocationAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: PoundSourceLocationArgumentsSyntax? = nil,
      _ unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforePoundSourceLocation, 
            poundSourceLocation, 
            unexpectedBetweenPoundSourceLocationAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforePoundSourceLocation?.raw, 
          poundSourceLocation.raw, 
          unexpectedBetweenPoundSourceLocationAndLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndArguments?.raw, 
          arguments?.raw, 
          unexpectedBetweenArgumentsAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.poundSourceLocation,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePoundSourceLocation: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var poundSourceLocation: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPoundSourceLocationAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arguments: PoundSourceLocationArgumentsSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(PoundSourceLocationArgumentsSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PoundSourceLocationSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforePoundSourceLocation, 
          \Self.poundSourceLocation, 
          \Self.unexpectedBetweenPoundSourceLocationAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - PrecedenceGroupDeclSyntax

/// A Swift `precedencegroup` declaration.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `precedencegroupKeyword`: `'precedencegroup'`
///  - `name`: `<identifier>`
///  - `leftBrace`: `'{'`
///  - `groupAttributes`: ``PrecedenceGroupAttributeListSyntax``
///  - `rightBrace`: `'}'`
public struct PrecedenceGroupDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .precedenceGroupDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``PrecedenceGroupDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .precedenceGroupDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: The attributes applied to the 'precedencegroup' declaration.
  ///   - modifiers: The declaration modifiers applied to the 'precedencegroup' declaration.
  ///   - name: The name of this precedence group.
  ///   - groupAttributes: The characteristics of this precedence group.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndPrecedencegroupKeyword: UnexpectedNodesSyntax? = nil,
      precedencegroupKeyword: TokenSyntax = .keyword(.precedencegroup),
      _ unexpectedBetweenPrecedencegroupKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndLeftBrace: UnexpectedNodesSyntax? = nil,
      leftBrace: TokenSyntax = .leftBraceToken(),
      _ unexpectedBetweenLeftBraceAndGroupAttributes: UnexpectedNodesSyntax? = nil,
      groupAttributes: PrecedenceGroupAttributeListSyntax,
      _ unexpectedBetweenGroupAttributesAndRightBrace: UnexpectedNodesSyntax? = nil,
      rightBrace: TokenSyntax = .rightBraceToken(),
      _ unexpectedAfterRightBrace: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndPrecedencegroupKeyword, 
            precedencegroupKeyword, 
            unexpectedBetweenPrecedencegroupKeywordAndName, 
            name, 
            unexpectedBetweenNameAndLeftBrace, 
            leftBrace, 
            unexpectedBetweenLeftBraceAndGroupAttributes, 
            groupAttributes, 
            unexpectedBetweenGroupAttributesAndRightBrace, 
            rightBrace, 
            unexpectedAfterRightBrace
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndPrecedencegroupKeyword?.raw, 
          precedencegroupKeyword.raw, 
          unexpectedBetweenPrecedencegroupKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndLeftBrace?.raw, 
          leftBrace.raw, 
          unexpectedBetweenLeftBraceAndGroupAttributes?.raw, 
          groupAttributes.raw, 
          unexpectedBetweenGroupAttributesAndRightBrace?.raw, 
          rightBrace.raw, 
          unexpectedAfterRightBrace?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.precedenceGroupDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The attributes applied to the 'precedencegroup' declaration.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return PrecedenceGroupDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The declaration modifiers applied to the 'precedencegroup' declaration.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return PrecedenceGroupDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndPrecedencegroupKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var precedencegroupKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPrecedencegroupKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of this precedence group.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndLeftBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftBraceAndGroupAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The characteristics of this precedence group.
  public var groupAttributes: PrecedenceGroupAttributeListSyntax {
    get {
      return PrecedenceGroupAttributeListSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `groupAttributes`
  /// collection.
  /// - param element: The new `GroupAttribute` to add to the node's
  ///                  `groupAttributes` collection.
  /// - returns: A copy of the receiver with the provided `GroupAttribute`
  ///            appended to its `groupAttributes` collection.
  public func addGroupAttribute(_ element: Syntax) -> PrecedenceGroupDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[11] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.precedenceGroupAttributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 11, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return PrecedenceGroupDeclSyntax(newData)
  }
  
  public var unexpectedBetweenGroupAttributesAndRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightBrace: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 13, parent: Syntax(self))!)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 13, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightBrace: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = PrecedenceGroupDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndPrecedencegroupKeyword, 
          \Self.precedencegroupKeyword, 
          \Self.unexpectedBetweenPrecedencegroupKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndLeftBrace, 
          \Self.leftBrace, 
          \Self.unexpectedBetweenLeftBraceAndGroupAttributes, 
          \Self.groupAttributes, 
          \Self.unexpectedBetweenGroupAttributesAndRightBrace, 
          \Self.rightBrace, 
          \Self.unexpectedAfterRightBrace
        ])
  }
}

// MARK: - ProtocolDeclSyntax

/// A protocol declaration like the following.
/// 
/// ```swift
/// protocol Example {
///   var isValid: Bool { get }
/// }
/// ```
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `protocolKeyword`: `'protocol'`
///  - `name`: `<identifier>`
///  - `primaryAssociatedTypeClause`: ``PrimaryAssociatedTypeClauseSyntax``?
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct ProtocolDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .protocolDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ProtocolDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .protocolDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes attached to the protocol declaration, such as an `@available` attribute.
  ///   - modifiers: Modifiers attached to the protocol declaration, such as `public`.
  ///   - protocolKeyword: The `protocol` keyword for this declaration.
  ///   - name: The name of the protocol.
  ///   - primaryAssociatedTypeClause: The primary associated type for the protocol.
  ///   - inheritanceClause: The inheritance clause describing one or more conformances for this protocol declaration.
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters of this protocol declaration.
  ///   - memberBlock: The members of the protocol declaration.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndProtocolKeyword: UnexpectedNodesSyntax? = nil,
      protocolKeyword: TokenSyntax = .keyword(.protocol),
      _ unexpectedBetweenProtocolKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndPrimaryAssociatedTypeClause: UnexpectedNodesSyntax? = nil,
      primaryAssociatedTypeClause: PrimaryAssociatedTypeClauseSyntax? = nil,
      _ unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndProtocolKeyword, 
            protocolKeyword, 
            unexpectedBetweenProtocolKeywordAndName, 
            name, 
            unexpectedBetweenNameAndPrimaryAssociatedTypeClause, 
            primaryAssociatedTypeClause, 
            unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndProtocolKeyword?.raw, 
          protocolKeyword.raw, 
          unexpectedBetweenProtocolKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndPrimaryAssociatedTypeClause?.raw, 
          primaryAssociatedTypeClause?.raw, 
          unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.protocolDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes attached to the protocol declaration, such as an `@available` attribute.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> ProtocolDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ProtocolDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers attached to the protocol declaration, such as `public`.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> ProtocolDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ProtocolDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndProtocolKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `protocol` keyword for this declaration.
  public var protocolKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenProtocolKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of the protocol.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndPrimaryAssociatedTypeClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The primary associated type for the protocol.
  public var primaryAssociatedTypeClause: PrimaryAssociatedTypeClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(PrimaryAssociatedTypeClauseSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The inheritance clause describing one or more conformances for this protocol declaration.
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `where` clause that applies to the generic parameters of this protocol declaration.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The members of the protocol declaration.
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 15, parent: Syntax(self))!)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 15, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ProtocolDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndProtocolKeyword, 
          \Self.protocolKeyword, 
          \Self.unexpectedBetweenProtocolKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndPrimaryAssociatedTypeClause, 
          \Self.primaryAssociatedTypeClause, 
          \Self.unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}

// MARK: - StructDeclSyntax

///     A struct declaration like the following.
/// 
///     ```swift
///     struct SomeStruct {
///       let someMember: String
///       var anotherMember: Int
/// 
///       func foo() {
///         print(someMember)
///       }
/// 
///       mutating func bar() {
///         anotherMember = 42
///       }
///     }
///     ```
/// 
///     A struct declaration may be declared without any members.
/// 
///     ```swift
///     struct EmptyStruct {
/// 
///     }
///     ```
/// 
///     A struct declaration may include a type inheritance clause listing
///     one or more protocols the struct conforms to.
/// 
///     The example below uses Hashable and Equatable protocols whose members
///     are automatically synthesized by the compiler if the struct contains
///     stored members that are themselves `Hashable` and `Equatable`.
/// 
///     ```swift
///     struct AdvancedStruct: Hashable, Equatable {
///       let someMember: String
///       var anotherMember: Int
///     }
///     ```
/// 
///     A struct declaration may include a generic parameter clause as well
///     as a generic where clause.
/// 
///     ```swift
///     struct Stack<Element> {
///       var items: [Element] = []
/// 
///       mutating func push(_ item: Element) {
///         items.append(item)
///       }
/// 
///       mutating func pop() -> Element {
///         return items.removeLast()
///       }
///    }
///    ```
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `structKeyword`: `'struct'`
///  - `name`: `<identifier>`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct StructDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .structDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``StructDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .structDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes that are attached to the struct declaration.
  ///   - modifiers: Modifiers that are attached to the struct declaration.
  ///   - structKeyword: The `struct` keyword for this declaration.
  ///   - name: Declares the name of this struct. If the name matches a reserved keyword use backticks to escape it.
  ///   - genericParameterClause: The generic parameters, if any, of the struct declaration.
  ///   - inheritanceClause: The struct declaration inheritance clause describing one or more conformances for this struct declaration.
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters of this struct declaration.
  ///   - memberBlock: The members of the struct declaration. Because struct extension declarations may declare additional members the contents of this member block isn't guaranteed to be a complete list of members for this type.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndStructKeyword: UnexpectedNodesSyntax? = nil,
      structKeyword: TokenSyntax = .keyword(.struct),
      _ unexpectedBetweenStructKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndStructKeyword, 
            structKeyword, 
            unexpectedBetweenStructKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndStructKeyword?.raw, 
          structKeyword.raw, 
          unexpectedBetweenStructKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.structDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes that are attached to the struct declaration.
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> StructDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return StructDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers that are attached to the struct declaration.
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> StructDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return StructDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndStructKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `struct` keyword for this declaration.
  public var structKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenStructKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Declares the name of this struct. If the name matches a reserved keyword use backticks to escape it.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The generic parameters, if any, of the struct declaration.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The struct declaration inheritance clause describing one or more conformances for this struct declaration.
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `where` clause that applies to the generic parameters of this struct declaration.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The members of the struct declaration. Because struct extension declarations may declare additional members the contents of this member block isn't guaranteed to be a complete list of members for this type.
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 15, parent: Syntax(self))!)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 15, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = StructDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndStructKeyword, 
          \Self.structKeyword, 
          \Self.unexpectedBetweenStructKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}

// MARK: - SubscriptDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `subscriptKeyword`: `'subscript'`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `parameterClause`: ``FunctionParameterClauseSyntax``
///  - `returnClause`: ``ReturnClauseSyntax``
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `accessors`: (``AccessorBlockSyntax`` | ``CodeBlockSyntax``)?
public struct SubscriptDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public enum Accessors: SyntaxChildChoices {
    case `accessors`(AccessorBlockSyntax)
    case `getter`(CodeBlockSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .accessors(let node):
        return node._syntaxNode
      case .getter(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: AccessorBlockSyntax) {
      self = .accessors(node)
    }
    
    public init(_ node: CodeBlockSyntax) {
      self = .getter(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(AccessorBlockSyntax.self) {
        self = .accessors(node)
        return
      }
      if let node = node.as(CodeBlockSyntax.self) {
        self = .getter(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(AccessorBlockSyntax.self), .node(CodeBlockSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .subscriptDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``SubscriptDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .subscriptDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - genericParameterClause: The parameter clause that defines the generic parameters.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndSubscriptKeyword: UnexpectedNodesSyntax? = nil,
      subscriptKeyword: TokenSyntax = .keyword(.subscript),
      _ unexpectedBetweenSubscriptKeywordAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndParameterClause: UnexpectedNodesSyntax? = nil,
      parameterClause: FunctionParameterClauseSyntax,
      _ unexpectedBetweenParameterClauseAndReturnClause: UnexpectedNodesSyntax? = nil,
      returnClause: ReturnClauseSyntax,
      _ unexpectedBetweenReturnClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndAccessors: UnexpectedNodesSyntax? = nil,
      accessors: Accessors? = nil,
      _ unexpectedAfterAccessors: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndSubscriptKeyword, 
            subscriptKeyword, 
            unexpectedBetweenSubscriptKeywordAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndParameterClause, 
            parameterClause, 
            unexpectedBetweenParameterClauseAndReturnClause, 
            returnClause, 
            unexpectedBetweenReturnClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndAccessors, 
            accessors, 
            unexpectedAfterAccessors
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndSubscriptKeyword?.raw, 
          subscriptKeyword.raw, 
          unexpectedBetweenSubscriptKeywordAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndParameterClause?.raw, 
          parameterClause.raw, 
          unexpectedBetweenParameterClauseAndReturnClause?.raw, 
          returnClause.raw, 
          unexpectedBetweenReturnClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndAccessors?.raw, 
          accessors?.raw, 
          unexpectedAfterAccessors?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.subscriptDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> SubscriptDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return SubscriptDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> SubscriptDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return SubscriptDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndSubscriptKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var subscriptKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSubscriptKeywordAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The parameter clause that defines the generic parameters.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var parameterClause: FunctionParameterClauseSyntax {
    get {
      return FunctionParameterClauseSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenParameterClauseAndReturnClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var returnClause: ReturnClauseSyntax {
    get {
      return ReturnClauseSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenReturnClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndAccessors: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var accessors: Accessors? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(Accessors.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterAccessors: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = SubscriptDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndSubscriptKeyword, 
          \Self.subscriptKeyword, 
          \Self.unexpectedBetweenSubscriptKeywordAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndParameterClause, 
          \Self.parameterClause, 
          \Self.unexpectedBetweenParameterClauseAndReturnClause, 
          \Self.returnClause, 
          \Self.unexpectedBetweenReturnClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndAccessors, 
          \Self.accessors, 
          \Self.unexpectedAfterAccessors
        ])
  }
}

// MARK: - TypeAliasDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `typealiasKeyword`: `'typealias'`
///  - `name`: `<identifier>`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `initializer`: ``TypeInitializerClauseSyntax``
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
public struct TypeAliasDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .typeAliasDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``TypeAliasDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .typeAliasDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - genericParameterClause: The parameter clause that defines the generic parameters.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndTypealiasKeyword: UnexpectedNodesSyntax? = nil,
      typealiasKeyword: TokenSyntax = .keyword(.typealias),
      _ unexpectedBetweenTypealiasKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndInitializer: UnexpectedNodesSyntax? = nil,
      initializer: TypeInitializerClauseSyntax,
      _ unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndTypealiasKeyword, 
            typealiasKeyword, 
            unexpectedBetweenTypealiasKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndInitializer, 
            initializer, 
            unexpectedBetweenInitializerAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedAfterGenericWhereClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndTypealiasKeyword?.raw, 
          typealiasKeyword.raw, 
          unexpectedBetweenTypealiasKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndInitializer?.raw, 
          initializer.raw, 
          unexpectedBetweenInitializerAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedAfterGenericWhereClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.typeAliasDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> TypeAliasDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return TypeAliasDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> TypeAliasDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return TypeAliasDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndTypealiasKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var typealiasKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypealiasKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The parameter clause that defines the generic parameters.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndInitializer: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var initializer: TypeInitializerClauseSyntax {
    get {
      return TypeInitializerClauseSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = TypeAliasDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndTypealiasKeyword, 
          \Self.typealiasKeyword, 
          \Self.unexpectedBetweenTypealiasKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndInitializer, 
          \Self.initializer, 
          \Self.unexpectedBetweenInitializerAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedAfterGenericWhereClause
        ])
  }
}

// MARK: - VariableDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `bindingSpecifier`: (`'let'` | `'var'` | `'inout'`)
///  - `bindings`: ``PatternBindingListSyntax``
public struct VariableDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .variableDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``VariableDeclSyntax`` node from the given ``SyntaxData``. This assumes
  /// that the `SyntaxData` is of the correct kind. If it is not, the behaviour
  /// is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .variableDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax? = nil,
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax? = nil,
      _ unexpectedBetweenModifiersAndBindingSpecifier: UnexpectedNodesSyntax? = nil,
      bindingSpecifier: TokenSyntax,
      _ unexpectedBetweenBindingSpecifierAndBindings: UnexpectedNodesSyntax? = nil,
      bindings: PatternBindingListSyntax,
      _ unexpectedAfterBindings: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndBindingSpecifier, 
            bindingSpecifier, 
            unexpectedBetweenBindingSpecifierAndBindings, 
            bindings, 
            unexpectedAfterBindings
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes?.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers?.raw, 
          unexpectedBetweenModifiersAndBindingSpecifier?.raw, 
          bindingSpecifier.raw, 
          unexpectedBetweenBindingSpecifierAndBindings?.raw, 
          bindings.raw, 
          unexpectedAfterBindings?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.variableDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = VariableDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(AttributeListSyntax.init)
    }
    set(value) {
      self = VariableDeclSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  public func addAttribute(_ element: Syntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return VariableDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = VariableDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierListSyntax.init)
    }
    set(value) {
      self = VariableDeclSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  public func addModifier(_ element: DeclModifierSyntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return VariableDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndBindingSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = VariableDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var bindingSpecifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = VariableDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBindingSpecifierAndBindings: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = VariableDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var bindings: PatternBindingListSyntax {
    get {
      return PatternBindingListSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = VariableDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `bindings`
  /// collection.
  /// - param element: The new `Binding` to add to the node's
  ///                  `bindings` collection.
  /// - returns: A copy of the receiver with the provided `Binding`
  ///            appended to its `bindings` collection.
  public func addBinding(_ element: PatternBindingSyntax) -> VariableDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[7] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.patternBindingList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 7, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return VariableDeclSyntax(newData)
  }
  
  public var unexpectedAfterBindings: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = VariableDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndBindingSpecifier, 
          \Self.bindingSpecifier, 
          \Self.unexpectedBetweenBindingSpecifierAndBindings, 
          \Self.bindings, 
          \Self.unexpectedAfterBindings
        ])
  }
}
