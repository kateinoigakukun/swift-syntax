//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - EditorPlaceholderDeclSyntax

/// An editor placeholder, e.g. `<#declaration#>` that is used in a position that expects a declaration.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `placeholder`: `<identifier>`
public struct EditorPlaceholderDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .editorPlaceholderDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EditorPlaceholderDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .editorPlaceholderDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: If there were attributes before the editor placeholder, the ``EditorPlaceholderDeclSyntax`` will contain these.
  ///   - modifiers: If there were modifiers before the editor placeholder, the `EditorPlaceholderDecl` will contain these.
  ///   - placeholder: The actual editor placeholder that starts with `<#` and ends with `#>`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndPlaceholder: UnexpectedNodesSyntax? = nil,
      placeholder: TokenSyntax,
      _ unexpectedAfterPlaceholder: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndPlaceholder, 
            placeholder, 
            unexpectedAfterPlaceholder
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndPlaceholder?.raw, 
          placeholder.raw, 
          unexpectedAfterPlaceholder?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.editorPlaceholderDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If there were attributes before the editor placeholder, the ``EditorPlaceholderDeclSyntax`` will contain these.
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> EditorPlaceholderDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EditorPlaceholderDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If there were modifiers before the editor placeholder, the `EditorPlaceholderDecl` will contain these.
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> EditorPlaceholderDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EditorPlaceholderDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndPlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The actual editor placeholder that starts with `<#` and ends with `#>`.
  public var placeholder: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndPlaceholder, 
          \Self.placeholder, 
          \Self.unexpectedAfterPlaceholder
        ])
  }
}

// MARK: - EditorPlaceholderExprSyntax

/// ### Children
/// 
///  - `placeholder`: `<identifier>`
public struct EditorPlaceholderExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .editorPlaceholderExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EditorPlaceholderExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .editorPlaceholderExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePlaceholder: UnexpectedNodesSyntax? = nil,
      placeholder: TokenSyntax,
      _ unexpectedAfterPlaceholder: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforePlaceholder, placeholder, unexpectedAfterPlaceholder))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforePlaceholder?.raw, placeholder.raw, unexpectedAfterPlaceholder?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.editorPlaceholderExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var placeholder: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = EditorPlaceholderExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPlaceholder: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EditorPlaceholderExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforePlaceholder, \Self.placeholder, \Self.unexpectedAfterPlaceholder])
  }
}

// MARK: - EnumCaseDeclSyntax

/// A `case` declaration of a Swift `enum`. It can have 1 or more `EnumCaseElement`s inside, each declaring a different case of the enum.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `caseKeyword`: `'case'`
///  - `elements`: ``EnumCaseElementListSyntax``
public struct EnumCaseDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .enumCaseDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EnumCaseDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .enumCaseDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: The attributes applied to the case declaration.
  ///   - modifiers: The declaration modifiers applied to the case declaration.
  ///   - caseKeyword: The `case` keyword for this case.
  ///   - elements: The elements this case declares.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndCaseKeyword: UnexpectedNodesSyntax? = nil,
      caseKeyword: TokenSyntax = .keyword(.case),
      _ unexpectedBetweenCaseKeywordAndElements: UnexpectedNodesSyntax? = nil,
      elements: EnumCaseElementListSyntax,
      _ unexpectedAfterElements: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndCaseKeyword, 
            caseKeyword, 
            unexpectedBetweenCaseKeywordAndElements, 
            elements, 
            unexpectedAfterElements
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndCaseKeyword?.raw, 
          caseKeyword.raw, 
          unexpectedBetweenCaseKeywordAndElements?.raw, 
          elements.raw, 
          unexpectedAfterElements?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.enumCaseDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The attributes applied to the case declaration.
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumCaseDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The declaration modifiers applied to the case declaration.
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumCaseDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndCaseKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `case` keyword for this case.
  public var caseKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCaseKeywordAndElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The elements this case declares.
  public var elements: EnumCaseElementListSyntax {
    get {
      return EnumCaseElementListSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `elements`
  /// collection.
  ///
  /// - param element: The new `Element` to add to the node's
  ///                  `elements` collection.
  /// - returns: A copy of the receiver with the provided `Element`
  ///            appended to its `elements` collection.
  @available(*, deprecated, message: "Use node.elements.append(newElement) instead")
  public func addElement(_ element: EnumCaseElementSyntax) -> EnumCaseDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[7] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.enumCaseElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 7, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumCaseDeclSyntax(newData)
  }
  
  public var unexpectedAfterElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndCaseKeyword, 
          \Self.caseKeyword, 
          \Self.unexpectedBetweenCaseKeywordAndElements, 
          \Self.elements, 
          \Self.unexpectedAfterElements
        ])
  }
}

// MARK: - EnumCaseElementSyntax

/// An element of an enum case, containing the name of the case and, optionally, either associated values or an assignment to a raw value.
///
/// ### Children
/// 
///  - `name`: `<identifier>`
///  - `parameterClause`: ``EnumCaseParameterClauseSyntax``?
///  - `rawValue`: ``InitializerClauseSyntax``?
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``EnumCaseElementListSyntax``
public struct EnumCaseElementSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .enumCaseElement else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EnumCaseElementSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .enumCaseElement)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - name: The name of this case.
  ///   - parameterClause: The set of associated values of the case.
  ///   - rawValue: The raw value of this enum element, if present.
  ///   - trailingComma: The trailing comma of this element, if the case has multiple elements.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndParameterClause: UnexpectedNodesSyntax? = nil,
      parameterClause: EnumCaseParameterClauseSyntax? = nil,
      _ unexpectedBetweenParameterClauseAndRawValue: UnexpectedNodesSyntax? = nil,
      rawValue: InitializerClauseSyntax? = nil,
      _ unexpectedBetweenRawValueAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeName, 
            name, 
            unexpectedBetweenNameAndParameterClause, 
            parameterClause, 
            unexpectedBetweenParameterClauseAndRawValue, 
            rawValue, 
            unexpectedBetweenRawValueAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndParameterClause?.raw, 
          parameterClause?.raw, 
          unexpectedBetweenParameterClauseAndRawValue?.raw, 
          rawValue?.raw, 
          unexpectedBetweenRawValueAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.enumCaseElement,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseElementSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The name of this case.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseElementSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseElementSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The set of associated values of the case.
  public var parameterClause: EnumCaseParameterClauseSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(EnumCaseParameterClauseSyntax.init)
    }
    set(value) {
      self = EnumCaseElementSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenParameterClauseAndRawValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseElementSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The raw value of this enum element, if present.
  public var rawValue: InitializerClauseSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(InitializerClauseSyntax.init)
    }
    set(value) {
      self = EnumCaseElementSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRawValueAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseElementSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The trailing comma of this element, if the case has multiple elements.
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = EnumCaseElementSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseElementSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndParameterClause, 
          \Self.parameterClause, 
          \Self.unexpectedBetweenParameterClauseAndRawValue, 
          \Self.rawValue, 
          \Self.unexpectedBetweenRawValueAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - EnumCaseParameterClauseSyntax

/// ### Children
/// 
///  - `leftParen`: `'('`
///  - `parameters`: ``EnumCaseParameterListSyntax``
///  - `rightParen`: `')'`
///
/// ### Contained in
/// 
///  - ``EnumCaseElementSyntax``.``EnumCaseElementSyntax/parameterClause``
public struct EnumCaseParameterClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .enumCaseParameterClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EnumCaseParameterClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .enumCaseParameterClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - leftParen: The '(' to open the parameter clause.
  ///   - parameters: The actual parameters.
  ///   - rightParen: The ')' to close the parameter clause.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndParameters: UnexpectedNodesSyntax? = nil,
      parameters: EnumCaseParameterListSyntax,
      _ unexpectedBetweenParametersAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndParameters, 
            parameters, 
            unexpectedBetweenParametersAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndParameters?.raw, 
          parameters.raw, 
          unexpectedBetweenParametersAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.enumCaseParameterClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The '(' to open the parameter clause.
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseParameterClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndParameters: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The actual parameters.
  public var parameters: EnumCaseParameterListSyntax {
    get {
      return EnumCaseParameterListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseParameterClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `parameters`
  /// collection.
  ///
  /// - param element: The new `Parameter` to add to the node's
  ///                  `parameters` collection.
  /// - returns: A copy of the receiver with the provided `Parameter`
  ///            appended to its `parameters` collection.
  @available(*, deprecated, message: "Use node.parameters.append(newElement) instead")
  public func addParameter(_ element: EnumCaseParameterSyntax) -> EnumCaseParameterClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.enumCaseParameterList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumCaseParameterClauseSyntax(newData)
  }
  
  public var unexpectedBetweenParametersAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The ')' to close the parameter clause.
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseParameterClauseSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterClauseSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndParameters, 
          \Self.parameters, 
          \Self.unexpectedBetweenParametersAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - EnumCaseParameterSyntax

/// ### Children
/// 
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `firstName`: (`<identifier>` | `'_'`)?
///  - `secondName`: (`<identifier>` | `'_'`)?
///  - `colon`: `':'`?
///  - `type`: ``TypeSyntax``
///  - `defaultValue`: ``InitializerClauseSyntax``?
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``EnumCaseParameterListSyntax``
public struct EnumCaseParameterSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .enumCaseParameter else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EnumCaseParameterSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .enumCaseParameter)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - colon: If the parameter has a label, the colon separating the label from the type.
  ///   - type: The parameter's type.
  ///   - defaultValue: If the parameter has a default value, the initializer clause describing the default value.
  ///   - trailingComma: If the parameter is followed by another parameter, the comma separating them.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndFirstName: UnexpectedNodesSyntax? = nil,
      firstName: TokenSyntax? = nil,
      _ unexpectedBetweenFirstNameAndSecondName: UnexpectedNodesSyntax? = nil,
      secondName: TokenSyntax? = nil,
      _ unexpectedBetweenSecondNameAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax? = nil,
      _ unexpectedBetweenColonAndType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedBetweenTypeAndDefaultValue: UnexpectedNodesSyntax? = nil,
      defaultValue: InitializerClauseSyntax? = nil,
      _ unexpectedBetweenDefaultValueAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndFirstName, 
            firstName, 
            unexpectedBetweenFirstNameAndSecondName, 
            secondName, 
            unexpectedBetweenSecondNameAndColon, 
            colon, 
            unexpectedBetweenColonAndType, 
            type, 
            unexpectedBetweenTypeAndDefaultValue, 
            defaultValue, 
            unexpectedBetweenDefaultValueAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndFirstName?.raw, 
          firstName?.raw, 
          unexpectedBetweenFirstNameAndSecondName?.raw, 
          secondName?.raw, 
          unexpectedBetweenSecondNameAndColon?.raw, 
          colon?.raw, 
          unexpectedBetweenColonAndType?.raw, 
          type.raw, 
          unexpectedBetweenTypeAndDefaultValue?.raw, 
          defaultValue?.raw, 
          unexpectedBetweenDefaultValueAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.enumCaseParameter,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> EnumCaseParameterSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumCaseParameterSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndFirstName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var firstName: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFirstNameAndSecondName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var secondName: TokenSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSecondNameAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the parameter has a label, the colon separating the label from the type.
  public var colon: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The parameter's type.
  public var type: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypeAndDefaultValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the parameter has a default value, the initializer clause describing the default value.
  public var defaultValue: InitializerClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(InitializerClauseSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDefaultValueAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the parameter is followed by another parameter, the comma separating them.
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumCaseParameterSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndFirstName, 
          \Self.firstName, 
          \Self.unexpectedBetweenFirstNameAndSecondName, 
          \Self.secondName, 
          \Self.unexpectedBetweenSecondNameAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndType, 
          \Self.type, 
          \Self.unexpectedBetweenTypeAndDefaultValue, 
          \Self.defaultValue, 
          \Self.unexpectedBetweenDefaultValueAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - EnumDeclSyntax

/// A Swift `enum` declaration.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `enumKeyword`: `'enum'`
///  - `name`: `<identifier>`
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct EnumDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .enumDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``EnumDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .enumDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: The attributes applied to the enum declaration.
  ///   - modifiers: The declaration modifiers applied to the enum declaration.
  ///   - enumKeyword: The `enum` keyword for this declaration.
  ///   - name: Declares the name of this enum. If the name matches a reserved keyword use backticks to escape it.
  ///   - genericParameterClause: The generic parameters, if any, for this enum declaration.
  ///   - inheritanceClause: The inheritance clause describing conformances or raw values for this enum declaration.
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters of this enum declaration.
  ///   - memberBlock: The cases and other members associated with this enum declaration. Because enum extension declarations may declare additional members the contents of this member block isn't guaranteed to be a complete list of members for this type.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndEnumKeyword: UnexpectedNodesSyntax? = nil,
      enumKeyword: TokenSyntax = .keyword(.enum),
      _ unexpectedBetweenEnumKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndEnumKeyword, 
            enumKeyword, 
            unexpectedBetweenEnumKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndEnumKeyword?.raw, 
          enumKeyword.raw, 
          unexpectedBetweenEnumKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.enumDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The attributes applied to the enum declaration.
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> EnumDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The declaration modifiers applied to the enum declaration.
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> EnumDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return EnumDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndEnumKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `enum` keyword for this declaration.
  public var enumKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEnumKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Declares the name of this enum. If the name matches a reserved keyword use backticks to escape it.
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The generic parameters, if any, for this enum declaration.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The inheritance clause describing conformances or raw values for this enum declaration.
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `where` clause that applies to the generic parameters of this enum declaration.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The cases and other members associated with this enum declaration. Because enum extension declarations may declare additional members the contents of this member block isn't guaranteed to be a complete list of members for this type.
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 15, parent: Syntax(self))!)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 15, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = EnumDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndEnumKeyword, 
          \Self.enumKeyword, 
          \Self.unexpectedBetweenEnumKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}

// MARK: - ExposeAttributeArgumentsSyntax

/// The arguments for the '@_expose' attribute
///
/// ### Children
/// 
///  - `language`: ``TokenSyntax``
///  - `comma`: `','`?
///  - `cxxName`: ``StringLiteralExprSyntax``?
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct ExposeAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .exposeAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ExposeAttributeArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .exposeAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLanguage: UnexpectedNodesSyntax? = nil,
      language: TokenSyntax,
      _ unexpectedBetweenLanguageAndComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax? = nil,
      _ unexpectedBetweenCommaAndCxxName: UnexpectedNodesSyntax? = nil,
      cxxName: StringLiteralExprSyntax? = nil,
      _ unexpectedAfterCxxName: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLanguage, 
            language, 
            unexpectedBetweenLanguageAndComma, 
            comma, 
            unexpectedBetweenCommaAndCxxName, 
            cxxName, 
            unexpectedAfterCxxName
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLanguage?.raw, 
          language.raw, 
          unexpectedBetweenLanguageAndComma?.raw, 
          comma?.raw, 
          unexpectedBetweenCommaAndCxxName?.raw, 
          cxxName?.raw, 
          unexpectedAfterCxxName?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.exposeAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLanguage: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExposeAttributeArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var language: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ExposeAttributeArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLanguageAndComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExposeAttributeArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var comma: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ExposeAttributeArgumentsSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCommaAndCxxName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExposeAttributeArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var cxxName: StringLiteralExprSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(StringLiteralExprSyntax.init)
    }
    set(value) {
      self = ExposeAttributeArgumentsSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterCxxName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExposeAttributeArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLanguage, 
          \Self.language, 
          \Self.unexpectedBetweenLanguageAndComma, 
          \Self.comma, 
          \Self.unexpectedBetweenCommaAndCxxName, 
          \Self.cxxName, 
          \Self.unexpectedAfterCxxName
        ])
  }
}

// MARK: - ExpressionPatternSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
public struct ExpressionPatternSyntax: PatternSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .expressionPattern else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ExpressionPatternSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .expressionPattern)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeExpression, expression, unexpectedAfterExpression))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeExpression?.raw, expression.raw, unexpectedAfterExpression?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.expressionPattern,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionPatternSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ExpressionPatternSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionPatternSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeExpression, \Self.expression, \Self.unexpectedAfterExpression])
  }
}

// MARK: - ExpressionSegmentSyntax

/// ### Children
/// 
///  - `backslash`: `'\'`
///  - `pounds`: `<rawStringPoundDelimiter>`?
///  - `leftParen`: `'('`
///  - `expressions`: ``LabeledExprListSyntax``
///  - `rightParen`: `')'`
///
/// ### Contained in
/// 
///  - ``StringLiteralSegmentListSyntax``
public struct ExpressionSegmentSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .expressionSegment else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ExpressionSegmentSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .expressionSegment)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBackslash: UnexpectedNodesSyntax? = nil,
      backslash: TokenSyntax = .backslashToken(),
      _ unexpectedBetweenBackslashAndPounds: UnexpectedNodesSyntax? = nil,
      pounds: TokenSyntax? = nil,
      _ unexpectedBetweenPoundsAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndExpressions: UnexpectedNodesSyntax? = nil,
      expressions: LabeledExprListSyntax,
      _ unexpectedBetweenExpressionsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBackslash, 
            backslash, 
            unexpectedBetweenBackslashAndPounds, 
            pounds, 
            unexpectedBetweenPoundsAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndExpressions, 
            expressions, 
            unexpectedBetweenExpressionsAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBackslash?.raw, 
          backslash.raw, 
          unexpectedBetweenBackslashAndPounds?.raw, 
          pounds?.raw, 
          unexpectedBetweenPoundsAndLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndExpressions?.raw, 
          expressions.raw, 
          unexpectedBetweenExpressionsAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.expressionSegment,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBackslash: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var backslash: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBackslashAndPounds: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var pounds: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPoundsAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndExpressions: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expressions: LabeledExprListSyntax {
    get {
      return LabeledExprListSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `expressions`
  /// collection.
  ///
  /// - param element: The new `Expression` to add to the node's
  ///                  `expressions` collection.
  /// - returns: A copy of the receiver with the provided `Expression`
  ///            appended to its `expressions` collection.
  @available(*, deprecated, message: "Use node.expressions.append(newElement) instead")
  public func addExpression(_ element: LabeledExprSyntax) -> ExpressionSegmentSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[7] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.labeledExprList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 7, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ExpressionSegmentSyntax(newData)
  }
  
  public var unexpectedBetweenExpressionsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionSegmentSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBackslash, 
          \Self.backslash, 
          \Self.unexpectedBetweenBackslashAndPounds, 
          \Self.pounds, 
          \Self.unexpectedBetweenPoundsAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndExpressions, 
          \Self.expressions, 
          \Self.unexpectedBetweenExpressionsAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - ExpressionStmtSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
public struct ExpressionStmtSyntax: StmtSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .expressionStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ExpressionStmtSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .expressionStmt)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeExpression, expression, unexpectedAfterExpression))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeExpression?.raw, expression.raw, unexpectedAfterExpression?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.expressionStmt,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionStmtSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ExpressionStmtSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExpressionStmtSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeExpression, \Self.expression, \Self.unexpectedAfterExpression])
  }
}

// MARK: - ExtensionDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `extensionKeyword`: `'extension'`
///  - `extendedType`: ``TypeSyntax``
///  - `inheritanceClause`: ``InheritanceClauseSyntax``?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `memberBlock`: ``MemberBlockSyntax``
public struct ExtensionDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .extensionDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ExtensionDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .extensionDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndExtensionKeyword: UnexpectedNodesSyntax? = nil,
      extensionKeyword: TokenSyntax = .keyword(.extension),
      _ unexpectedBetweenExtensionKeywordAndExtendedType: UnexpectedNodesSyntax? = nil,
      extendedType: some TypeSyntaxProtocol,
      _ unexpectedBetweenExtendedTypeAndInheritanceClause: UnexpectedNodesSyntax? = nil,
      inheritanceClause: InheritanceClauseSyntax? = nil,
      _ unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? = nil,
      memberBlock: MemberBlockSyntax,
      _ unexpectedAfterMemberBlock: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndExtensionKeyword, 
            extensionKeyword, 
            unexpectedBetweenExtensionKeywordAndExtendedType, 
            extendedType, 
            unexpectedBetweenExtendedTypeAndInheritanceClause, 
            inheritanceClause, 
            unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndMemberBlock, 
            memberBlock, 
            unexpectedAfterMemberBlock
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndExtensionKeyword?.raw, 
          extensionKeyword.raw, 
          unexpectedBetweenExtensionKeywordAndExtendedType?.raw, 
          extendedType.raw, 
          unexpectedBetweenExtendedTypeAndInheritanceClause?.raw, 
          inheritanceClause?.raw, 
          unexpectedBetweenInheritanceClauseAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndMemberBlock?.raw, 
          memberBlock.raw, 
          unexpectedAfterMemberBlock?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.extensionDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> ExtensionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ExtensionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> ExtensionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ExtensionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndExtensionKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var extensionKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExtensionKeywordAndExtendedType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var extendedType: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExtendedTypeAndInheritanceClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var inheritanceClause: InheritanceClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(InheritanceClauseSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var memberBlock: MemberBlockSyntax {
    get {
      return MemberBlockSyntax(data.child(at: 13, parent: Syntax(self))!)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 13, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterMemberBlock: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ExtensionDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndExtensionKeyword, 
          \Self.extensionKeyword, 
          \Self.unexpectedBetweenExtensionKeywordAndExtendedType, 
          \Self.extendedType, 
          \Self.unexpectedBetweenExtendedTypeAndInheritanceClause, 
          \Self.inheritanceClause, 
          \Self.unexpectedBetweenInheritanceClauseAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndMemberBlock, 
          \Self.memberBlock, 
          \Self.unexpectedAfterMemberBlock
        ])
  }
}

// MARK: - FallThroughStmtSyntax

/// ### Children
/// 
///  - `fallthroughKeyword`: `'fallthrough'`
public struct FallThroughStmtSyntax: StmtSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .fallThroughStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FallThroughStmtSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .fallThroughStmt)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeFallthroughKeyword: UnexpectedNodesSyntax? = nil,
      fallthroughKeyword: TokenSyntax = .keyword(.fallthrough),
      _ unexpectedAfterFallthroughKeyword: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeFallthroughKeyword, fallthroughKeyword, unexpectedAfterFallthroughKeyword))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeFallthroughKeyword?.raw, fallthroughKeyword.raw, unexpectedAfterFallthroughKeyword?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.fallThroughStmt,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeFallthroughKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FallThroughStmtSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var fallthroughKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FallThroughStmtSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterFallthroughKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FallThroughStmtSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeFallthroughKeyword, \Self.fallthroughKeyword, \Self.unexpectedAfterFallthroughKeyword])
  }
}

// MARK: - FloatLiteralExprSyntax

/// ### Children
/// 
///  - `literal`: `<floatLiteral>`
public struct FloatLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .floatLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FloatLiteralExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .floatLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLiteral: UnexpectedNodesSyntax? = nil,
      literal: TokenSyntax,
      _ unexpectedAfterLiteral: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeLiteral, literal, unexpectedAfterLiteral))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeLiteral?.raw, literal.raw, unexpectedAfterLiteral?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.floatLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLiteral: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FloatLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var literal: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FloatLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterLiteral: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FloatLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeLiteral, \Self.literal, \Self.unexpectedAfterLiteral])
  }
}

// MARK: - ForStmtSyntax

/// ### Children
/// 
///  - `forKeyword`: `'for'`
///  - `tryKeyword`: `'try'`?
///  - `awaitKeyword`: `'await'`?
///  - `caseKeyword`: `'case'`?
///  - `pattern`: ``PatternSyntax``
///  - `typeAnnotation`: ``TypeAnnotationSyntax``?
///  - `inKeyword`: `'in'`
///  - `sequence`: ``ExprSyntax``
///  - `whereClause`: ``WhereClauseSyntax``?
///  - `body`: ``CodeBlockSyntax``
public struct ForStmtSyntax: StmtSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .forStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ForStmtSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .forStmt)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeForKeyword: UnexpectedNodesSyntax? = nil,
      forKeyword: TokenSyntax = .keyword(.for),
      _ unexpectedBetweenForKeywordAndTryKeyword: UnexpectedNodesSyntax? = nil,
      tryKeyword: TokenSyntax? = nil,
      _ unexpectedBetweenTryKeywordAndAwaitKeyword: UnexpectedNodesSyntax? = nil,
      awaitKeyword: TokenSyntax? = nil,
      _ unexpectedBetweenAwaitKeywordAndCaseKeyword: UnexpectedNodesSyntax? = nil,
      caseKeyword: TokenSyntax? = nil,
      _ unexpectedBetweenCaseKeywordAndPattern: UnexpectedNodesSyntax? = nil,
      pattern: some PatternSyntaxProtocol,
      _ unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodesSyntax? = nil,
      typeAnnotation: TypeAnnotationSyntax? = nil,
      _ unexpectedBetweenTypeAnnotationAndInKeyword: UnexpectedNodesSyntax? = nil,
      inKeyword: TokenSyntax = .keyword(.in),
      _ unexpectedBetweenInKeywordAndSequence: UnexpectedNodesSyntax? = nil,
      sequence: some ExprSyntaxProtocol,
      _ unexpectedBetweenSequenceAndWhereClause: UnexpectedNodesSyntax? = nil,
      whereClause: WhereClauseSyntax? = nil,
      _ unexpectedBetweenWhereClauseAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeForKeyword, 
            forKeyword, 
            unexpectedBetweenForKeywordAndTryKeyword, 
            tryKeyword, 
            unexpectedBetweenTryKeywordAndAwaitKeyword, 
            awaitKeyword, 
            unexpectedBetweenAwaitKeywordAndCaseKeyword, 
            caseKeyword, 
            unexpectedBetweenCaseKeywordAndPattern, 
            pattern, 
            unexpectedBetweenPatternAndTypeAnnotation, 
            typeAnnotation, 
            unexpectedBetweenTypeAnnotationAndInKeyword, 
            inKeyword, 
            unexpectedBetweenInKeywordAndSequence, 
            sequence, 
            unexpectedBetweenSequenceAndWhereClause, 
            whereClause, 
            unexpectedBetweenWhereClauseAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeForKeyword?.raw, 
          forKeyword.raw, 
          unexpectedBetweenForKeywordAndTryKeyword?.raw, 
          tryKeyword?.raw, 
          unexpectedBetweenTryKeywordAndAwaitKeyword?.raw, 
          awaitKeyword?.raw, 
          unexpectedBetweenAwaitKeywordAndCaseKeyword?.raw, 
          caseKeyword?.raw, 
          unexpectedBetweenCaseKeywordAndPattern?.raw, 
          pattern.raw, 
          unexpectedBetweenPatternAndTypeAnnotation?.raw, 
          typeAnnotation?.raw, 
          unexpectedBetweenTypeAnnotationAndInKeyword?.raw, 
          inKeyword.raw, 
          unexpectedBetweenInKeywordAndSequence?.raw, 
          sequence.raw, 
          unexpectedBetweenSequenceAndWhereClause?.raw, 
          whereClause?.raw, 
          unexpectedBetweenWhereClauseAndBody?.raw, 
          body.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.forStmt,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeForKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var forKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenForKeywordAndTryKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var tryKeyword: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTryKeywordAndAwaitKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var awaitKeyword: TokenSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAwaitKeywordAndCaseKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var caseKeyword: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCaseKeywordAndPattern: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var pattern: PatternSyntax {
    get {
      return PatternSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var typeAnnotation: TypeAnnotationSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(TypeAnnotationSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypeAnnotationAndInKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var inKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 13, parent: Syntax(self))!)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 13, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInKeywordAndSequence: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var sequence: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 15, parent: Syntax(self))!)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 15, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSequenceAndWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var whereClause: WhereClauseSyntax? {
    get {
      return data.child(at: 17, parent: Syntax(self)).map(WhereClauseSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 17, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenWhereClauseAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 18, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 18, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax {
    get {
      return CodeBlockSyntax(data.child(at: 19, parent: Syntax(self))!)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 19, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 20, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForStmtSyntax(data.replacingChild(at: 20, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeForKeyword, 
          \Self.forKeyword, 
          \Self.unexpectedBetweenForKeywordAndTryKeyword, 
          \Self.tryKeyword, 
          \Self.unexpectedBetweenTryKeywordAndAwaitKeyword, 
          \Self.awaitKeyword, 
          \Self.unexpectedBetweenAwaitKeywordAndCaseKeyword, 
          \Self.caseKeyword, 
          \Self.unexpectedBetweenCaseKeywordAndPattern, 
          \Self.pattern, 
          \Self.unexpectedBetweenPatternAndTypeAnnotation, 
          \Self.typeAnnotation, 
          \Self.unexpectedBetweenTypeAnnotationAndInKeyword, 
          \Self.inKeyword, 
          \Self.unexpectedBetweenInKeywordAndSequence, 
          \Self.sequence, 
          \Self.unexpectedBetweenSequenceAndWhereClause, 
          \Self.whereClause, 
          \Self.unexpectedBetweenWhereClauseAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - ForceUnwrapExprSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `exclamationMark`: `'!'`
public struct ForceUnwrapExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .forceUnwrapExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ForceUnwrapExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .forceUnwrapExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndExclamationMark: UnexpectedNodesSyntax? = nil,
      exclamationMark: TokenSyntax = .exclamationMarkToken(),
      _ unexpectedAfterExclamationMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndExclamationMark, 
            exclamationMark, 
            unexpectedAfterExclamationMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndExclamationMark?.raw, 
          exclamationMark.raw, 
          unexpectedAfterExclamationMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.forceUnwrapExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForceUnwrapExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ForceUnwrapExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForceUnwrapExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var exclamationMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ForceUnwrapExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ForceUnwrapExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndExclamationMark, 
          \Self.exclamationMark, 
          \Self.unexpectedAfterExclamationMark
        ])
  }
}

// MARK: - FunctionCallExprSyntax

/// ### Children
/// 
///  - `calledExpression`: ``ExprSyntax``
///  - `leftParen`: `'('`?
///  - `arguments`: ``LabeledExprListSyntax``
///  - `rightParen`: `')'`?
///  - `trailingClosure`: ``ClosureExprSyntax``?
///  - `additionalTrailingClosures`: ``MultipleTrailingClosureElementListSyntax``
public struct FunctionCallExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionCallExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FunctionCallExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionCallExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? = nil,
      calledExpression: some ExprSyntaxProtocol,
      _ unexpectedBetweenCalledExpressionAndLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax? = nil,
      _ unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: LabeledExprListSyntax,
      _ unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax? = nil,
      _ unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? = nil,
      trailingClosure: ClosureExprSyntax? = nil,
      _ unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      additionalTrailingClosures: MultipleTrailingClosureElementListSyntax = [],
      _ unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeCalledExpression, 
            calledExpression, 
            unexpectedBetweenCalledExpressionAndLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndRightParen, 
            rightParen, 
            unexpectedBetweenRightParenAndTrailingClosure, 
            trailingClosure, 
            unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
            additionalTrailingClosures, 
            unexpectedAfterAdditionalTrailingClosures
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeCalledExpression?.raw, 
          calledExpression.raw, 
          unexpectedBetweenCalledExpressionAndLeftParen?.raw, 
          leftParen?.raw, 
          unexpectedBetweenLeftParenAndArguments?.raw, 
          arguments.raw, 
          unexpectedBetweenArgumentsAndRightParen?.raw, 
          rightParen?.raw, 
          unexpectedBetweenRightParenAndTrailingClosure?.raw, 
          trailingClosure?.raw, 
          unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.raw, 
          additionalTrailingClosures.raw, 
          unexpectedAfterAdditionalTrailingClosures?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionCallExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeCalledExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var calledExpression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCalledExpressionAndLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arguments: LabeledExprListSyntax {
    get {
      return LabeledExprListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `arguments`
  /// collection.
  ///
  /// - param element: The new `Argument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `arguments` collection.
  @available(*, deprecated, message: "Use node.arguments.append(newElement) instead")
  public func addArgument(_ element: LabeledExprSyntax) -> FunctionCallExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.labeledExprList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionCallExprSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingClosure: ClosureExprSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(ClosureExprSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var additionalTrailingClosures: MultipleTrailingClosureElementListSyntax {
    get {
      return MultipleTrailingClosureElementListSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `additionalTrailingClosures`
  /// collection.
  ///
  /// - param element: The new `AdditionalTrailingClosure` to add to the node's
  ///                  `additionalTrailingClosures` collection.
  /// - returns: A copy of the receiver with the provided `AdditionalTrailingClosure`
  ///            appended to its `additionalTrailingClosures` collection.
  @available(*, deprecated, message: "Use node.additionalTrailingClosures.append(newElement) instead")
  public func addAdditionalTrailingClosure(_ element: MultipleTrailingClosureElementSyntax) -> FunctionCallExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[11] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.multipleTrailingClosureElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 11, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionCallExprSyntax(newData)
  }
  
  public var unexpectedAfterAdditionalTrailingClosures: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionCallExprSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeCalledExpression, 
          \Self.calledExpression, 
          \Self.unexpectedBetweenCalledExpressionAndLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedBetweenRightParenAndTrailingClosure, 
          \Self.trailingClosure, 
          \Self.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, 
          \Self.additionalTrailingClosures, 
          \Self.unexpectedAfterAdditionalTrailingClosures
        ])
  }
}

// MARK: - FunctionDeclSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `funcKeyword`: `'func'`
///  - `name`: (`<identifier>` | `<binaryOperator>` | `<prefixOperator>` | `<postfixOperator>`)
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `signature`: ``FunctionSignatureSyntax``
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `body`: ``CodeBlockSyntax``?
public struct FunctionDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FunctionDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - genericParameterClause: The parameter clause that defines the generic parameters.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndFuncKeyword: UnexpectedNodesSyntax? = nil,
      funcKeyword: TokenSyntax = .keyword(.func),
      _ unexpectedBetweenFuncKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? = nil,
      signature: FunctionSignatureSyntax,
      _ unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax? = nil,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndFuncKeyword, 
            funcKeyword, 
            unexpectedBetweenFuncKeywordAndName, 
            name, 
            unexpectedBetweenNameAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndSignature, 
            signature, 
            unexpectedBetweenSignatureAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndFuncKeyword?.raw, 
          funcKeyword.raw, 
          unexpectedBetweenFuncKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndSignature?.raw, 
          signature.raw, 
          unexpectedBetweenSignatureAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndBody?.raw, 
          body?.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> FunctionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> FunctionDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndFuncKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var funcKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFuncKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The parameter clause that defines the generic parameters.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var signature: FunctionSignatureSyntax {
    get {
      return FunctionSignatureSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(CodeBlockSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndFuncKeyword, 
          \Self.funcKeyword, 
          \Self.unexpectedBetweenFuncKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndSignature, 
          \Self.signature, 
          \Self.unexpectedBetweenSignatureAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - FunctionEffectSpecifiersSyntax

/// ### Children
/// 
///  - `asyncSpecifier`: (`'async'` | `'reasync'`)?
///  - `throwsSpecifier`: (`'throws'` | `'rethrows'`)?
///
/// ### Contained in
/// 
///  - ``FunctionSignatureSyntax``.``FunctionSignatureSyntax/effectSpecifiers``
public struct FunctionEffectSpecifiersSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionEffectSpecifiers else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FunctionEffectSpecifiersSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionEffectSpecifiers)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAsyncSpecifier: UnexpectedNodesSyntax? = nil,
      asyncSpecifier: TokenSyntax? = nil,
      _ unexpectedBetweenAsyncSpecifierAndThrowsSpecifier: UnexpectedNodesSyntax? = nil,
      throwsSpecifier: TokenSyntax? = nil,
      _ unexpectedAfterThrowsSpecifier: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAsyncSpecifier, 
            asyncSpecifier, 
            unexpectedBetweenAsyncSpecifierAndThrowsSpecifier, 
            throwsSpecifier, 
            unexpectedAfterThrowsSpecifier
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAsyncSpecifier?.raw, 
          asyncSpecifier?.raw, 
          unexpectedBetweenAsyncSpecifierAndThrowsSpecifier?.raw, 
          throwsSpecifier?.raw, 
          unexpectedAfterThrowsSpecifier?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionEffectSpecifiers,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAsyncSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionEffectSpecifiersSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var asyncSpecifier: TokenSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionEffectSpecifiersSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAsyncSpecifierAndThrowsSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionEffectSpecifiersSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var throwsSpecifier: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionEffectSpecifiersSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterThrowsSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionEffectSpecifiersSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAsyncSpecifier, 
          \Self.asyncSpecifier, 
          \Self.unexpectedBetweenAsyncSpecifierAndThrowsSpecifier, 
          \Self.throwsSpecifier, 
          \Self.unexpectedAfterThrowsSpecifier
        ])
  }
}

// MARK: - FunctionParameterClauseSyntax

/// ### Children
/// 
///  - `leftParen`: `'('`
///  - `parameters`: ``FunctionParameterListSyntax``
///  - `rightParen`: `')'`
///
/// ### Contained in
/// 
///  - ``FunctionSignatureSyntax``.``FunctionSignatureSyntax/parameterClause``
///  - ``SubscriptDeclSyntax``.``SubscriptDeclSyntax/parameterClause``
public struct FunctionParameterClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionParameterClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FunctionParameterClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionParameterClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndParameters: UnexpectedNodesSyntax? = nil,
      parameters: FunctionParameterListSyntax,
      _ unexpectedBetweenParametersAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndParameters, 
            parameters, 
            unexpectedBetweenParametersAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndParameters?.raw, 
          parameters.raw, 
          unexpectedBetweenParametersAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionParameterClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionParameterClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndParameters: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var parameters: FunctionParameterListSyntax {
    get {
      return FunctionParameterListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionParameterClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `parameters`
  /// collection.
  ///
  /// - param element: The new `Parameter` to add to the node's
  ///                  `parameters` collection.
  /// - returns: A copy of the receiver with the provided `Parameter`
  ///            appended to its `parameters` collection.
  @available(*, deprecated, message: "Use node.parameters.append(newElement) instead")
  public func addParameter(_ element: FunctionParameterSyntax) -> FunctionParameterClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.functionParameterList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionParameterClauseSyntax(newData)
  }
  
  public var unexpectedBetweenParametersAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionParameterClauseSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterClauseSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndParameters, 
          \Self.parameters, 
          \Self.unexpectedBetweenParametersAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - FunctionParameterSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `firstName`: (`<identifier>` | `'_'`)
///  - `secondName`: (`<identifier>` | `'_'`)?
///  - `colon`: `':'`
///  - `type`: ``TypeSyntax``
///  - `ellipsis`: `'...'`?
///  - `defaultValue`: ``InitializerClauseSyntax``?
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``FunctionParameterListSyntax``
public struct FunctionParameterSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionParameter else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FunctionParameterSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionParameter)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndFirstName: UnexpectedNodesSyntax? = nil,
      firstName: TokenSyntax,
      _ unexpectedBetweenFirstNameAndSecondName: UnexpectedNodesSyntax? = nil,
      secondName: TokenSyntax? = nil,
      _ unexpectedBetweenSecondNameAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedBetweenTypeAndEllipsis: UnexpectedNodesSyntax? = nil,
      ellipsis: TokenSyntax? = nil,
      _ unexpectedBetweenEllipsisAndDefaultValue: UnexpectedNodesSyntax? = nil,
      defaultValue: InitializerClauseSyntax? = nil,
      _ unexpectedBetweenDefaultValueAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndFirstName, 
            firstName, 
            unexpectedBetweenFirstNameAndSecondName, 
            secondName, 
            unexpectedBetweenSecondNameAndColon, 
            colon, 
            unexpectedBetweenColonAndType, 
            type, 
            unexpectedBetweenTypeAndEllipsis, 
            ellipsis, 
            unexpectedBetweenEllipsisAndDefaultValue, 
            defaultValue, 
            unexpectedBetweenDefaultValueAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndFirstName?.raw, 
          firstName.raw, 
          unexpectedBetweenFirstNameAndSecondName?.raw, 
          secondName?.raw, 
          unexpectedBetweenSecondNameAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndType?.raw, 
          type.raw, 
          unexpectedBetweenTypeAndEllipsis?.raw, 
          ellipsis?.raw, 
          unexpectedBetweenEllipsisAndDefaultValue?.raw, 
          defaultValue?.raw, 
          unexpectedBetweenDefaultValueAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionParameter,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> FunctionParameterSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionParameterSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> FunctionParameterSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionParameterSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndFirstName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var firstName: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenFirstNameAndSecondName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var secondName: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSecondNameAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var type: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypeAndEllipsis: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var ellipsis: TokenSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEllipsisAndDefaultValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var defaultValue: InitializerClauseSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(InitializerClauseSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDefaultValueAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 17, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 17, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 18, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionParameterSyntax(data.replacingChild(at: 18, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndFirstName, 
          \Self.firstName, 
          \Self.unexpectedBetweenFirstNameAndSecondName, 
          \Self.secondName, 
          \Self.unexpectedBetweenSecondNameAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndType, 
          \Self.type, 
          \Self.unexpectedBetweenTypeAndEllipsis, 
          \Self.ellipsis, 
          \Self.unexpectedBetweenEllipsisAndDefaultValue, 
          \Self.defaultValue, 
          \Self.unexpectedBetweenDefaultValueAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - FunctionSignatureSyntax

/// ### Children
/// 
///  - `parameterClause`: ``FunctionParameterClauseSyntax``
///  - `effectSpecifiers`: ``FunctionEffectSpecifiersSyntax``?
///  - `returnClause`: ``ReturnClauseSyntax``?
///
/// ### Contained in
/// 
///  - ``FunctionDeclSyntax``.``FunctionDeclSyntax/signature``
///  - ``InitializerDeclSyntax``.``InitializerDeclSyntax/signature``
///  - ``MacroDeclSyntax``.``MacroDeclSyntax/signature``
public struct FunctionSignatureSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionSignature else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FunctionSignatureSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionSignature)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeParameterClause: UnexpectedNodesSyntax? = nil,
      parameterClause: FunctionParameterClauseSyntax,
      _ unexpectedBetweenParameterClauseAndEffectSpecifiers: UnexpectedNodesSyntax? = nil,
      effectSpecifiers: FunctionEffectSpecifiersSyntax? = nil,
      _ unexpectedBetweenEffectSpecifiersAndReturnClause: UnexpectedNodesSyntax? = nil,
      returnClause: ReturnClauseSyntax? = nil,
      _ unexpectedAfterReturnClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeParameterClause, 
            parameterClause, 
            unexpectedBetweenParameterClauseAndEffectSpecifiers, 
            effectSpecifiers, 
            unexpectedBetweenEffectSpecifiersAndReturnClause, 
            returnClause, 
            unexpectedAfterReturnClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeParameterClause?.raw, 
          parameterClause.raw, 
          unexpectedBetweenParameterClauseAndEffectSpecifiers?.raw, 
          effectSpecifiers?.raw, 
          unexpectedBetweenEffectSpecifiersAndReturnClause?.raw, 
          returnClause?.raw, 
          unexpectedAfterReturnClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionSignature,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionSignatureSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var parameterClause: FunctionParameterClauseSyntax {
    get {
      return FunctionParameterClauseSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionSignatureSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenParameterClauseAndEffectSpecifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionSignatureSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var effectSpecifiers: FunctionEffectSpecifiersSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(FunctionEffectSpecifiersSyntax.init)
    }
    set(value) {
      self = FunctionSignatureSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEffectSpecifiersAndReturnClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionSignatureSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var returnClause: ReturnClauseSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(ReturnClauseSyntax.init)
    }
    set(value) {
      self = FunctionSignatureSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterReturnClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionSignatureSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeParameterClause, 
          \Self.parameterClause, 
          \Self.unexpectedBetweenParameterClauseAndEffectSpecifiers, 
          \Self.effectSpecifiers, 
          \Self.unexpectedBetweenEffectSpecifiersAndReturnClause, 
          \Self.returnClause, 
          \Self.unexpectedAfterReturnClause
        ])
  }
}

// MARK: - FunctionTypeSyntax

/// ### Children
/// 
///  - `leftParen`: `'('`
///  - `parameters`: ``TupleTypeElementListSyntax``
///  - `rightParen`: `')'`
///  - `effectSpecifiers`: ``TypeEffectSpecifiersSyntax``?
///  - `returnClause`: ``ReturnClauseSyntax``
public struct FunctionTypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``FunctionTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .functionType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndParameters: UnexpectedNodesSyntax? = nil,
      parameters: TupleTypeElementListSyntax,
      _ unexpectedBetweenParametersAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedBetweenRightParenAndEffectSpecifiers: UnexpectedNodesSyntax? = nil,
      effectSpecifiers: TypeEffectSpecifiersSyntax? = nil,
      _ unexpectedBetweenEffectSpecifiersAndReturnClause: UnexpectedNodesSyntax? = nil,
      returnClause: ReturnClauseSyntax,
      _ unexpectedAfterReturnClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndParameters, 
            parameters, 
            unexpectedBetweenParametersAndRightParen, 
            rightParen, 
            unexpectedBetweenRightParenAndEffectSpecifiers, 
            effectSpecifiers, 
            unexpectedBetweenEffectSpecifiersAndReturnClause, 
            returnClause, 
            unexpectedAfterReturnClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndParameters?.raw, 
          parameters.raw, 
          unexpectedBetweenParametersAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedBetweenRightParenAndEffectSpecifiers?.raw, 
          effectSpecifiers?.raw, 
          unexpectedBetweenEffectSpecifiersAndReturnClause?.raw, 
          returnClause.raw, 
          unexpectedAfterReturnClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.functionType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndParameters: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var parameters: TupleTypeElementListSyntax {
    get {
      return TupleTypeElementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `parameters`
  /// collection.
  ///
  /// - param element: The new `Parameter` to add to the node's
  ///                  `parameters` collection.
  /// - returns: A copy of the receiver with the provided `Parameter`
  ///            appended to its `parameters` collection.
  @available(*, deprecated, message: "Use node.parameters.append(newElement) instead")
  public func addParameter(_ element: TupleTypeElementSyntax) -> FunctionTypeSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.tupleTypeElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return FunctionTypeSyntax(newData)
  }
  
  public var unexpectedBetweenParametersAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRightParenAndEffectSpecifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var effectSpecifiers: TypeEffectSpecifiersSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TypeEffectSpecifiersSyntax.init)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEffectSpecifiersAndReturnClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var returnClause: ReturnClauseSyntax {
    get {
      return ReturnClauseSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterReturnClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = FunctionTypeSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndParameters, 
          \Self.parameters, 
          \Self.unexpectedBetweenParametersAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedBetweenRightParenAndEffectSpecifiers, 
          \Self.effectSpecifiers, 
          \Self.unexpectedBetweenEffectSpecifiersAndReturnClause, 
          \Self.returnClause, 
          \Self.unexpectedAfterReturnClause
        ])
  }
}
