//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - GenericArgumentClauseSyntax

/// ### Children
/// 
///  - `leftAngle`: `'<'`
///  - `arguments`: ``GenericArgumentListSyntax``
///  - `rightAngle`: `'>'`
///
/// ### Contained in
/// 
///  - ``GenericSpecializationExprSyntax``.``GenericSpecializationExprSyntax/genericArgumentClause``
///  - ``IdentifierTypeSyntax``.``IdentifierTypeSyntax/genericArgumentClause``
///  - ``KeyPathPropertyComponentSyntax``.``KeyPathPropertyComponentSyntax/genericArgumentClause``
///  - ``MacroExpansionDeclSyntax``.``MacroExpansionDeclSyntax/genericArgumentClause``
///  - ``MacroExpansionExprSyntax``.``MacroExpansionExprSyntax/genericArgumentClause``
///  - ``MemberTypeSyntax``.``MemberTypeSyntax/genericArgumentClause``
public struct GenericArgumentClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericArgumentClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``GenericArgumentClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericArgumentClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftAngle: UnexpectedNodesSyntax? = nil,
      leftAngle: TokenSyntax = .leftAngleToken(),
      _ unexpectedBetweenLeftAngleAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: GenericArgumentListSyntax,
      _ unexpectedBetweenArgumentsAndRightAngle: UnexpectedNodesSyntax? = nil,
      rightAngle: TokenSyntax = .rightAngleToken(),
      _ unexpectedAfterRightAngle: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftAngle, 
            leftAngle, 
            unexpectedBetweenLeftAngleAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndRightAngle, 
            rightAngle, 
            unexpectedAfterRightAngle
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftAngle?.raw, 
          leftAngle.raw, 
          unexpectedBetweenLeftAngleAndArguments?.raw, 
          arguments.raw, 
          unexpectedBetweenArgumentsAndRightAngle?.raw, 
          rightAngle.raw, 
          unexpectedAfterRightAngle?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.genericArgumentClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftAngle: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericArgumentClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftAngle: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericArgumentClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftAngleAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericArgumentClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arguments: GenericArgumentListSyntax {
    get {
      return GenericArgumentListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericArgumentClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `arguments`
  /// collection.
  ///
  /// - param element: The new `Argument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `arguments` collection.
  @available(*, deprecated, message: "Use node.arguments.append(newElement) instead")
  public func addArgument(_ element: GenericArgumentSyntax) -> GenericArgumentClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.genericArgumentList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return GenericArgumentClauseSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentsAndRightAngle: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericArgumentClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightAngle: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericArgumentClauseSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightAngle: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericArgumentClauseSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftAngle, 
          \Self.leftAngle, 
          \Self.unexpectedBetweenLeftAngleAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndRightAngle, 
          \Self.rightAngle, 
          \Self.unexpectedAfterRightAngle
        ])
  }
}

// MARK: - GenericArgumentSyntax

/// ### Children
/// 
///  - `argument`: ``TypeSyntax``
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``GenericArgumentListSyntax``
public struct GenericArgumentSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericArgument else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``GenericArgumentSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericArgument)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeArgument: UnexpectedNodesSyntax? = nil,
      argument: some TypeSyntaxProtocol,
      _ unexpectedBetweenArgumentAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeArgument, 
            argument, 
            unexpectedBetweenArgumentAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeArgument?.raw, 
          argument.raw, 
          unexpectedBetweenArgumentAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.genericArgument,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeArgument: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericArgumentSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var argument: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericArgumentSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenArgumentAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericArgumentSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = GenericArgumentSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericArgumentSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeArgument, 
          \Self.argument, 
          \Self.unexpectedBetweenArgumentAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - GenericParameterClauseSyntax

/// The parameter clause that defines the generic parameters.
///
/// ### Children
/// 
///  - `leftAngle`: `'<'`
///  - `parameters`: ``GenericParameterListSyntax``
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `rightAngle`: `'>'`
///
/// ### Contained in
/// 
///  - ``ActorDeclSyntax``.``ActorDeclSyntax/genericParameterClause``
///  - ``ClassDeclSyntax``.``ClassDeclSyntax/genericParameterClause``
///  - ``EnumDeclSyntax``.``EnumDeclSyntax/genericParameterClause``
///  - ``FunctionDeclSyntax``.``FunctionDeclSyntax/genericParameterClause``
///  - ``InitializerDeclSyntax``.``InitializerDeclSyntax/genericParameterClause``
///  - ``MacroDeclSyntax``.``MacroDeclSyntax/genericParameterClause``
///  - ``NamedOpaqueReturnTypeSyntax``.``NamedOpaqueReturnTypeSyntax/genericParameterClause``
///  - ``StructDeclSyntax``.``StructDeclSyntax/genericParameterClause``
///  - ``SubscriptDeclSyntax``.``SubscriptDeclSyntax/genericParameterClause``
///  - ``TypeAliasDeclSyntax``.``TypeAliasDeclSyntax/genericParameterClause``
public struct GenericParameterClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericParameterClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``GenericParameterClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericParameterClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - leftAngle: The opening angle bracket (`<`) of the generic parameter clause.
  ///   - parameters: The list of generic parameters in the clause.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  ///   - rightAngle: The closing angle bracket (`>`) of the generic parameter clause.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftAngle: UnexpectedNodesSyntax? = nil,
      leftAngle: TokenSyntax = .leftAngleToken(),
      _ unexpectedBetweenLeftAngleAndParameters: UnexpectedNodesSyntax? = nil,
      parameters: GenericParameterListSyntax,
      _ unexpectedBetweenParametersAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndRightAngle: UnexpectedNodesSyntax? = nil,
      rightAngle: TokenSyntax = .rightAngleToken(),
      _ unexpectedAfterRightAngle: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftAngle, 
            leftAngle, 
            unexpectedBetweenLeftAngleAndParameters, 
            parameters, 
            unexpectedBetweenParametersAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndRightAngle, 
            rightAngle, 
            unexpectedAfterRightAngle
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftAngle?.raw, 
          leftAngle.raw, 
          unexpectedBetweenLeftAngleAndParameters?.raw, 
          parameters.raw, 
          unexpectedBetweenParametersAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndRightAngle?.raw, 
          rightAngle.raw, 
          unexpectedAfterRightAngle?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.genericParameterClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftAngle: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The opening angle bracket (`<`) of the generic parameter clause.
  public var leftAngle: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericParameterClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftAngleAndParameters: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The list of generic parameters in the clause.
  public var parameters: GenericParameterListSyntax {
    get {
      return GenericParameterListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericParameterClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `parameters`
  /// collection.
  ///
  /// - param element: The new `Parameter` to add to the node's
  ///                  `parameters` collection.
  /// - returns: A copy of the receiver with the provided `Parameter`
  ///            appended to its `parameters` collection.
  @available(*, deprecated, message: "Use node.parameters.append(newElement) instead")
  public func addParameter(_ element: GenericParameterSyntax) -> GenericParameterClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.genericParameterList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return GenericParameterClauseSyntax(newData)
  }
  
  public var unexpectedBetweenParametersAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = GenericParameterClauseSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndRightAngle: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterClauseSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The closing angle bracket (`>`) of the generic parameter clause.
  public var rightAngle: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericParameterClauseSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightAngle: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterClauseSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftAngle, 
          \Self.leftAngle, 
          \Self.unexpectedBetweenLeftAngleAndParameters, 
          \Self.parameters, 
          \Self.unexpectedBetweenParametersAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndRightAngle, 
          \Self.rightAngle, 
          \Self.unexpectedAfterRightAngle
        ])
  }
}

// MARK: - GenericParameterSyntax

/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `eachKeyword`: `'each'`?
///  - `name`: `<identifier>`
///  - `colon`: `':'`?
///  - `inheritedType`: ``TypeSyntax``?
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``GenericParameterListSyntax``
public struct GenericParameterSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericParameter else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``GenericParameterSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericParameter)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndEachKeyword: UnexpectedNodesSyntax? = nil,
      eachKeyword: TokenSyntax? = nil,
      _ unexpectedBetweenEachKeywordAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax? = nil,
      _ unexpectedBetweenColonAndInheritedType: UnexpectedNodesSyntax? = nil,
      inheritedType: (some TypeSyntaxProtocol)? = TypeSyntax?.none,
      _ unexpectedBetweenInheritedTypeAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndEachKeyword, 
            eachKeyword, 
            unexpectedBetweenEachKeywordAndName, 
            name, 
            unexpectedBetweenNameAndColon, 
            colon, 
            unexpectedBetweenColonAndInheritedType, 
            inheritedType, 
            unexpectedBetweenInheritedTypeAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndEachKeyword?.raw, 
          eachKeyword?.raw, 
          unexpectedBetweenEachKeywordAndName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndColon?.raw, 
          colon?.raw, 
          unexpectedBetweenColonAndInheritedType?.raw, 
          inheritedType?.raw, 
          unexpectedBetweenInheritedTypeAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.genericParameter,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> GenericParameterSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return GenericParameterSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndEachKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var eachKeyword: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEachKeywordAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndInheritedType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var inheritedType: TypeSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(TypeSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInheritedTypeAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericParameterSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndEachKeyword, 
          \Self.eachKeyword, 
          \Self.unexpectedBetweenEachKeywordAndName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndInheritedType, 
          \Self.inheritedType, 
          \Self.unexpectedBetweenInheritedTypeAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - GenericRequirementSyntax

/// ### Children
/// 
///  - `requirement`: (``SameTypeRequirementSyntax`` | ``ConformanceRequirementSyntax`` | ``LayoutRequirementSyntax``)
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``GenericRequirementListSyntax``
public struct GenericRequirementSyntax: SyntaxProtocol, SyntaxHashable {
  public enum Requirement: SyntaxChildChoices, SyntaxHashable {
    case `sameTypeRequirement`(SameTypeRequirementSyntax)
    case `conformanceRequirement`(ConformanceRequirementSyntax)
    case `layoutRequirement`(LayoutRequirementSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .sameTypeRequirement(let node):
        return node._syntaxNode
      case .conformanceRequirement(let node):
        return node._syntaxNode
      case .layoutRequirement(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: SameTypeRequirementSyntax) {
      self = .sameTypeRequirement(node)
    }
    
    public init(_ node: ConformanceRequirementSyntax) {
      self = .conformanceRequirement(node)
    }
    
    public init(_ node: LayoutRequirementSyntax) {
      self = .layoutRequirement(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(SameTypeRequirementSyntax.self) {
        self = .sameTypeRequirement(node)
        return
      }
      if let node = node.as(ConformanceRequirementSyntax.self) {
        self = .conformanceRequirement(node)
        return
      }
      if let node = node.as(LayoutRequirementSyntax.self) {
        self = .layoutRequirement(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(SameTypeRequirementSyntax.self), .node(ConformanceRequirementSyntax.self), .node(LayoutRequirementSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericRequirement else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``GenericRequirementSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericRequirement)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeRequirement: UnexpectedNodesSyntax? = nil,
      requirement: Requirement,
      _ unexpectedBetweenRequirementAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeRequirement, 
            requirement, 
            unexpectedBetweenRequirementAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeRequirement?.raw, 
          requirement.raw, 
          unexpectedBetweenRequirementAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.genericRequirement,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeRequirement: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericRequirementSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var requirement: Requirement {
    get {
      return Requirement(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericRequirementSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenRequirementAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericRequirementSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = GenericRequirementSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericRequirementSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeRequirement, 
          \Self.requirement, 
          \Self.unexpectedBetweenRequirementAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - GenericSpecializationExprSyntax

/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `genericArgumentClause`: ``GenericArgumentClauseSyntax``
public struct GenericSpecializationExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericSpecializationExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``GenericSpecializationExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericSpecializationExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      genericArgumentClause: GenericArgumentClauseSyntax,
      _ unexpectedAfterGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndGenericArgumentClause, 
            genericArgumentClause, 
            unexpectedAfterGenericArgumentClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndGenericArgumentClause?.raw, 
          genericArgumentClause.raw, 
          unexpectedAfterGenericArgumentClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.genericSpecializationExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericSpecializationExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericSpecializationExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericSpecializationExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var genericArgumentClause: GenericArgumentClauseSyntax {
    get {
      return GenericArgumentClauseSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericSpecializationExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericSpecializationExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndGenericArgumentClause, 
          \Self.genericArgumentClause, 
          \Self.unexpectedAfterGenericArgumentClause
        ])
  }
}

// MARK: - GenericWhereClauseSyntax

/// A `where` clause that places additional constraints on generic parameters like `where Element: Hashable`.
///
/// ### Children
/// 
///  - `whereKeyword`: `'where'`
///  - `requirements`: ``GenericRequirementListSyntax``
///
/// ### Contained in
/// 
///  - ``ActorDeclSyntax``.``ActorDeclSyntax/genericWhereClause``
///  - ``AssociatedTypeDeclSyntax``.``AssociatedTypeDeclSyntax/genericWhereClause``
///  - ``ClassDeclSyntax``.``ClassDeclSyntax/genericWhereClause``
///  - ``DifferentiableAttributeArgumentsSyntax``.``DifferentiableAttributeArgumentsSyntax/genericWhereClause``
///  - ``EnumDeclSyntax``.``EnumDeclSyntax/genericWhereClause``
///  - ``ExtensionDeclSyntax``.``ExtensionDeclSyntax/genericWhereClause``
///  - ``FunctionDeclSyntax``.``FunctionDeclSyntax/genericWhereClause``
///  - ``GenericParameterClauseSyntax``.``GenericParameterClauseSyntax/genericWhereClause``
///  - ``InitializerDeclSyntax``.``InitializerDeclSyntax/genericWhereClause``
///  - ``MacroDeclSyntax``.``MacroDeclSyntax/genericWhereClause``
///  - ``ProtocolDeclSyntax``.``ProtocolDeclSyntax/genericWhereClause``
///  - ``SpecializeAttributeArgumentListSyntax``
///  - ``StructDeclSyntax``.``StructDeclSyntax/genericWhereClause``
///  - ``SubscriptDeclSyntax``.``SubscriptDeclSyntax/genericWhereClause``
///  - ``TypeAliasDeclSyntax``.``TypeAliasDeclSyntax/genericWhereClause``
public struct GenericWhereClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericWhereClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``GenericWhereClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .genericWhereClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - whereKeyword: The `where` keyword in the clause.
  ///   - requirements: The list of requirements in the clause.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWhereKeyword: UnexpectedNodesSyntax? = nil,
      whereKeyword: TokenSyntax = .keyword(.where),
      _ unexpectedBetweenWhereKeywordAndRequirements: UnexpectedNodesSyntax? = nil,
      requirements: GenericRequirementListSyntax,
      _ unexpectedAfterRequirements: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeWhereKeyword, 
            whereKeyword, 
            unexpectedBetweenWhereKeywordAndRequirements, 
            requirements, 
            unexpectedAfterRequirements
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeWhereKeyword?.raw, 
          whereKeyword.raw, 
          unexpectedBetweenWhereKeywordAndRequirements?.raw, 
          requirements.raw, 
          unexpectedAfterRequirements?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.genericWhereClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeWhereKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericWhereClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `where` keyword in the clause.
  public var whereKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericWhereClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenWhereKeywordAndRequirements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericWhereClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The list of requirements in the clause.
  public var requirements: GenericRequirementListSyntax {
    get {
      return GenericRequirementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = GenericWhereClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `requirements`
  /// collection.
  ///
  /// - param element: The new `Requirement` to add to the node's
  ///                  `requirements` collection.
  /// - returns: A copy of the receiver with the provided `Requirement`
  ///            appended to its `requirements` collection.
  @available(*, deprecated, message: "Use node.requirements.append(newElement) instead")
  public func addRequirement(_ element: GenericRequirementSyntax) -> GenericWhereClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.genericRequirementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return GenericWhereClauseSyntax(newData)
  }
  
  public var unexpectedAfterRequirements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GenericWhereClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeWhereKeyword, 
          \Self.whereKeyword, 
          \Self.unexpectedBetweenWhereKeywordAndRequirements, 
          \Self.requirements, 
          \Self.unexpectedAfterRequirements
        ])
  }
}

// MARK: - GuardStmtSyntax

/// ### Children
/// 
///  - `guardKeyword`: `'guard'`
///  - `conditions`: ``ConditionElementListSyntax``
///  - `elseKeyword`: `'else'`
///  - `body`: ``CodeBlockSyntax``
public struct GuardStmtSyntax: StmtSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .guardStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``GuardStmtSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .guardStmt)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeGuardKeyword: UnexpectedNodesSyntax? = nil,
      guardKeyword: TokenSyntax = .keyword(.guard),
      _ unexpectedBetweenGuardKeywordAndConditions: UnexpectedNodesSyntax? = nil,
      conditions: ConditionElementListSyntax,
      _ unexpectedBetweenConditionsAndElseKeyword: UnexpectedNodesSyntax? = nil,
      elseKeyword: TokenSyntax = .keyword(.else),
      _ unexpectedBetweenElseKeywordAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeGuardKeyword, 
            guardKeyword, 
            unexpectedBetweenGuardKeywordAndConditions, 
            conditions, 
            unexpectedBetweenConditionsAndElseKeyword, 
            elseKeyword, 
            unexpectedBetweenElseKeywordAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeGuardKeyword?.raw, 
          guardKeyword.raw, 
          unexpectedBetweenGuardKeywordAndConditions?.raw, 
          conditions.raw, 
          unexpectedBetweenConditionsAndElseKeyword?.raw, 
          elseKeyword.raw, 
          unexpectedBetweenElseKeywordAndBody?.raw, 
          body.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.guardStmt,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeGuardKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GuardStmtSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var guardKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = GuardStmtSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGuardKeywordAndConditions: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GuardStmtSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var conditions: ConditionElementListSyntax {
    get {
      return ConditionElementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = GuardStmtSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `conditions`
  /// collection.
  ///
  /// - param element: The new `Condition` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `Condition`
  ///            appended to its `conditions` collection.
  @available(*, deprecated, message: "Use node.conditions.append(newElement) instead")
  public func addCondition(_ element: ConditionElementSyntax) -> GuardStmtSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.conditionElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return GuardStmtSyntax(newData)
  }
  
  public var unexpectedBetweenConditionsAndElseKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GuardStmtSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elseKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = GuardStmtSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenElseKeywordAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GuardStmtSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax {
    get {
      return CodeBlockSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = GuardStmtSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = GuardStmtSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeGuardKeyword, 
          \Self.guardKeyword, 
          \Self.unexpectedBetweenGuardKeywordAndConditions, 
          \Self.conditions, 
          \Self.unexpectedBetweenConditionsAndElseKeyword, 
          \Self.elseKeyword, 
          \Self.unexpectedBetweenElseKeywordAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - IdentifierPatternSyntax

/// ### Children
/// 
///  - `identifier`: (`<identifier>` | `'self'` | `'init'`)
public struct IdentifierPatternSyntax: PatternSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .identifierPattern else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IdentifierPatternSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .identifierPattern)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIdentifier: UnexpectedNodesSyntax? = nil,
      identifier: TokenSyntax,
      _ unexpectedAfterIdentifier: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeIdentifier, identifier, unexpectedAfterIdentifier))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeIdentifier?.raw, identifier.raw, unexpectedAfterIdentifier?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.identifierPattern,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIdentifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierPatternSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var identifier: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IdentifierPatternSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterIdentifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierPatternSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeIdentifier, \Self.identifier, \Self.unexpectedAfterIdentifier])
  }
}

// MARK: - IdentifierTypeSyntax

/// ### Children
/// 
///  - `name`: (`<identifier>` | `'Self'` | `'Any'` | `'_'`)
///  - `genericArgumentClause`: ``GenericArgumentClauseSyntax``?
public struct IdentifierTypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .identifierType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IdentifierTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .identifierType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      genericArgumentClause: GenericArgumentClauseSyntax? = nil,
      _ unexpectedAfterGenericArgumentClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeName, 
            name, 
            unexpectedBetweenNameAndGenericArgumentClause, 
            genericArgumentClause, 
            unexpectedAfterGenericArgumentClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndGenericArgumentClause?.raw, 
          genericArgumentClause?.raw, 
          unexpectedAfterGenericArgumentClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.identifierType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IdentifierTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var genericArgumentClause: GenericArgumentClauseSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(GenericArgumentClauseSyntax.init)
    }
    set(value) {
      self = IdentifierTypeSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterGenericArgumentClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IdentifierTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndGenericArgumentClause, 
          \Self.genericArgumentClause, 
          \Self.unexpectedAfterGenericArgumentClause
        ])
  }
}

// MARK: - IfConfigClauseSyntax

/// ### Children
/// 
///  - `poundKeyword`: (`'#if'` | `'#elseif'` | `'#else'`)
///  - `condition`: ``ExprSyntax``?
///  - `elements`: (``CodeBlockItemListSyntax`` | ``SwitchCaseListSyntax`` | ``MemberBlockItemListSyntax`` | ``ExprSyntax`` | ``AttributeListSyntax``)?
///
/// ### Contained in
/// 
///  - ``IfConfigClauseListSyntax``
public struct IfConfigClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public enum Elements: SyntaxChildChoices, SyntaxHashable {
    case `statements`(CodeBlockItemListSyntax)
    case `switchCases`(SwitchCaseListSyntax)
    case `decls`(MemberBlockItemListSyntax)
    case `postfixExpression`(ExprSyntax)
    case `attributes`(AttributeListSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .statements(let node):
        return node._syntaxNode
      case .switchCases(let node):
        return node._syntaxNode
      case .decls(let node):
        return node._syntaxNode
      case .postfixExpression(let node):
        return node._syntaxNode
      case .attributes(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: CodeBlockItemListSyntax) {
      self = .statements(node)
    }
    
    public init(_ node: SwitchCaseListSyntax) {
      self = .switchCases(node)
    }
    
    public init(_ node: MemberBlockItemListSyntax) {
      self = .decls(node)
    }
    
    public init(_ node: some ExprSyntaxProtocol) {
      self = .postfixExpression(ExprSyntax(node))
    }
    
    public init(_ node: AttributeListSyntax) {
      self = .attributes(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(CodeBlockItemListSyntax.self) {
        self = .statements(node)
        return
      }
      if let node = node.as(SwitchCaseListSyntax.self) {
        self = .switchCases(node)
        return
      }
      if let node = node.as(MemberBlockItemListSyntax.self) {
        self = .decls(node)
        return
      }
      if let node = node.as(ExprSyntax.self) {
        self = .postfixExpression(node)
        return
      }
      if let node = node.as(AttributeListSyntax.self) {
        self = .attributes(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
            .node(CodeBlockItemListSyntax.self), 
            .node(SwitchCaseListSyntax.self), 
            .node(MemberBlockItemListSyntax.self), 
            .node(ExprSyntax.self), 
            .node(AttributeListSyntax.self)
          ])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .ifConfigClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IfConfigClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .ifConfigClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforePoundKeyword: UnexpectedNodesSyntax? = nil,
      poundKeyword: TokenSyntax,
      _ unexpectedBetweenPoundKeywordAndCondition: UnexpectedNodesSyntax? = nil,
      condition: (some ExprSyntaxProtocol)? = ExprSyntax?.none,
      _ unexpectedBetweenConditionAndElements: UnexpectedNodesSyntax? = nil,
      elements: Elements? = nil,
      _ unexpectedAfterElements: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforePoundKeyword, 
            poundKeyword, 
            unexpectedBetweenPoundKeywordAndCondition, 
            condition, 
            unexpectedBetweenConditionAndElements, 
            elements, 
            unexpectedAfterElements
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforePoundKeyword?.raw, 
          poundKeyword.raw, 
          unexpectedBetweenPoundKeywordAndCondition?.raw, 
          condition?.raw, 
          unexpectedBetweenConditionAndElements?.raw, 
          elements?.raw, 
          unexpectedAfterElements?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.ifConfigClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforePoundKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var poundKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IfConfigClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPoundKeywordAndCondition: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var condition: ExprSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(ExprSyntax.init)
    }
    set(value) {
      self = IfConfigClauseSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenConditionAndElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elements: Elements? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(Elements.init)
    }
    set(value) {
      self = IfConfigClauseSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterElements: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigClauseSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforePoundKeyword, 
          \Self.poundKeyword, 
          \Self.unexpectedBetweenPoundKeywordAndCondition, 
          \Self.condition, 
          \Self.unexpectedBetweenConditionAndElements, 
          \Self.elements, 
          \Self.unexpectedAfterElements
        ])
  }
}

// MARK: - IfConfigDeclSyntax

/// ### Children
/// 
///  - `clauses`: ``IfConfigClauseListSyntax``
///  - `poundEndif`: `'#endif'`
///
/// ### Contained in
/// 
///  - ``AttributeListSyntax``
///  - ``PostfixIfConfigExprSyntax``.``PostfixIfConfigExprSyntax/config``
///  - ``SwitchCaseListSyntax``
public struct IfConfigDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .ifConfigDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IfConfigDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .ifConfigDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeClauses: UnexpectedNodesSyntax? = nil,
      clauses: IfConfigClauseListSyntax,
      _ unexpectedBetweenClausesAndPoundEndif: UnexpectedNodesSyntax? = nil,
      poundEndif: TokenSyntax = .poundEndifToken(),
      _ unexpectedAfterPoundEndif: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeClauses, 
            clauses, 
            unexpectedBetweenClausesAndPoundEndif, 
            poundEndif, 
            unexpectedAfterPoundEndif
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeClauses?.raw, 
          clauses.raw, 
          unexpectedBetweenClausesAndPoundEndif?.raw, 
          poundEndif.raw, 
          unexpectedAfterPoundEndif?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.ifConfigDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeClauses: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var clauses: IfConfigClauseListSyntax {
    get {
      return IfConfigClauseListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `clauses`
  /// collection.
  ///
  /// - param element: The new `Clause` to add to the node's
  ///                  `clauses` collection.
  /// - returns: A copy of the receiver with the provided `Clause`
  ///            appended to its `clauses` collection.
  @available(*, deprecated, message: "Use node.clauses.append(newElement) instead")
  public func addClause(_ element: IfConfigClauseSyntax) -> IfConfigDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.ifConfigClauseList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return IfConfigDeclSyntax(newData)
  }
  
  public var unexpectedBetweenClausesAndPoundEndif: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var poundEndif: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterPoundEndif: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfConfigDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeClauses, 
          \Self.clauses, 
          \Self.unexpectedBetweenClausesAndPoundEndif, 
          \Self.poundEndif, 
          \Self.unexpectedAfterPoundEndif
        ])
  }
}

// MARK: - IfExprSyntax

/// ### Children
/// 
///  - `ifKeyword`: `'if'`
///  - `conditions`: ``ConditionElementListSyntax``
///  - `body`: ``CodeBlockSyntax``
///  - `elseKeyword`: `'else'`?
///  - `elseBody`: (``IfExprSyntax`` | ``CodeBlockSyntax``)?
///
/// ### Contained in
/// 
///  - ``IfExprSyntax``.``IfExprSyntax/elseBody``
public struct IfExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public enum ElseBody: SyntaxChildChoices, SyntaxHashable {
    case `ifExpr`(IfExprSyntax)
    case `codeBlock`(CodeBlockSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .ifExpr(let node):
        return node._syntaxNode
      case .codeBlock(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: IfExprSyntax) {
      self = .ifExpr(node)
    }
    
    public init(_ node: CodeBlockSyntax) {
      self = .codeBlock(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(IfExprSyntax.self) {
        self = .ifExpr(node)
        return
      }
      if let node = node.as(CodeBlockSyntax.self) {
        self = .codeBlock(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(IfExprSyntax.self), .node(CodeBlockSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .ifExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IfExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .ifExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIfKeyword: UnexpectedNodesSyntax? = nil,
      ifKeyword: TokenSyntax = .keyword(.if),
      _ unexpectedBetweenIfKeywordAndConditions: UnexpectedNodesSyntax? = nil,
      conditions: ConditionElementListSyntax,
      _ unexpectedBetweenConditionsAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax,
      _ unexpectedBetweenBodyAndElseKeyword: UnexpectedNodesSyntax? = nil,
      elseKeyword: TokenSyntax? = nil,
      _ unexpectedBetweenElseKeywordAndElseBody: UnexpectedNodesSyntax? = nil,
      elseBody: ElseBody? = nil,
      _ unexpectedAfterElseBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeIfKeyword, 
            ifKeyword, 
            unexpectedBetweenIfKeywordAndConditions, 
            conditions, 
            unexpectedBetweenConditionsAndBody, 
            body, 
            unexpectedBetweenBodyAndElseKeyword, 
            elseKeyword, 
            unexpectedBetweenElseKeywordAndElseBody, 
            elseBody, 
            unexpectedAfterElseBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeIfKeyword?.raw, 
          ifKeyword.raw, 
          unexpectedBetweenIfKeywordAndConditions?.raw, 
          conditions.raw, 
          unexpectedBetweenConditionsAndBody?.raw, 
          body.raw, 
          unexpectedBetweenBodyAndElseKeyword?.raw, 
          elseKeyword?.raw, 
          unexpectedBetweenElseKeywordAndElseBody?.raw, 
          elseBody?.raw, 
          unexpectedAfterElseBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.ifExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIfKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var ifKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenIfKeywordAndConditions: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var conditions: ConditionElementListSyntax {
    get {
      return ConditionElementListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `conditions`
  /// collection.
  ///
  /// - param element: The new `Condition` to add to the node's
  ///                  `conditions` collection.
  /// - returns: A copy of the receiver with the provided `Condition`
  ///            appended to its `conditions` collection.
  @available(*, deprecated, message: "Use node.conditions.append(newElement) instead")
  public func addCondition(_ element: ConditionElementSyntax) -> IfExprSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.conditionElementList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return IfExprSyntax(newData)
  }
  
  public var unexpectedBetweenConditionsAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax {
    get {
      return CodeBlockSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBodyAndElseKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elseKeyword: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenElseKeywordAndElseBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var elseBody: ElseBody? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(ElseBody.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterElseBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IfExprSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeIfKeyword, 
          \Self.ifKeyword, 
          \Self.unexpectedBetweenIfKeywordAndConditions, 
          \Self.conditions, 
          \Self.unexpectedBetweenConditionsAndBody, 
          \Self.body, 
          \Self.unexpectedBetweenBodyAndElseKeyword, 
          \Self.elseKeyword, 
          \Self.unexpectedBetweenElseKeywordAndElseBody, 
          \Self.elseBody, 
          \Self.unexpectedAfterElseBody
        ])
  }
}

// MARK: - ImplementsAttributeArgumentsSyntax

/// The arguments for the `@_implements` attribute of the form `Type, methodName(arg1Label:arg2Label:)`
///
/// ### Children
/// 
///  - `type`: ``TypeSyntax``
///  - `comma`: `','`
///  - `declName`: ``DeclReferenceExprSyntax``
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct ImplementsAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .implementsAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ImplementsAttributeArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .implementsAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - type: The type for which the method with this attribute implements a requirement.
  ///   - comma: The comma separating the type and method name
  ///   - declName: The value for this argument
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedBetweenTypeAndComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax = .commaToken(),
      _ unexpectedBetweenCommaAndDeclName: UnexpectedNodesSyntax? = nil,
      declName: DeclReferenceExprSyntax,
      _ unexpectedAfterDeclName: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeType, 
            type, 
            unexpectedBetweenTypeAndComma, 
            comma, 
            unexpectedBetweenCommaAndDeclName, 
            declName, 
            unexpectedAfterDeclName
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeType?.raw, 
          type.raw, 
          unexpectedBetweenTypeAndComma?.raw, 
          comma.raw, 
          unexpectedBetweenCommaAndDeclName?.raw, 
          declName.raw, 
          unexpectedAfterDeclName?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.implementsAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImplementsAttributeArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The type for which the method with this attribute implements a requirement.
  public var type: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ImplementsAttributeArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypeAndComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImplementsAttributeArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The comma separating the type and method name
  public var comma: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ImplementsAttributeArgumentsSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCommaAndDeclName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImplementsAttributeArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The value for this argument
  public var declName: DeclReferenceExprSyntax {
    get {
      return DeclReferenceExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ImplementsAttributeArgumentsSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDeclName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImplementsAttributeArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeType, 
          \Self.type, 
          \Self.unexpectedBetweenTypeAndComma, 
          \Self.comma, 
          \Self.unexpectedBetweenCommaAndDeclName, 
          \Self.declName, 
          \Self.unexpectedAfterDeclName
        ])
  }
}

// MARK: - ImplicitlyUnwrappedOptionalTypeSyntax

/// ### Children
/// 
///  - `wrappedType`: ``TypeSyntax``
///  - `exclamationMark`: `'!'`
public struct ImplicitlyUnwrappedOptionalTypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .implicitlyUnwrappedOptionalType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ImplicitlyUnwrappedOptionalTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .implicitlyUnwrappedOptionalType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWrappedType: UnexpectedNodesSyntax? = nil,
      wrappedType: some TypeSyntaxProtocol,
      _ unexpectedBetweenWrappedTypeAndExclamationMark: UnexpectedNodesSyntax? = nil,
      exclamationMark: TokenSyntax = .exclamationMarkToken(),
      _ unexpectedAfterExclamationMark: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeWrappedType, 
            wrappedType, 
            unexpectedBetweenWrappedTypeAndExclamationMark, 
            exclamationMark, 
            unexpectedAfterExclamationMark
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeWrappedType?.raw, 
          wrappedType.raw, 
          unexpectedBetweenWrappedTypeAndExclamationMark?.raw, 
          exclamationMark.raw, 
          unexpectedAfterExclamationMark?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.implicitlyUnwrappedOptionalType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeWrappedType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImplicitlyUnwrappedOptionalTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var wrappedType: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ImplicitlyUnwrappedOptionalTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenWrappedTypeAndExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImplicitlyUnwrappedOptionalTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var exclamationMark: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ImplicitlyUnwrappedOptionalTypeSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExclamationMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImplicitlyUnwrappedOptionalTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeWrappedType, 
          \Self.wrappedType, 
          \Self.unexpectedBetweenWrappedTypeAndExclamationMark, 
          \Self.exclamationMark, 
          \Self.unexpectedAfterExclamationMark
        ])
  }
}

// MARK: - ImportDeclSyntax

/// An `import` declaration
/// 
/// An example of an import declaration is
/// 
/// ```swift
/// import Foundation
/// ```
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `importKeyword`: `'import'`
///  - `importKindSpecifier`: (`'typealias'` | `'struct'` | `'class'` | `'enum'` | `'protocol'` | `'var'` | `'let'` | `'func'` | `'inout'`)?
///  - `path`: ``ImportPathComponentListSyntax``
public struct ImportDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .importDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ImportDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .importDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes attached to the import declaration, for example `@testable`.
  ///   - modifiers: Modifiers attached to the import declaration. Currently, no modifiers are supported by Swift.
  ///   - importKeyword: The `import` keyword for this declaration.
  ///   - importKindSpecifier: The kind of declaration being imported. 
  ///   - path: The path to the module, submodule or symbol being imported.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndImportKeyword: UnexpectedNodesSyntax? = nil,
      importKeyword: TokenSyntax = .keyword(.import),
      _ unexpectedBetweenImportKeywordAndImportKindSpecifier: UnexpectedNodesSyntax? = nil,
      importKindSpecifier: TokenSyntax? = nil,
      _ unexpectedBetweenImportKindSpecifierAndPath: UnexpectedNodesSyntax? = nil,
      path: ImportPathComponentListSyntax,
      _ unexpectedAfterPath: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndImportKeyword, 
            importKeyword, 
            unexpectedBetweenImportKeywordAndImportKindSpecifier, 
            importKindSpecifier, 
            unexpectedBetweenImportKindSpecifierAndPath, 
            path, 
            unexpectedAfterPath
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndImportKeyword?.raw, 
          importKeyword.raw, 
          unexpectedBetweenImportKeywordAndImportKindSpecifier?.raw, 
          importKindSpecifier?.raw, 
          unexpectedBetweenImportKindSpecifierAndPath?.raw, 
          path.raw, 
          unexpectedAfterPath?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.importDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes attached to the import declaration, for example `@testable`.
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ImportDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers attached to the import declaration. Currently, no modifiers are supported by Swift.
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ImportDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndImportKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `import` keyword for this declaration.
  public var importKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenImportKeywordAndImportKindSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The kind of declaration being imported. 
  /// 
  /// A struct can be imported from a specific module.
  public var importKindSpecifier: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenImportKindSpecifierAndPath: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The path to the module, submodule or symbol being imported.
  public var path: ImportPathComponentListSyntax {
    get {
      return ImportPathComponentListSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `path`
  /// collection.
  ///
  /// - param element: The new `PathComponent` to add to the node's
  ///                  `path` collection.
  /// - returns: A copy of the receiver with the provided `PathComponent`
  ///            appended to its `path` collection.
  @available(*, deprecated, message: "Use node.path.append(newElement) instead")
  public func addPathComponent(_ element: ImportPathComponentSyntax) -> ImportDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[9] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.importPathComponentList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 9, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return ImportDeclSyntax(newData)
  }
  
  public var unexpectedAfterPath: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndImportKeyword, 
          \Self.importKeyword, 
          \Self.unexpectedBetweenImportKeywordAndImportKindSpecifier, 
          \Self.importKindSpecifier, 
          \Self.unexpectedBetweenImportKindSpecifierAndPath, 
          \Self.path, 
          \Self.unexpectedAfterPath
        ])
  }
}

// MARK: - ImportPathComponentSyntax

/// ### Children
/// 
///  - `name`: (`<identifier>` | `<binaryOperator>` | `<prefixOperator>` | `<postfixOperator>`)
///  - `trailingPeriod`: `'.'`?
///
/// ### Contained in
/// 
///  - ``ImportPathComponentListSyntax``
public struct ImportPathComponentSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .importPathComponent else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``ImportPathComponentSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .importPathComponent)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndTrailingPeriod: UnexpectedNodesSyntax? = nil,
      trailingPeriod: TokenSyntax? = nil,
      _ unexpectedAfterTrailingPeriod: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeName, 
            name, 
            unexpectedBetweenNameAndTrailingPeriod, 
            trailingPeriod, 
            unexpectedAfterTrailingPeriod
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndTrailingPeriod?.raw, 
          trailingPeriod?.raw, 
          unexpectedAfterTrailingPeriod?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.importPathComponent,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportPathComponentSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = ImportPathComponentSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndTrailingPeriod: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportPathComponentSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingPeriod: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = ImportPathComponentSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingPeriod: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = ImportPathComponentSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndTrailingPeriod, 
          \Self.trailingPeriod, 
          \Self.unexpectedAfterTrailingPeriod
        ])
  }
}

// MARK: - InOutExprSyntax

/// ### Children
/// 
///  - `ampersand`: `'&'`
///  - `expression`: ``ExprSyntax``
public struct InOutExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .inOutExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``InOutExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .inOutExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAmpersand: UnexpectedNodesSyntax? = nil,
      ampersand: TokenSyntax = .prefixAmpersandToken(),
      _ unexpectedBetweenAmpersandAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAmpersand, 
            ampersand, 
            unexpectedBetweenAmpersandAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAmpersand?.raw, 
          ampersand.raw, 
          unexpectedBetweenAmpersandAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.inOutExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAmpersand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var ampersand: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAmpersandAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InOutExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAmpersand, 
          \Self.ampersand, 
          \Self.unexpectedBetweenAmpersandAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - InfixOperatorExprSyntax

/// ### Children
/// 
///  - `leftOperand`: ``ExprSyntax``
///  - `operator`: ``ExprSyntax``
///  - `rightOperand`: ``ExprSyntax``
public struct InfixOperatorExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .infixOperatorExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``InfixOperatorExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .infixOperatorExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftOperand: UnexpectedNodesSyntax? = nil,
      leftOperand: some ExprSyntaxProtocol,
      _ unexpectedBetweenLeftOperandAndOperator: UnexpectedNodesSyntax? = nil,
      operator: some ExprSyntaxProtocol,
      _ unexpectedBetweenOperatorAndRightOperand: UnexpectedNodesSyntax? = nil,
      rightOperand: some ExprSyntaxProtocol,
      _ unexpectedAfterRightOperand: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftOperand, 
            leftOperand, 
            unexpectedBetweenLeftOperandAndOperator, 
            `operator`, 
            unexpectedBetweenOperatorAndRightOperand, 
            rightOperand, 
            unexpectedAfterRightOperand
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftOperand?.raw, 
          leftOperand.raw, 
          unexpectedBetweenLeftOperandAndOperator?.raw, 
          `operator`.raw, 
          unexpectedBetweenOperatorAndRightOperand?.raw, 
          rightOperand.raw, 
          unexpectedAfterRightOperand?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.infixOperatorExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftOperand: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftOperandAndOperator: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var `operator`: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOperatorAndRightOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightOperand: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightOperand: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InfixOperatorExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftOperand, 
          \Self.leftOperand, 
          \Self.unexpectedBetweenLeftOperandAndOperator, 
          \Self.operator, 
          \Self.unexpectedBetweenOperatorAndRightOperand, 
          \Self.rightOperand, 
          \Self.unexpectedAfterRightOperand
        ])
  }
}

// MARK: - InheritanceClauseSyntax

/// ### Children
/// 
///  - `colon`: `':'`
///  - `inheritedTypes`: ``InheritedTypeListSyntax``
///
/// ### Contained in
/// 
///  - ``ActorDeclSyntax``.``ActorDeclSyntax/inheritanceClause``
///  - ``AssociatedTypeDeclSyntax``.``AssociatedTypeDeclSyntax/inheritanceClause``
///  - ``ClassDeclSyntax``.``ClassDeclSyntax/inheritanceClause``
///  - ``EnumDeclSyntax``.``EnumDeclSyntax/inheritanceClause``
///  - ``ExtensionDeclSyntax``.``ExtensionDeclSyntax/inheritanceClause``
///  - ``ProtocolDeclSyntax``.``ProtocolDeclSyntax/inheritanceClause``
///  - ``StructDeclSyntax``.``StructDeclSyntax/inheritanceClause``
public struct InheritanceClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .inheritanceClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``InheritanceClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .inheritanceClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndInheritedTypes: UnexpectedNodesSyntax? = nil,
      inheritedTypes: InheritedTypeListSyntax,
      _ unexpectedAfterInheritedTypes: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeColon, 
            colon, 
            unexpectedBetweenColonAndInheritedTypes, 
            inheritedTypes, 
            unexpectedAfterInheritedTypes
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndInheritedTypes?.raw, 
          inheritedTypes.raw, 
          unexpectedAfterInheritedTypes?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.inheritanceClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InheritanceClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InheritanceClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndInheritedTypes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InheritanceClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var inheritedTypes: InheritedTypeListSyntax {
    get {
      return InheritedTypeListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = InheritanceClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `inheritedTypes`
  /// collection.
  ///
  /// - param element: The new `InheritedType` to add to the node's
  ///                  `inheritedTypes` collection.
  /// - returns: A copy of the receiver with the provided `InheritedType`
  ///            appended to its `inheritedTypes` collection.
  @available(*, deprecated, message: "Use node.inheritedTypes.append(newElement) instead")
  public func addInheritedType(_ element: InheritedTypeSyntax) -> InheritanceClauseSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.inheritedTypeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return InheritanceClauseSyntax(newData)
  }
  
  public var unexpectedAfterInheritedTypes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InheritanceClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndInheritedTypes, 
          \Self.inheritedTypes, 
          \Self.unexpectedAfterInheritedTypes
        ])
  }
}

// MARK: - InheritedTypeSyntax

/// ### Children
/// 
///  - `type`: ``TypeSyntax``
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``InheritedTypeListSyntax``
public struct InheritedTypeSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .inheritedType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``InheritedTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .inheritedType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedBetweenTypeAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeType, 
            type, 
            unexpectedBetweenTypeAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeType?.raw, 
          type.raw, 
          unexpectedBetweenTypeAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.inheritedType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InheritedTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var type: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InheritedTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenTypeAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InheritedTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = InheritedTypeSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InheritedTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeType, 
          \Self.type, 
          \Self.unexpectedBetweenTypeAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - InitializerClauseSyntax

/// ### Children
/// 
///  - `equal`: `'='`
///  - `value`: ``ExprSyntax``
///
/// ### Contained in
/// 
///  - ``EnumCaseElementSyntax``.``EnumCaseElementSyntax/rawValue``
///  - ``EnumCaseParameterSyntax``.``EnumCaseParameterSyntax/defaultValue``
///  - ``FunctionParameterSyntax``.``FunctionParameterSyntax/defaultValue``
///  - ``MacroDeclSyntax``.``MacroDeclSyntax/definition``
///  - ``MatchingPatternConditionSyntax``.``MatchingPatternConditionSyntax/initializer``
///  - ``OptionalBindingConditionSyntax``.``OptionalBindingConditionSyntax/initializer``
///  - ``PatternBindingSyntax``.``PatternBindingSyntax/initializer``
public struct InitializerClauseSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .initializerClause else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``InitializerClauseSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .initializerClause)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeEqual: UnexpectedNodesSyntax? = nil,
      equal: TokenSyntax = .equalToken(),
      _ unexpectedBetweenEqualAndValue: UnexpectedNodesSyntax? = nil,
      value: some ExprSyntaxProtocol,
      _ unexpectedAfterValue: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeEqual, 
            equal, 
            unexpectedBetweenEqualAndValue, 
            value, 
            unexpectedAfterValue
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeEqual?.raw, 
          equal.raw, 
          unexpectedBetweenEqualAndValue?.raw, 
          value.raw, 
          unexpectedAfterValue?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.initializerClause,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeEqual: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerClauseSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var equal: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InitializerClauseSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEqualAndValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerClauseSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var value: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = InitializerClauseSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerClauseSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeEqual, 
          \Self.equal, 
          \Self.unexpectedBetweenEqualAndValue, 
          \Self.value, 
          \Self.unexpectedAfterValue
        ])
  }
}

// MARK: - InitializerDeclSyntax

/// An `init` declaration
/// 
/// An example of an initializer is
/// 
/// ```swift
/// init(someParameter: Int) {
/// }
/// ```
/// 
/// The body is optional because this node also represents initializer requirements inside protocols.
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `initKeyword`: `'init'`
///  - `optionalMark`: (`'?'` | `'!'`)?
///  - `genericParameterClause`: ``GenericParameterClauseSyntax``?
///  - `signature`: ``FunctionSignatureSyntax``
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///  - `body`: ``CodeBlockSyntax``?
public struct InitializerDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .initializerDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``InitializerDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .initializerDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes that are attached to the initializer.
  ///   - modifiers: Modifiers attached to the initializer
  ///   - initKeyword: The init keyword
  ///   - optionalMark: If the initializer is failable, a question mark to indicate that.
  ///   - genericParameterClause: Generic parameters of the initializer.
  ///   - signature: The arguments of the initializer. While the function signature allows specifying a return clause, doing so is not semantically valid.
  ///   - genericWhereClause: If the initializer had generic parameters, a where clause that can restrict those
  ///   - body: The initializer’s body. Missing if the initializer is a requirement of a protocol declaration.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndInitKeyword: UnexpectedNodesSyntax? = nil,
      initKeyword: TokenSyntax = .keyword(.`init`),
      _ unexpectedBetweenInitKeywordAndOptionalMark: UnexpectedNodesSyntax? = nil,
      optionalMark: TokenSyntax? = nil,
      _ unexpectedBetweenOptionalMarkAndGenericParameterClause: UnexpectedNodesSyntax? = nil,
      genericParameterClause: GenericParameterClauseSyntax? = nil,
      _ unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? = nil,
      signature: FunctionSignatureSyntax,
      _ unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax? = nil,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndInitKeyword, 
            initKeyword, 
            unexpectedBetweenInitKeywordAndOptionalMark, 
            optionalMark, 
            unexpectedBetweenOptionalMarkAndGenericParameterClause, 
            genericParameterClause, 
            unexpectedBetweenGenericParameterClauseAndSignature, 
            signature, 
            unexpectedBetweenSignatureAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedBetweenGenericWhereClauseAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndInitKeyword?.raw, 
          initKeyword.raw, 
          unexpectedBetweenInitKeywordAndOptionalMark?.raw, 
          optionalMark?.raw, 
          unexpectedBetweenOptionalMarkAndGenericParameterClause?.raw, 
          genericParameterClause?.raw, 
          unexpectedBetweenGenericParameterClauseAndSignature?.raw, 
          signature.raw, 
          unexpectedBetweenSignatureAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedBetweenGenericWhereClauseAndBody?.raw, 
          body?.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.initializerDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes that are attached to the initializer.
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> InitializerDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return InitializerDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers attached to the initializer
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> InitializerDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return InitializerDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndInitKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The init keyword
  public var initKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenInitKeywordAndOptionalMark: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the initializer is failable, a question mark to indicate that.
  public var optionalMark: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOptionalMarkAndGenericParameterClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Generic parameters of the initializer.
  public var genericParameterClause: GenericParameterClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericParameterClauseSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The arguments of the initializer. While the function signature allows specifying a return clause, doing so is not semantically valid.
  public var signature: FunctionSignatureSyntax {
    get {
      return FunctionSignatureSyntax(data.child(at: 11, parent: Syntax(self))!)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 11, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// If the initializer had generic parameters, a where clause that can restrict those
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The initializer’s body. Missing if the initializer is a requirement of a protocol declaration.
  public var body: CodeBlockSyntax? {
    get {
      return data.child(at: 15, parent: Syntax(self)).map(CodeBlockSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 15, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 16, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = InitializerDeclSyntax(data.replacingChild(at: 16, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndInitKeyword, 
          \Self.initKeyword, 
          \Self.unexpectedBetweenInitKeywordAndOptionalMark, 
          \Self.optionalMark, 
          \Self.unexpectedBetweenOptionalMarkAndGenericParameterClause, 
          \Self.genericParameterClause, 
          \Self.unexpectedBetweenGenericParameterClauseAndSignature, 
          \Self.signature, 
          \Self.unexpectedBetweenSignatureAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedBetweenGenericWhereClauseAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - IntegerLiteralExprSyntax

/// ### Children
/// 
///  - `literal`: `<integerLiteral>`
public struct IntegerLiteralExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .integerLiteralExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IntegerLiteralExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .integerLiteralExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLiteral: UnexpectedNodesSyntax? = nil,
      literal: TokenSyntax,
      _ unexpectedAfterLiteral: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeLiteral, literal, unexpectedAfterLiteral))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeLiteral?.raw, literal.raw, unexpectedAfterLiteral?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.integerLiteralExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLiteral: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IntegerLiteralExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var literal: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IntegerLiteralExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterLiteral: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IntegerLiteralExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeLiteral, \Self.literal, \Self.unexpectedAfterLiteral])
  }
}

// MARK: - IsExprSyntax

/// Checks if an expression is of a given type.
/// 
/// An example of an `is` expression is
/// 
/// ```swift
/// value is Double
/// ```
/// 
/// This node is only generated after operators are folded using the `SwiftOperators` library. Beforehand, the parser does not know the precedences of operators and thus represents `is` by an `UnresolvedIsExpr`.
///
/// ### Children
/// 
///  - `expression`: ``ExprSyntax``
///  - `isKeyword`: `'is'`
///  - `type`: ``TypeSyntax``
public struct IsExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .isExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IsExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .isExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - expression: The expression which will be checked to determine whether it can be cast to a specific type.
  ///   - isKeyword: The `is` keyword for this expression.
  ///   - type: The type against which the expression will be checked to see if the expression can be cast to it.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedBetweenExpressionAndIsKeyword: UnexpectedNodesSyntax? = nil,
      isKeyword: TokenSyntax = .keyword(.is),
      _ unexpectedBetweenIsKeywordAndType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedAfterType: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeExpression, 
            expression, 
            unexpectedBetweenExpressionAndIsKeyword, 
            isKeyword, 
            unexpectedBetweenIsKeywordAndType, 
            type, 
            unexpectedAfterType
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeExpression?.raw, 
          expression.raw, 
          unexpectedBetweenExpressionAndIsKeyword?.raw, 
          isKeyword.raw, 
          unexpectedBetweenIsKeywordAndType?.raw, 
          type.raw, 
          unexpectedAfterType?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.isExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The expression which will be checked to determine whether it can be cast to a specific type.
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenExpressionAndIsKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The `is` keyword for this expression.
  public var isKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenIsKeywordAndType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The type against which the expression will be checked to see if the expression can be cast to it.
  public var type: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeExpression, 
          \Self.expression, 
          \Self.unexpectedBetweenExpressionAndIsKeyword, 
          \Self.isKeyword, 
          \Self.unexpectedBetweenIsKeywordAndType, 
          \Self.type, 
          \Self.unexpectedAfterType
        ])
  }
}

// MARK: - IsTypePatternSyntax

/// ### Children
/// 
///  - `isKeyword`: `'is'`
///  - `type`: ``TypeSyntax``
public struct IsTypePatternSyntax: PatternSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .isTypePattern else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``IsTypePatternSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .isTypePattern)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeIsKeyword: UnexpectedNodesSyntax? = nil,
      isKeyword: TokenSyntax = .keyword(.is),
      _ unexpectedBetweenIsKeywordAndType: UnexpectedNodesSyntax? = nil,
      type: some TypeSyntaxProtocol,
      _ unexpectedAfterType: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeIsKeyword, 
            isKeyword, 
            unexpectedBetweenIsKeywordAndType, 
            type, 
            unexpectedAfterType
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeIsKeyword?.raw, 
          isKeyword.raw, 
          unexpectedBetweenIsKeywordAndType?.raw, 
          type.raw, 
          unexpectedAfterType?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.isTypePattern,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeIsKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsTypePatternSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var isKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = IsTypePatternSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenIsKeywordAndType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsTypePatternSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var type: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = IsTypePatternSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterType: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = IsTypePatternSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeIsKeyword, 
          \Self.isKeyword, 
          \Self.unexpectedBetweenIsKeywordAndType, 
          \Self.type, 
          \Self.unexpectedAfterType
        ])
  }
}
