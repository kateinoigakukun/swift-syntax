//// Automatically generated by generate-swift-syntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// MARK: - DeclModifierDetailSyntax

/// ### Children
/// 
///  - `leftParen`: `'('`
///  - `detail`: `<identifier>`
///  - `rightParen`: `')'`
///
/// ### Contained in
/// 
///  - ``DeclModifierSyntax``.``DeclModifierSyntax/detail``
public struct DeclModifierDetailSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .declModifierDetail else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DeclModifierDetailSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .declModifierDetail)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndDetail: UnexpectedNodesSyntax? = nil,
      detail: TokenSyntax,
      _ unexpectedBetweenDetailAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndDetail, 
            detail, 
            unexpectedBetweenDetailAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndDetail?.raw, 
          detail.raw, 
          unexpectedBetweenDetailAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.declModifierDetail,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclModifierDetailSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclModifierDetailSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndDetail: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclModifierDetailSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var detail: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclModifierDetailSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDetailAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclModifierDetailSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclModifierDetailSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclModifierDetailSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndDetail, 
          \Self.detail, 
          \Self.unexpectedBetweenDetailAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - DeclModifierSyntax

/// ### Children
/// 
///  - `name`: (`'__consuming'` | `'__setter_access'` | `'_const'` | `'_local'` | `'actor'` | `'async'` | `'borrowing'` | `'class'` | `'consuming'` | `'convenience'` | `'distributed'` | `'dynamic'` | `'fileprivate'` | `'final'` | `'indirect'` | `'infix'` | `'internal'` | `'isolated'` | `'lazy'` | `'mutating'` | `'nonisolated'` | `'nonmutating'` | `'open'` | `'optional'` | `'override'` | `'package'` | `'postfix'` | `'prefix'` | `'private'` | `'public'` | `'reasync'` | `'required'` | `'static'` | `'unowned'` | `'weak'`)
///  - `detail`: ``DeclModifierDetailSyntax``?
///
/// ### Contained in
/// 
///  - ``AccessorDeclSyntax``.``AccessorDeclSyntax/modifier``
///  - ``DeclModifierListSyntax``
public struct DeclModifierSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .declModifier else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DeclModifierSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .declModifier)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndDetail: UnexpectedNodesSyntax? = nil,
      detail: DeclModifierDetailSyntax? = nil,
      _ unexpectedAfterDetail: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeName, 
            name, 
            unexpectedBetweenNameAndDetail, 
            detail, 
            unexpectedAfterDetail
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndDetail?.raw, 
          detail?.raw, 
          unexpectedAfterDetail?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.declModifier,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclModifierSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclModifierSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndDetail: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclModifierSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var detail: DeclModifierDetailSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclModifierDetailSyntax.init)
    }
    set(value) {
      self = DeclModifierSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDetail: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclModifierSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndDetail, 
          \Self.detail, 
          \Self.unexpectedAfterDetail
        ])
  }
}

// MARK: - DeclNameArgumentSyntax

/// ### Children
/// 
///  - `name`: ``TokenSyntax``
///  - `colon`: `':'`
///
/// ### Contained in
/// 
///  - ``DeclNameArgumentListSyntax``
public struct DeclNameArgumentSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .declNameArgument else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DeclNameArgumentSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .declNameArgument)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedBetweenNameAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedAfterColon: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeName, 
            name, 
            unexpectedBetweenNameAndColon, 
            colon, 
            unexpectedAfterColon
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeName?.raw, 
          name.raw, 
          unexpectedBetweenNameAndColon?.raw, 
          colon.raw, 
          unexpectedAfterColon?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.declNameArgument,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclNameArgumentSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclNameArgumentSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenNameAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclNameArgumentSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclNameArgumentSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclNameArgumentSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeName, 
          \Self.name, 
          \Self.unexpectedBetweenNameAndColon, 
          \Self.colon, 
          \Self.unexpectedAfterColon
        ])
  }
}

// MARK: - DeclNameArgumentsSyntax

/// ### Children
/// 
///  - `leftParen`: `'('`
///  - `arguments`: ``DeclNameArgumentListSyntax``
///  - `rightParen`: `')'`
///
/// ### Contained in
/// 
///  - ``DeclReferenceExprSyntax``.``DeclReferenceExprSyntax/argumentNames``
public struct DeclNameArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .declNameArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DeclNameArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .declNameArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: DeclNameArgumentListSyntax,
      _ unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndArguments?.raw, 
          arguments.raw, 
          unexpectedBetweenArgumentsAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.declNameArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclNameArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclNameArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclNameArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arguments: DeclNameArgumentListSyntax {
    get {
      return DeclNameArgumentListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclNameArgumentsSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `arguments`
  /// collection.
  ///
  /// - param element: The new `Argument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `arguments` collection.
  @available(*, deprecated, message: "Use node.arguments.append(newElement) instead")
  public func addArgument(_ element: DeclNameArgumentSyntax) -> DeclNameArgumentsSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declNameArgumentList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return DeclNameArgumentsSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclNameArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclNameArgumentsSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclNameArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - DeclReferenceExprSyntax

/// ### Children
/// 
///  - `baseName`: (`<identifier>` | `'self'` | `'Self'` | `'init'` | `<dollarIdentifier>` | `<binaryOperator>` | `<integerLiteral>`)
///  - `argumentNames`: ``DeclNameArgumentsSyntax``?
///
/// ### Contained in
/// 
///  - ``DynamicReplacementAttributeArgumentsSyntax``.``DynamicReplacementAttributeArgumentsSyntax/declName``
///  - ``ImplementsAttributeArgumentsSyntax``.``ImplementsAttributeArgumentsSyntax/declName``
///  - ``KeyPathPropertyComponentSyntax``.``KeyPathPropertyComponentSyntax/declName``
///  - ``MemberAccessExprSyntax``.``MemberAccessExprSyntax/declName``
///  - ``SpecializeTargetFunctionArgumentSyntax``.``SpecializeTargetFunctionArgumentSyntax/declName``
public struct DeclReferenceExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .declReferenceExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DeclReferenceExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .declReferenceExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeBaseName: UnexpectedNodesSyntax? = nil,
      baseName: TokenSyntax,
      _ unexpectedBetweenBaseNameAndArgumentNames: UnexpectedNodesSyntax? = nil,
      argumentNames: DeclNameArgumentsSyntax? = nil,
      _ unexpectedAfterArgumentNames: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeBaseName, 
            baseName, 
            unexpectedBetweenBaseNameAndArgumentNames, 
            argumentNames, 
            unexpectedAfterArgumentNames
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeBaseName?.raw, 
          baseName.raw, 
          unexpectedBetweenBaseNameAndArgumentNames?.raw, 
          argumentNames?.raw, 
          unexpectedAfterArgumentNames?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.declReferenceExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeBaseName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclReferenceExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var baseName: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DeclReferenceExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBaseNameAndArgumentNames: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclReferenceExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var argumentNames: DeclNameArgumentsSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(DeclNameArgumentsSyntax.init)
    }
    set(value) {
      self = DeclReferenceExprSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterArgumentNames: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeclReferenceExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeBaseName, 
          \Self.baseName, 
          \Self.unexpectedBetweenBaseNameAndArgumentNames, 
          \Self.argumentNames, 
          \Self.unexpectedAfterArgumentNames
        ])
  }
}

// MARK: - DeferStmtSyntax

/// ### Children
/// 
///  - `deferKeyword`: `'defer'`
///  - `body`: ``CodeBlockSyntax``
public struct DeferStmtSyntax: StmtSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .deferStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DeferStmtSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .deferStmt)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeDeferKeyword: UnexpectedNodesSyntax? = nil,
      deferKeyword: TokenSyntax = .keyword(.defer),
      _ unexpectedBetweenDeferKeywordAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeDeferKeyword, 
            deferKeyword, 
            unexpectedBetweenDeferKeywordAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeDeferKeyword?.raw, 
          deferKeyword.raw, 
          unexpectedBetweenDeferKeywordAndBody?.raw, 
          body.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.deferStmt,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeDeferKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeferStmtSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var deferKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DeferStmtSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDeferKeywordAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeferStmtSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax {
    get {
      return CodeBlockSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DeferStmtSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeferStmtSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeDeferKeyword, 
          \Self.deferKeyword, 
          \Self.unexpectedBetweenDeferKeywordAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - DeinitializerDeclSyntax

/// A `deint` declaration
/// 
/// An example of a deinitializer is
/// 
/// ```swift
/// deinit {
/// }
/// ```
///
/// ### Children
/// 
///  - `attributes`: ``AttributeListSyntax``
///  - `modifiers`: ``DeclModifierListSyntax``
///  - `deinitKeyword`: `'deinit'`
///  - `effectSpecifiers`: ``DeinitializerEffectSpecifiersSyntax``?
///  - `body`: ``CodeBlockSyntax``?
public struct DeinitializerDeclSyntax: DeclSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .deinitializerDecl else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DeinitializerDeclSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .deinitializerDecl)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - attributes: Attributes that are attached to the deinitializer.
  ///   - modifiers: Modifiers that are attached to the deinitializer.
  ///   - deinitKeyword: The deinit keyword.
  ///   - body: The deinitializer's body.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAttributes: UnexpectedNodesSyntax? = nil,
      attributes: AttributeListSyntax = [],
      _ unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? = nil,
      modifiers: DeclModifierListSyntax = [],
      _ unexpectedBetweenModifiersAndDeinitKeyword: UnexpectedNodesSyntax? = nil,
      deinitKeyword: TokenSyntax = .keyword(.deinit),
      _ unexpectedBetweenDeinitKeywordAndEffectSpecifiers: UnexpectedNodesSyntax? = nil,
      effectSpecifiers: DeinitializerEffectSpecifiersSyntax? = nil,
      _ unexpectedBetweenEffectSpecifiersAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax? = nil,
      _ unexpectedAfterBody: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeAttributes, 
            attributes, 
            unexpectedBetweenAttributesAndModifiers, 
            modifiers, 
            unexpectedBetweenModifiersAndDeinitKeyword, 
            deinitKeyword, 
            unexpectedBetweenDeinitKeywordAndEffectSpecifiers, 
            effectSpecifiers, 
            unexpectedBetweenEffectSpecifiersAndBody, 
            body, 
            unexpectedAfterBody
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeAttributes?.raw, 
          attributes.raw, 
          unexpectedBetweenAttributesAndModifiers?.raw, 
          modifiers.raw, 
          unexpectedBetweenModifiersAndDeinitKeyword?.raw, 
          deinitKeyword.raw, 
          unexpectedBetweenDeinitKeywordAndEffectSpecifiers?.raw, 
          effectSpecifiers?.raw, 
          unexpectedBetweenEffectSpecifiersAndBody?.raw, 
          body?.raw, 
          unexpectedAfterBody?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.deinitializerDecl,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAttributes: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Attributes that are attached to the deinitializer.
  public var attributes: AttributeListSyntax {
    get {
      return AttributeListSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `attributes`
  /// collection.
  ///
  /// - param element: The new `Attribute` to add to the node's
  ///                  `attributes` collection.
  /// - returns: A copy of the receiver with the provided `Attribute`
  ///            appended to its `attributes` collection.
  @available(*, deprecated, message: "Use node.attributes.append(newElement) instead")
  public func addAttribute(_ element: Syntax) -> DeinitializerDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[1] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.attributeList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 1, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return DeinitializerDeclSyntax(newData)
  }
  
  public var unexpectedBetweenAttributesAndModifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// Modifiers that are attached to the deinitializer.
  public var modifiers: DeclModifierListSyntax {
    get {
      return DeclModifierListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `modifiers`
  /// collection.
  ///
  /// - param element: The new `Modifier` to add to the node's
  ///                  `modifiers` collection.
  /// - returns: A copy of the receiver with the provided `Modifier`
  ///            appended to its `modifiers` collection.
  @available(*, deprecated, message: "Use node.modifiers.append(newElement) instead")
  public func addModifier(_ element: DeclModifierSyntax) -> DeinitializerDeclSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.declModifierList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return DeinitializerDeclSyntax(newData)
  }
  
  public var unexpectedBetweenModifiersAndDeinitKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The deinit keyword.
  public var deinitKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDeinitKeywordAndEffectSpecifiers: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var effectSpecifiers: DeinitializerEffectSpecifiersSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(DeinitializerEffectSpecifiersSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenEffectSpecifiersAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The deinitializer's body.
  public var body: CodeBlockSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(CodeBlockSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerDeclSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeAttributes, 
          \Self.attributes, 
          \Self.unexpectedBetweenAttributesAndModifiers, 
          \Self.modifiers, 
          \Self.unexpectedBetweenModifiersAndDeinitKeyword, 
          \Self.deinitKeyword, 
          \Self.unexpectedBetweenDeinitKeywordAndEffectSpecifiers, 
          \Self.effectSpecifiers, 
          \Self.unexpectedBetweenEffectSpecifiersAndBody, 
          \Self.body, 
          \Self.unexpectedAfterBody
        ])
  }
}

// MARK: - DeinitializerEffectSpecifiersSyntax

/// ### Children
/// 
///  - `asyncSpecifier`: `'async'`?
///
/// ### Contained in
/// 
///  - ``DeinitializerDeclSyntax``.``DeinitializerDeclSyntax/effectSpecifiers``
public struct DeinitializerEffectSpecifiersSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .deinitializerEffectSpecifiers else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DeinitializerEffectSpecifiersSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .deinitializerEffectSpecifiers)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeAsyncSpecifier: UnexpectedNodesSyntax? = nil,
      asyncSpecifier: TokenSyntax? = nil,
      _ unexpectedAfterAsyncSpecifier: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeAsyncSpecifier, asyncSpecifier, unexpectedAfterAsyncSpecifier))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeAsyncSpecifier?.raw, asyncSpecifier?.raw, unexpectedAfterAsyncSpecifier?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.deinitializerEffectSpecifiers,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeAsyncSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerEffectSpecifiersSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var asyncSpecifier: TokenSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DeinitializerEffectSpecifiersSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterAsyncSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DeinitializerEffectSpecifiersSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeAsyncSpecifier, \Self.asyncSpecifier, \Self.unexpectedAfterAsyncSpecifier])
  }
}

// MARK: - DerivativeAttributeArgumentsSyntax

/// The arguments for the '@derivative(of:)' and '@transpose(of:)' attributes: the 'of:' label, the original declaration name, and an optional differentiability parameter list.
///
/// ### Children
/// 
///  - `ofLabel`: `'of'`
///  - `colon`: `':'`
///  - `originalDeclName`: ``ExprSyntax``
///  - `period`: `'.'`?
///  - `accessorSpecifier`: (`'get'` | `'set'`)?
///  - `comma`: `','`?
///  - `arguments`: ``DifferentiabilityWithRespectToArgumentSyntax``?
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct DerivativeAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .derivativeAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DerivativeAttributeArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .derivativeAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - ofLabel: The "of" label.
  ///   - colon: The colon separating the "of" label and the original declaration name.
  ///   - originalDeclName: The referenced original declaration name.
  ///   - period: The period separating the original declaration name and the accessor name.
  ///   - accessorSpecifier: The accessor name.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeOfLabel: UnexpectedNodesSyntax? = nil,
      ofLabel: TokenSyntax = .keyword(.of),
      _ unexpectedBetweenOfLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndOriginalDeclName: UnexpectedNodesSyntax? = nil,
      originalDeclName: some ExprSyntaxProtocol,
      _ unexpectedBetweenOriginalDeclNameAndPeriod: UnexpectedNodesSyntax? = nil,
      period: TokenSyntax? = nil,
      _ unexpectedBetweenPeriodAndAccessorSpecifier: UnexpectedNodesSyntax? = nil,
      accessorSpecifier: TokenSyntax? = nil,
      _ unexpectedBetweenAccessorSpecifierAndComma: UnexpectedNodesSyntax? = nil,
      comma: TokenSyntax? = nil,
      _ unexpectedBetweenCommaAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: DifferentiabilityWithRespectToArgumentSyntax? = nil,
      _ unexpectedAfterArguments: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeOfLabel, 
            ofLabel, 
            unexpectedBetweenOfLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndOriginalDeclName, 
            originalDeclName, 
            unexpectedBetweenOriginalDeclNameAndPeriod, 
            period, 
            unexpectedBetweenPeriodAndAccessorSpecifier, 
            accessorSpecifier, 
            unexpectedBetweenAccessorSpecifierAndComma, 
            comma, 
            unexpectedBetweenCommaAndArguments, 
            arguments, 
            unexpectedAfterArguments
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeOfLabel?.raw, 
          ofLabel.raw, 
          unexpectedBetweenOfLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndOriginalDeclName?.raw, 
          originalDeclName.raw, 
          unexpectedBetweenOriginalDeclNameAndPeriod?.raw, 
          period?.raw, 
          unexpectedBetweenPeriodAndAccessorSpecifier?.raw, 
          accessorSpecifier?.raw, 
          unexpectedBetweenAccessorSpecifierAndComma?.raw, 
          comma?.raw, 
          unexpectedBetweenCommaAndArguments?.raw, 
          arguments?.raw, 
          unexpectedAfterArguments?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.derivativeAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeOfLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The "of" label.
  public var ofLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOfLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The colon separating the "of" label and the original declaration name.
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndOriginalDeclName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The referenced original declaration name.
  public var originalDeclName: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenOriginalDeclNameAndPeriod: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The period separating the original declaration name and the accessor name.
  public var period: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenPeriodAndAccessorSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The accessor name.
  public var accessorSpecifier: TokenSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenAccessorSpecifierAndComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var comma: TokenSyntax? {
    get {
      return data.child(at: 11, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 11, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenCommaAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 12, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 12, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arguments: DifferentiabilityWithRespectToArgumentSyntax? {
    get {
      return data.child(at: 13, parent: Syntax(self)).map(DifferentiabilityWithRespectToArgumentSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 13, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 14, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DerivativeAttributeArgumentsSyntax(data.replacingChild(at: 14, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeOfLabel, 
          \Self.ofLabel, 
          \Self.unexpectedBetweenOfLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndOriginalDeclName, 
          \Self.originalDeclName, 
          \Self.unexpectedBetweenOriginalDeclNameAndPeriod, 
          \Self.period, 
          \Self.unexpectedBetweenPeriodAndAccessorSpecifier, 
          \Self.accessorSpecifier, 
          \Self.unexpectedBetweenAccessorSpecifierAndComma, 
          \Self.comma, 
          \Self.unexpectedBetweenCommaAndArguments, 
          \Self.arguments, 
          \Self.unexpectedAfterArguments
        ])
  }
}

// MARK: - DesignatedTypeSyntax

/// ### Children
/// 
///  - `leadingComma`: `','`
///  - `name`: ``TokenSyntax``
///
/// ### Contained in
/// 
///  - ``DesignatedTypeListSyntax``
public struct DesignatedTypeSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .designatedType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DesignatedTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .designatedType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeadingComma: UnexpectedNodesSyntax? = nil,
      leadingComma: TokenSyntax = .commaToken(),
      _ unexpectedBetweenLeadingCommaAndName: UnexpectedNodesSyntax? = nil,
      name: TokenSyntax,
      _ unexpectedAfterName: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeadingComma, 
            leadingComma, 
            unexpectedBetweenLeadingCommaAndName, 
            name, 
            unexpectedAfterName
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeadingComma?.raw, 
          leadingComma.raw, 
          unexpectedBetweenLeadingCommaAndName?.raw, 
          name.raw, 
          unexpectedAfterName?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.designatedType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeadingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DesignatedTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leadingComma: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DesignatedTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeadingCommaAndName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DesignatedTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var name: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DesignatedTypeSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DesignatedTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeadingComma, 
          \Self.leadingComma, 
          \Self.unexpectedBetweenLeadingCommaAndName, 
          \Self.name, 
          \Self.unexpectedAfterName
        ])
  }
}

// MARK: - DictionaryElementSyntax

/// ### Children
/// 
///  - `key`: ``ExprSyntax``
///  - `colon`: `':'`
///  - `value`: ``ExprSyntax``
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``DictionaryElementListSyntax``
public struct DictionaryElementSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .dictionaryElement else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DictionaryElementSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .dictionaryElement)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeKey: UnexpectedNodesSyntax? = nil,
      key: some ExprSyntaxProtocol,
      _ unexpectedBetweenKeyAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? = nil,
      value: some ExprSyntaxProtocol,
      _ unexpectedBetweenValueAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeKey, 
            key, 
            unexpectedBetweenKeyAndColon, 
            colon, 
            unexpectedBetweenColonAndValue, 
            value, 
            unexpectedBetweenValueAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeKey?.raw, 
          key.raw, 
          unexpectedBetweenKeyAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndValue?.raw, 
          value.raw, 
          unexpectedBetweenValueAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.dictionaryElement,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeKey: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryElementSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var key: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryElementSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenKeyAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryElementSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryElementSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryElementSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var value: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryElementSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenValueAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryElementSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DictionaryElementSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryElementSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeKey, 
          \Self.key, 
          \Self.unexpectedBetweenKeyAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndValue, 
          \Self.value, 
          \Self.unexpectedBetweenValueAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - DictionaryExprSyntax

/// ### Children
/// 
///  - `leftSquare`: `'['`
///  - `content`: (`':'` | ``DictionaryElementListSyntax``)
///  - `rightSquare`: `']'`
public struct DictionaryExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public enum Content: SyntaxChildChoices, SyntaxHashable {
    case `colon`(TokenSyntax)
    case `elements`(DictionaryElementListSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .colon(let node):
        return node._syntaxNode
      case .elements(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: TokenSyntax) {
      self = .colon(node)
    }
    
    public init(_ node: DictionaryElementListSyntax) {
      self = .elements(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(TokenSyntax.self) {
        self = .colon(node)
        return
      }
      if let node = node.as(DictionaryElementListSyntax.self) {
        self = .elements(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(TokenSyntax.self), .node(DictionaryElementListSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .dictionaryExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DictionaryExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .dictionaryExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? = nil,
      leftSquare: TokenSyntax = .leftSquareToken(),
      _ unexpectedBetweenLeftSquareAndContent: UnexpectedNodesSyntax? = nil,
      content: Content,
      _ unexpectedBetweenContentAndRightSquare: UnexpectedNodesSyntax? = nil,
      rightSquare: TokenSyntax = .rightSquareToken(),
      _ unexpectedAfterRightSquare: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftSquare, 
            leftSquare, 
            unexpectedBetweenLeftSquareAndContent, 
            content, 
            unexpectedBetweenContentAndRightSquare, 
            rightSquare, 
            unexpectedAfterRightSquare
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftSquare?.raw, 
          leftSquare.raw, 
          unexpectedBetweenLeftSquareAndContent?.raw, 
          content.raw, 
          unexpectedBetweenContentAndRightSquare?.raw, 
          rightSquare.raw, 
          unexpectedAfterRightSquare?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.dictionaryExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftSquareAndContent: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var content: Content {
    get {
      return Content(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenContentAndRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryExprSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftSquare, 
          \Self.leftSquare, 
          \Self.unexpectedBetweenLeftSquareAndContent, 
          \Self.content, 
          \Self.unexpectedBetweenContentAndRightSquare, 
          \Self.rightSquare, 
          \Self.unexpectedAfterRightSquare
        ])
  }
}

// MARK: - DictionaryTypeSyntax

/// ### Children
/// 
///  - `leftSquare`: `'['`
///  - `key`: ``TypeSyntax``
///  - `colon`: `':'`
///  - `value`: ``TypeSyntax``
///  - `rightSquare`: `']'`
public struct DictionaryTypeSyntax: TypeSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .dictionaryType else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DictionaryTypeSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .dictionaryType)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? = nil,
      leftSquare: TokenSyntax = .leftSquareToken(),
      _ unexpectedBetweenLeftSquareAndKey: UnexpectedNodesSyntax? = nil,
      key: some TypeSyntaxProtocol,
      _ unexpectedBetweenKeyAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? = nil,
      value: some TypeSyntaxProtocol,
      _ unexpectedBetweenValueAndRightSquare: UnexpectedNodesSyntax? = nil,
      rightSquare: TokenSyntax = .rightSquareToken(),
      _ unexpectedAfterRightSquare: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftSquare, 
            leftSquare, 
            unexpectedBetweenLeftSquareAndKey, 
            key, 
            unexpectedBetweenKeyAndColon, 
            colon, 
            unexpectedBetweenColonAndValue, 
            value, 
            unexpectedBetweenValueAndRightSquare, 
            rightSquare, 
            unexpectedAfterRightSquare
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftSquare?.raw, 
          leftSquare.raw, 
          unexpectedBetweenLeftSquareAndKey?.raw, 
          key.raw, 
          unexpectedBetweenKeyAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndValue?.raw, 
          value.raw, 
          unexpectedBetweenValueAndRightSquare?.raw, 
          rightSquare.raw, 
          unexpectedAfterRightSquare?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.dictionaryType,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftSquareAndKey: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var key: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenKeyAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var value: TypeSyntax {
    get {
      return TypeSyntax(data.child(at: 7, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 7, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenValueAndRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightSquare: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 9, parent: Syntax(self))!)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 9, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightSquare: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DictionaryTypeSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftSquare, 
          \Self.leftSquare, 
          \Self.unexpectedBetweenLeftSquareAndKey, 
          \Self.key, 
          \Self.unexpectedBetweenKeyAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndValue, 
          \Self.value, 
          \Self.unexpectedBetweenValueAndRightSquare, 
          \Self.rightSquare, 
          \Self.unexpectedAfterRightSquare
        ])
  }
}

// MARK: - DifferentiabilityArgumentSyntax

/// A differentiability argument: either the "self" identifier, a function parameter name, or a function parameter index.
///
/// ### Children
/// 
///  - `argument`: (`<identifier>` | `<integerLiteral>` | `'self'`)
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``DifferentiabilityArgumentListSyntax``
///  - ``DifferentiabilityWithRespectToArgumentSyntax``.``DifferentiabilityWithRespectToArgumentSyntax/arguments``
public struct DifferentiabilityArgumentSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .differentiabilityArgument else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DifferentiabilityArgumentSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .differentiabilityArgument)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeArgument: UnexpectedNodesSyntax? = nil,
      argument: TokenSyntax,
      _ unexpectedBetweenArgumentAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeArgument, 
            argument, 
            unexpectedBetweenArgumentAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeArgument?.raw, 
          argument.raw, 
          unexpectedBetweenArgumentAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.differentiabilityArgument,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeArgument: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityArgumentSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var argument: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DifferentiabilityArgumentSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenArgumentAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityArgumentSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DifferentiabilityArgumentSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityArgumentSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeArgument, 
          \Self.argument, 
          \Self.unexpectedBetweenArgumentAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - DifferentiabilityArgumentsSyntax

/// The differentiability arguments.
///
/// ### Children
/// 
///  - `leftParen`: `'('`
///  - `arguments`: ``DifferentiabilityArgumentListSyntax``
///  - `rightParen`: `')'`
///
/// ### Contained in
/// 
///  - ``DifferentiabilityWithRespectToArgumentSyntax``.``DifferentiabilityWithRespectToArgumentSyntax/arguments``
public struct DifferentiabilityArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .differentiabilityArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DifferentiabilityArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .differentiabilityArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - arguments: The parameters for differentiation.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLeftParen: UnexpectedNodesSyntax? = nil,
      leftParen: TokenSyntax = .leftParenToken(),
      _ unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: DifferentiabilityArgumentListSyntax,
      _ unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? = nil,
      rightParen: TokenSyntax = .rightParenToken(),
      _ unexpectedAfterRightParen: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLeftParen, 
            leftParen, 
            unexpectedBetweenLeftParenAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndRightParen, 
            rightParen, 
            unexpectedAfterRightParen
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLeftParen?.raw, 
          leftParen.raw, 
          unexpectedBetweenLeftParenAndArguments?.raw, 
          arguments.raw, 
          unexpectedBetweenArgumentsAndRightParen?.raw, 
          rightParen.raw, 
          unexpectedAfterRightParen?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.differentiabilityArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLeftParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var leftParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DifferentiabilityArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLeftParenAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The parameters for differentiation.
  public var arguments: DifferentiabilityArgumentListSyntax {
    get {
      return DifferentiabilityArgumentListSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DifferentiabilityArgumentsSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `arguments`
  /// collection.
  ///
  /// - param element: The new `Argument` to add to the node's
  ///                  `arguments` collection.
  /// - returns: A copy of the receiver with the provided `Argument`
  ///            appended to its `arguments` collection.
  @available(*, deprecated, message: "Use node.arguments.append(newElement) instead")
  public func addArgument(_ element: DifferentiabilityArgumentSyntax) -> DifferentiabilityArgumentsSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[3] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.differentiabilityArgumentList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 3, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return DifferentiabilityArgumentsSyntax(newData)
  }
  
  public var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var rightParen: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DifferentiabilityArgumentsSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterRightParen: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLeftParen, 
          \Self.leftParen, 
          \Self.unexpectedBetweenLeftParenAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndRightParen, 
          \Self.rightParen, 
          \Self.unexpectedAfterRightParen
        ])
  }
}

// MARK: - DifferentiabilityWithRespectToArgumentSyntax

/// A clause containing differentiability parameters.
///
/// ### Children
/// 
///  - `wrtLabel`: `'wrt'`
///  - `colon`: `':'`
///  - `arguments`: (``DifferentiabilityArgumentSyntax`` | ``DifferentiabilityArgumentsSyntax``)
///
/// ### Contained in
/// 
///  - ``DerivativeAttributeArgumentsSyntax``.``DerivativeAttributeArgumentsSyntax/arguments``
///  - ``DifferentiableAttributeArgumentsSyntax``.``DifferentiableAttributeArgumentsSyntax/arguments``
public struct DifferentiabilityWithRespectToArgumentSyntax: SyntaxProtocol, SyntaxHashable {
  public enum Arguments: SyntaxChildChoices, SyntaxHashable {
    case `argument`(DifferentiabilityArgumentSyntax)
    case `argumentList`(DifferentiabilityArgumentsSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .argument(let node):
        return node._syntaxNode
      case .argumentList(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: DifferentiabilityArgumentSyntax) {
      self = .argument(node)
    }
    
    public init(_ node: DifferentiabilityArgumentsSyntax) {
      self = .argumentList(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(DifferentiabilityArgumentSyntax.self) {
        self = .argument(node)
        return
      }
      if let node = node.as(DifferentiabilityArgumentsSyntax.self) {
        self = .argumentList(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(DifferentiabilityArgumentSyntax.self), .node(DifferentiabilityArgumentsSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .differentiabilityWithRespectToArgument else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DifferentiabilityWithRespectToArgumentSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .differentiabilityWithRespectToArgument)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - wrtLabel: The "wrt" label.
  ///   - colon: The colon separating "wrt" and the parameter list.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWrtLabel: UnexpectedNodesSyntax? = nil,
      wrtLabel: TokenSyntax = .keyword(.wrt),
      _ unexpectedBetweenWrtLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: Arguments,
      _ unexpectedAfterArguments: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeWrtLabel, 
            wrtLabel, 
            unexpectedBetweenWrtLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndArguments, 
            arguments, 
            unexpectedAfterArguments
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeWrtLabel?.raw, 
          wrtLabel.raw, 
          unexpectedBetweenWrtLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndArguments?.raw, 
          arguments.raw, 
          unexpectedAfterArguments?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.differentiabilityWithRespectToArgument,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeWrtLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityWithRespectToArgumentSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The "wrt" label.
  public var wrtLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DifferentiabilityWithRespectToArgumentSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenWrtLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityWithRespectToArgumentSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The colon separating "wrt" and the parameter list.
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DifferentiabilityWithRespectToArgumentSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityWithRespectToArgumentSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arguments: Arguments {
    get {
      return Arguments(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DifferentiabilityWithRespectToArgumentSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiabilityWithRespectToArgumentSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeWrtLabel, 
          \Self.wrtLabel, 
          \Self.unexpectedBetweenWrtLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndArguments, 
          \Self.arguments, 
          \Self.unexpectedAfterArguments
        ])
  }
}

// MARK: - DifferentiableAttributeArgumentsSyntax

/// The arguments for the `@differentiable` attribute: an optional differentiability kind, an optional differentiability parameter clause, and an optional 'where' clause.
///
/// ### Children
/// 
///  - `kindSpecifier`: (`'_forward'` | `'reverse'` | `'_linear'`)?
///  - `kindSpecifierComma`: `','`?
///  - `arguments`: ``DifferentiabilityWithRespectToArgumentSyntax``?
///  - `argumentsComma`: `','`?
///  - `genericWhereClause`: ``GenericWhereClauseSyntax``?
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct DifferentiableAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .differentiableAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DifferentiableAttributeArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .differentiableAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - kindSpecifierComma: The comma following the differentiability kind, if it exists.
  ///   - argumentsComma: The comma following the differentiability arguments clause, if it exists.
  ///   - genericWhereClause: A `where` clause that places additional constraints on generic parameters like `where T: Differentiable`.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeKindSpecifier: UnexpectedNodesSyntax? = nil,
      kindSpecifier: TokenSyntax? = nil,
      _ unexpectedBetweenKindSpecifierAndKindSpecifierComma: UnexpectedNodesSyntax? = nil,
      kindSpecifierComma: TokenSyntax? = nil,
      _ unexpectedBetweenKindSpecifierCommaAndArguments: UnexpectedNodesSyntax? = nil,
      arguments: DifferentiabilityWithRespectToArgumentSyntax? = nil,
      _ unexpectedBetweenArgumentsAndArgumentsComma: UnexpectedNodesSyntax? = nil,
      argumentsComma: TokenSyntax? = nil,
      _ unexpectedBetweenArgumentsCommaAndGenericWhereClause: UnexpectedNodesSyntax? = nil,
      genericWhereClause: GenericWhereClauseSyntax? = nil,
      _ unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeKindSpecifier, 
            kindSpecifier, 
            unexpectedBetweenKindSpecifierAndKindSpecifierComma, 
            kindSpecifierComma, 
            unexpectedBetweenKindSpecifierCommaAndArguments, 
            arguments, 
            unexpectedBetweenArgumentsAndArgumentsComma, 
            argumentsComma, 
            unexpectedBetweenArgumentsCommaAndGenericWhereClause, 
            genericWhereClause, 
            unexpectedAfterGenericWhereClause
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeKindSpecifier?.raw, 
          kindSpecifier?.raw, 
          unexpectedBetweenKindSpecifierAndKindSpecifierComma?.raw, 
          kindSpecifierComma?.raw, 
          unexpectedBetweenKindSpecifierCommaAndArguments?.raw, 
          arguments?.raw, 
          unexpectedBetweenArgumentsAndArgumentsComma?.raw, 
          argumentsComma?.raw, 
          unexpectedBetweenArgumentsCommaAndGenericWhereClause?.raw, 
          genericWhereClause?.raw, 
          unexpectedAfterGenericWhereClause?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.differentiableAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeKindSpecifier: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var kindSpecifier: TokenSyntax? {
    get {
      return data.child(at: 1, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 1, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenKindSpecifierAndKindSpecifierComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The comma following the differentiability kind, if it exists.
  public var kindSpecifierComma: TokenSyntax? {
    get {
      return data.child(at: 3, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 3, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenKindSpecifierCommaAndArguments: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var arguments: DifferentiabilityWithRespectToArgumentSyntax? {
    get {
      return data.child(at: 5, parent: Syntax(self)).map(DifferentiabilityWithRespectToArgumentSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 5, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenArgumentsAndArgumentsComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// The comma following the differentiability arguments clause, if it exists.
  public var argumentsComma: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenArgumentsCommaAndGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A `where` clause that places additional constraints on generic parameters like `where T: Differentiable`.
  public var genericWhereClause: GenericWhereClauseSyntax? {
    get {
      return data.child(at: 9, parent: Syntax(self)).map(GenericWhereClauseSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 9, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterGenericWhereClause: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 10, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DifferentiableAttributeArgumentsSyntax(data.replacingChild(at: 10, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeKindSpecifier, 
          \Self.kindSpecifier, 
          \Self.unexpectedBetweenKindSpecifierAndKindSpecifierComma, 
          \Self.kindSpecifierComma, 
          \Self.unexpectedBetweenKindSpecifierCommaAndArguments, 
          \Self.arguments, 
          \Self.unexpectedBetweenArgumentsAndArgumentsComma, 
          \Self.argumentsComma, 
          \Self.unexpectedBetweenArgumentsCommaAndGenericWhereClause, 
          \Self.genericWhereClause, 
          \Self.unexpectedAfterGenericWhereClause
        ])
  }
}

// MARK: - DiscardAssignmentExprSyntax

/// ### Children
/// 
///  - `wildcard`: `'_'`
public struct DiscardAssignmentExprSyntax: ExprSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .discardAssignmentExpr else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DiscardAssignmentExprSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .discardAssignmentExpr)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeWildcard: UnexpectedNodesSyntax? = nil,
      wildcard: TokenSyntax = .wildcardToken(),
      _ unexpectedAfterWildcard: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (unexpectedBeforeWildcard, wildcard, unexpectedAfterWildcard))) { (arena, _) in
      let layout: [RawSyntax?] = [unexpectedBeforeWildcard?.raw, wildcard.raw, unexpectedAfterWildcard?.raw]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.discardAssignmentExpr,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeWildcard: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DiscardAssignmentExprSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var wildcard: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DiscardAssignmentExprSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterWildcard: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DiscardAssignmentExprSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([\Self.unexpectedBeforeWildcard, \Self.wildcard, \Self.unexpectedAfterWildcard])
  }
}

// MARK: - DiscardStmtSyntax

/// ### Children
/// 
///  - `discardKeyword`: `'discard'`
///  - `expression`: ``ExprSyntax``
public struct DiscardStmtSyntax: StmtSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .discardStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DiscardStmtSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .discardStmt)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeDiscardKeyword: UnexpectedNodesSyntax? = nil,
      discardKeyword: TokenSyntax = .keyword(.discard),
      _ unexpectedBetweenDiscardKeywordAndExpression: UnexpectedNodesSyntax? = nil,
      expression: some ExprSyntaxProtocol,
      _ unexpectedAfterExpression: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeDiscardKeyword, 
            discardKeyword, 
            unexpectedBetweenDiscardKeywordAndExpression, 
            expression, 
            unexpectedAfterExpression
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeDiscardKeyword?.raw, 
          discardKeyword.raw, 
          unexpectedBetweenDiscardKeywordAndExpression?.raw, 
          expression.raw, 
          unexpectedAfterExpression?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.discardStmt,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeDiscardKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DiscardStmtSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var discardKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DiscardStmtSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDiscardKeywordAndExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DiscardStmtSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var expression: ExprSyntax {
    get {
      return ExprSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DiscardStmtSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterExpression: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DiscardStmtSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeDiscardKeyword, 
          \Self.discardKeyword, 
          \Self.unexpectedBetweenDiscardKeywordAndExpression, 
          \Self.expression, 
          \Self.unexpectedAfterExpression
        ])
  }
}

// MARK: - DoStmtSyntax

/// ### Children
/// 
///  - `doKeyword`: `'do'`
///  - `body`: ``CodeBlockSyntax``
///  - `catchClauses`: ``CatchClauseListSyntax``
public struct DoStmtSyntax: StmtSyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .doStmt else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DoStmtSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .doStmt)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeDoKeyword: UnexpectedNodesSyntax? = nil,
      doKeyword: TokenSyntax = .keyword(.do),
      _ unexpectedBetweenDoKeywordAndBody: UnexpectedNodesSyntax? = nil,
      body: CodeBlockSyntax,
      _ unexpectedBetweenBodyAndCatchClauses: UnexpectedNodesSyntax? = nil,
      catchClauses: CatchClauseListSyntax = [],
      _ unexpectedAfterCatchClauses: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeDoKeyword, 
            doKeyword, 
            unexpectedBetweenDoKeywordAndBody, 
            body, 
            unexpectedBetweenBodyAndCatchClauses, 
            catchClauses, 
            unexpectedAfterCatchClauses
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeDoKeyword?.raw, 
          doKeyword.raw, 
          unexpectedBetweenDoKeywordAndBody?.raw, 
          body.raw, 
          unexpectedBetweenBodyAndCatchClauses?.raw, 
          catchClauses.raw, 
          unexpectedAfterCatchClauses?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.doStmt,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeDoKeyword: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DoStmtSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var doKeyword: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DoStmtSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenDoKeywordAndBody: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DoStmtSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var body: CodeBlockSyntax {
    get {
      return CodeBlockSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DoStmtSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenBodyAndCatchClauses: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DoStmtSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var catchClauses: CatchClauseListSyntax {
    get {
      return CatchClauseListSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DoStmtSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  /// Adds the provided `element` to the node's `catchClauses`
  /// collection.
  ///
  /// - param element: The new `CatchClause` to add to the node's
  ///                  `catchClauses` collection.
  /// - returns: A copy of the receiver with the provided `CatchClause`
  ///            appended to its `catchClauses` collection.
  @available(*, deprecated, message: "Use node.catchClauses.append(newElement) instead")
  public func addCatchClause(_ element: CatchClauseSyntax) -> DoStmtSyntax {
    var collection: RawSyntax
    let arena = SyntaxArena()
    if let col = raw.layoutView!.children[5] {
      collection = col.layoutView!.appending(element.raw, arena: arena)
    } else {
      collection = RawSyntax.makeLayout(kind: SyntaxKind.catchClauseList,
                                        from: [element.raw], arena: arena)
    }
    let newData = data.replacingChild(
        at: 5, 
        with: collection, 
        rawNodeArena: arena, 
        allocationArena: arena
      )
    return DoStmtSyntax(newData)
  }
  
  public var unexpectedAfterCatchClauses: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DoStmtSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeDoKeyword, 
          \Self.doKeyword, 
          \Self.unexpectedBetweenDoKeywordAndBody, 
          \Self.body, 
          \Self.unexpectedBetweenBodyAndCatchClauses, 
          \Self.catchClauses, 
          \Self.unexpectedAfterCatchClauses
        ])
  }
}

// MARK: - DocumentationAttributeArgumentSyntax

/// ### Children
/// 
///  - `label`: (`'visibility'` | `'metadata'`)
///  - `colon`: `':'`
///  - `value`: ((`<identifier>` | `'private'` | `'fileprivate'` | `'internal'` | `'public'` | `'open'`) | ``StringLiteralExprSyntax``)
///  - `trailingComma`: `','`?
///
/// ### Contained in
/// 
///  - ``DocumentationAttributeArgumentListSyntax``
public struct DocumentationAttributeArgumentSyntax: SyntaxProtocol, SyntaxHashable {
  public enum Value: SyntaxChildChoices, SyntaxHashable {
    case `token`(TokenSyntax)
    case `string`(StringLiteralExprSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .token(let node):
        return node._syntaxNode
      case .string(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: TokenSyntax) {
      self = .token(node)
    }
    
    public init(_ node: StringLiteralExprSyntax) {
      self = .string(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(TokenSyntax.self) {
        self = .token(node)
        return
      }
      if let node = node.as(StringLiteralExprSyntax.self) {
        self = .string(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([.node(TokenSyntax.self), .node(StringLiteralExprSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .documentationAttributeArgument else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DocumentationAttributeArgumentSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .documentationAttributeArgument)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingComma: A trailing comma if this argument is followed by another one
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeLabel: UnexpectedNodesSyntax? = nil,
      label: TokenSyntax,
      _ unexpectedBetweenLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? = nil,
      value: Value,
      _ unexpectedBetweenValueAndTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingComma: TokenSyntax? = nil,
      _ unexpectedAfterTrailingComma: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeLabel, 
            label, 
            unexpectedBetweenLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndValue, 
            value, 
            unexpectedBetweenValueAndTrailingComma, 
            trailingComma, 
            unexpectedAfterTrailingComma
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeLabel?.raw, 
          label.raw, 
          unexpectedBetweenLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndValue?.raw, 
          value.raw, 
          unexpectedBetweenValueAndTrailingComma?.raw, 
          trailingComma?.raw, 
          unexpectedAfterTrailingComma?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.documentationAttributeArgument,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DocumentationAttributeArgumentSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var label: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DocumentationAttributeArgumentSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DocumentationAttributeArgumentSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DocumentationAttributeArgumentSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndValue: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DocumentationAttributeArgumentSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var value: Value {
    get {
      return Value(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DocumentationAttributeArgumentSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenValueAndTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DocumentationAttributeArgumentSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  /// A trailing comma if this argument is followed by another one
  public var trailingComma: TokenSyntax? {
    get {
      return data.child(at: 7, parent: Syntax(self)).map(TokenSyntax.init)
    }
    set(value) {
      self = DocumentationAttributeArgumentSyntax(data.replacingChild(at: 7, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterTrailingComma: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 8, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DocumentationAttributeArgumentSyntax(data.replacingChild(at: 8, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeLabel, 
          \Self.label, 
          \Self.unexpectedBetweenLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndValue, 
          \Self.value, 
          \Self.unexpectedBetweenValueAndTrailingComma, 
          \Self.trailingComma, 
          \Self.unexpectedAfterTrailingComma
        ])
  }
}

// MARK: - DynamicReplacementAttributeArgumentsSyntax

/// The arguments for the '@_dynamicReplacement' attribute
///
/// ### Children
/// 
///  - `forLabel`: `'for'`
///  - `colon`: `':'`
///  - `declName`: ``DeclReferenceExprSyntax``
///
/// ### Contained in
/// 
///  - ``AttributeSyntax``.``AttributeSyntax/arguments``
public struct DynamicReplacementAttributeArgumentsSyntax: SyntaxProtocol, SyntaxHashable {
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .dynamicReplacementAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  /// Creates a ``DynamicReplacementAttributeArgumentsSyntax`` node from the given ``SyntaxData``. 
  ///
  ///  - Warning: This assumes that the `SyntaxData` is of the correct kind.
  ///    If it is not, the behaviour is undefined.
  internal init(_ data: SyntaxData) {
    precondition(data.raw.kind == .dynamicReplacementAttributeArguments)
    self._syntaxNode = Syntax(data)
  }
  
  /// - Parameters:
  ///   - leadingTrivia: Trivia to be prepended to the leading trivia of the node’s first token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  ///   - trailingTrivia: Trivia to be appended to the trailing trivia of the node’s last token. If the node is empty, there is no token to attach the trivia to and the parameter is ignored.
  public init(
      leadingTrivia: Trivia? = nil,
      _ unexpectedBeforeForLabel: UnexpectedNodesSyntax? = nil,
      forLabel: TokenSyntax = .keyword(.for),
      _ unexpectedBetweenForLabelAndColon: UnexpectedNodesSyntax? = nil,
      colon: TokenSyntax = .colonToken(),
      _ unexpectedBetweenColonAndDeclName: UnexpectedNodesSyntax? = nil,
      declName: DeclReferenceExprSyntax,
      _ unexpectedAfterDeclName: UnexpectedNodesSyntax? = nil,
      trailingTrivia: Trivia? = nil
    
  ) {
    // Extend the lifetime of all parameters so their arenas don't get destroyed
    // before they can be added as children of the new arena.
    let data: SyntaxData = withExtendedLifetime((SyntaxArena(), (
            unexpectedBeforeForLabel, 
            forLabel, 
            unexpectedBetweenForLabelAndColon, 
            colon, 
            unexpectedBetweenColonAndDeclName, 
            declName, 
            unexpectedAfterDeclName
          ))) { (arena, _) in
      let layout: [RawSyntax?] = [
          unexpectedBeforeForLabel?.raw, 
          forLabel.raw, 
          unexpectedBetweenForLabelAndColon?.raw, 
          colon.raw, 
          unexpectedBetweenColonAndDeclName?.raw, 
          declName.raw, 
          unexpectedAfterDeclName?.raw
        ]
      let raw = RawSyntax.makeLayout(
        kind: SyntaxKind.dynamicReplacementAttributeArguments,
        from: layout,
        arena: arena,
        leadingTrivia: leadingTrivia,
        trailingTrivia: trailingTrivia
        
      )
      return SyntaxData.forRoot(raw, rawNodeArena: arena)
    }
    self.init(data)
  }
  
  public var unexpectedBeforeForLabel: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 0, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DynamicReplacementAttributeArgumentsSyntax(data.replacingChild(at: 0, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var forLabel: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 1, parent: Syntax(self))!)
    }
    set(value) {
      self = DynamicReplacementAttributeArgumentsSyntax(data.replacingChild(at: 1, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenForLabelAndColon: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 2, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DynamicReplacementAttributeArgumentsSyntax(data.replacingChild(at: 2, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var colon: TokenSyntax {
    get {
      return TokenSyntax(data.child(at: 3, parent: Syntax(self))!)
    }
    set(value) {
      self = DynamicReplacementAttributeArgumentsSyntax(data.replacingChild(at: 3, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedBetweenColonAndDeclName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 4, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DynamicReplacementAttributeArgumentsSyntax(data.replacingChild(at: 4, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public var declName: DeclReferenceExprSyntax {
    get {
      return DeclReferenceExprSyntax(data.child(at: 5, parent: Syntax(self))!)
    }
    set(value) {
      self = DynamicReplacementAttributeArgumentsSyntax(data.replacingChild(at: 5, with: value.data, arena: SyntaxArena()))
    }
  }
  
  public var unexpectedAfterDeclName: UnexpectedNodesSyntax? {
    get {
      return data.child(at: 6, parent: Syntax(self)).map(UnexpectedNodesSyntax.init)
    }
    set(value) {
      self = DynamicReplacementAttributeArgumentsSyntax(data.replacingChild(at: 6, with: value?.data, arena: SyntaxArena()))
    }
  }
  
  public static var structure: SyntaxNodeStructure {
    return .layout([
          \Self.unexpectedBeforeForLabel, 
          \Self.forLabel, 
          \Self.unexpectedBetweenForLabelAndColon, 
          \Self.colon, 
          \Self.unexpectedBetweenColonAndDeclName, 
          \Self.declName, 
          \Self.unexpectedAfterDeclName
        ])
  }
}
