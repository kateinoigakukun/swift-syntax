//// Automatically generated by generate-swiftsyntax
//// Do not edit directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//


public struct AccessorListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = AccessorDeclSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .accessorList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.accessorList
}

public struct ArrayElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ArrayElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .arrayElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.arrayElementList
}

public struct AttributeListSyntax: SyntaxCollection, SyntaxHashable {
  public enum Element: SyntaxChildChoices {
    case `attribute`(AttributeSyntax)
    case `ifConfigDecl`(IfConfigDeclSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .attribute(let node):
        return node._syntaxNode
      case .ifConfigDecl(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: AttributeSyntax) {
      self = .attribute(node)
    }
    
    public init(_ node: IfConfigDeclSyntax) {
      self = .ifConfigDecl(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(AttributeSyntax.self) {
        self = .attribute(node)
        return
      }
      if let node = node.as(IfConfigDeclSyntax.self) {
        self = .ifConfigDecl(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
          .node(AttributeSyntax.self),
          .node(IfConfigDeclSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .attributeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.attributeList
}

public struct AvailabilitySpecListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = AvailabilityArgumentSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .availabilitySpecList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.availabilitySpecList
}

public struct AvailabilityVersionRestrictionListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = AvailabilityVersionRestrictionListEntrySyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .availabilityVersionRestrictionList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.availabilityVersionRestrictionList
}

public struct CaseItemListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CaseItemSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .caseItemList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.caseItemList
}

public struct CatchClauseListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CatchClauseSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .catchClauseList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.catchClauseList
}

public struct CatchItemListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CatchItemSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .catchItemList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.catchItemList
}

public struct ClosureCaptureItemListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ClosureCaptureItemSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureCaptureItemList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.closureCaptureItemList
}

public struct ClosureParamListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ClosureParamSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureParamList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.closureParamList
}

public struct ClosureParameterListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ClosureParameterSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .closureParameterList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.closureParameterList
}

public struct CodeBlockItemListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CodeBlockItemSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .codeBlockItemList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.codeBlockItemList
}

public struct CompositionTypeElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = CompositionTypeElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .compositionTypeElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.compositionTypeElementList
}

public struct ConditionElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ConditionElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .conditionElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.conditionElementList
}

public struct DeclNameArgumentListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DeclNameArgumentSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .declNameArgumentList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.declNameArgumentList
}

public struct DesignatedTypeListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DesignatedTypeElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .designatedTypeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.designatedTypeList
}

public struct DictionaryElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DictionaryElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .dictionaryElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.dictionaryElementList
}

public struct DifferentiabilityParamListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DifferentiabilityParamSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .differentiabilityParamList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.differentiabilityParamList
}

/// The arguments of the '@_documentation' attribute
public struct DocumentationAttributeArgumentsSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DocumentationAttributeArgumentSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .documentationAttributeArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.documentationAttributeArguments
}

/// The arguments of the '@_effect' attribute. These will be parsed during the SIL stage.
public struct EffectsArgumentsSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = TokenSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .effectsArguments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.effectsArguments
}

/// A collection of 0 or more `EnumCaseElement`s.
public struct EnumCaseElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = EnumCaseElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .enumCaseElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.enumCaseElementList
}

public struct EnumCaseParameterListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = EnumCaseParameterSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .enumCaseParameterList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.enumCaseParameterList
}

/// A list of expressions connected by operators. This list is contained by a ``SequenceExprSyntax``.
public struct ExprListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ExprSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .exprList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.exprList
}

public struct FunctionParameterListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = FunctionParameterSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .functionParameterList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.functionParameterList
}

public struct GenericArgumentListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = GenericArgumentSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericArgumentList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.genericArgumentList
}

public struct GenericParameterListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = GenericParameterSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericParameterList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.genericParameterList
}

public struct GenericRequirementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = GenericRequirementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .genericRequirementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.genericRequirementList
}

public struct IfConfigClauseListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = IfConfigClauseSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .ifConfigClauseList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.ifConfigClauseList
}

public struct ImportPathSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ImportPathComponentSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .importPath else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.importPath
}

public struct InheritedTypeListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = InheritedTypeSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .inheritedTypeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.inheritedTypeList
}

public struct KeyPathComponentListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = KeyPathComponentSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .keyPathComponentList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.keyPathComponentList
}

public struct MemberDeclListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = MemberDeclListItemSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .memberDeclList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.memberDeclList
}

public struct ModifierListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = DeclModifierSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .modifierList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.modifierList
}

public struct MultipleTrailingClosureElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = MultipleTrailingClosureElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .multipleTrailingClosureElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.multipleTrailingClosureElementList
}

public struct ObjCSelectorSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = ObjCSelectorPieceSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .objCSelector else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.objCSelector
}

public struct PatternBindingListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = PatternBindingSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .patternBindingList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.patternBindingList
}

public struct PrecedenceGroupAttributeListSyntax: SyntaxCollection, SyntaxHashable {
  public enum Element: SyntaxChildChoices {
    case `precedenceGroupRelation`(PrecedenceGroupRelationSyntax)
    case `precedenceGroupAssignment`(PrecedenceGroupAssignmentSyntax)
    case `precedenceGroupAssociativity`(PrecedenceGroupAssociativitySyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .precedenceGroupRelation(let node):
        return node._syntaxNode
      case .precedenceGroupAssignment(let node):
        return node._syntaxNode
      case .precedenceGroupAssociativity(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: PrecedenceGroupRelationSyntax) {
      self = .precedenceGroupRelation(node)
    }
    
    public init(_ node: PrecedenceGroupAssignmentSyntax) {
      self = .precedenceGroupAssignment(node)
    }
    
    public init(_ node: PrecedenceGroupAssociativitySyntax) {
      self = .precedenceGroupAssociativity(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(PrecedenceGroupRelationSyntax.self) {
        self = .precedenceGroupRelation(node)
        return
      }
      if let node = node.as(PrecedenceGroupAssignmentSyntax.self) {
        self = .precedenceGroupAssignment(node)
        return
      }
      if let node = node.as(PrecedenceGroupAssociativitySyntax.self) {
        self = .precedenceGroupAssociativity(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
          .node(PrecedenceGroupRelationSyntax.self),
          .node(PrecedenceGroupAssignmentSyntax.self),
          .node(PrecedenceGroupAssociativitySyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .precedenceGroupAttributeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.precedenceGroupAttributeList
}

public struct PrecedenceGroupNameListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = PrecedenceGroupNameElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .precedenceGroupNameList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.precedenceGroupNameList
}

public struct PrimaryAssociatedTypeListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = PrimaryAssociatedTypeSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .primaryAssociatedTypeList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.primaryAssociatedTypeList
}

/// A collection of arguments for the `@_specialize` attribute
public struct SpecializeAttributeSpecListSyntax: SyntaxCollection, SyntaxHashable {
  public enum Element: SyntaxChildChoices {
    case `labeledSpecializeEntry`(LabeledSpecializeEntrySyntax)
    case `availabilityEntry`(AvailabilityEntrySyntax)
    case `targetFunctionEntry`(TargetFunctionEntrySyntax)
    case `genericWhereClause`(GenericWhereClauseSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .labeledSpecializeEntry(let node):
        return node._syntaxNode
      case .availabilityEntry(let node):
        return node._syntaxNode
      case .targetFunctionEntry(let node):
        return node._syntaxNode
      case .genericWhereClause(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: LabeledSpecializeEntrySyntax) {
      self = .labeledSpecializeEntry(node)
    }
    
    public init(_ node: AvailabilityEntrySyntax) {
      self = .availabilityEntry(node)
    }
    
    public init(_ node: TargetFunctionEntrySyntax) {
      self = .targetFunctionEntry(node)
    }
    
    public init(_ node: GenericWhereClauseSyntax) {
      self = .genericWhereClause(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(LabeledSpecializeEntrySyntax.self) {
        self = .labeledSpecializeEntry(node)
        return
      }
      if let node = node.as(AvailabilityEntrySyntax.self) {
        self = .availabilityEntry(node)
        return
      }
      if let node = node.as(TargetFunctionEntrySyntax.self) {
        self = .targetFunctionEntry(node)
        return
      }
      if let node = node.as(GenericWhereClauseSyntax.self) {
        self = .genericWhereClause(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
            .node(LabeledSpecializeEntrySyntax.self),
            .node(AvailabilityEntrySyntax.self),
            .node(TargetFunctionEntrySyntax.self),
            .node(GenericWhereClauseSyntax.self)
          ])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .specializeAttributeSpecList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.specializeAttributeSpecList
}

public struct StringLiteralSegmentsSyntax: SyntaxCollection, SyntaxHashable {
  public enum Element: SyntaxChildChoices {
    case `stringSegment`(StringSegmentSyntax)
    case `expressionSegment`(ExpressionSegmentSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .stringSegment(let node):
        return node._syntaxNode
      case .expressionSegment(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: StringSegmentSyntax) {
      self = .stringSegment(node)
    }
    
    public init(_ node: ExpressionSegmentSyntax) {
      self = .expressionSegment(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(StringSegmentSyntax.self) {
        self = .stringSegment(node)
        return
      }
      if let node = node.as(ExpressionSegmentSyntax.self) {
        self = .expressionSegment(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
          .node(StringSegmentSyntax.self),
          .node(ExpressionSegmentSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .stringLiteralSegments else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.stringLiteralSegments
}

public struct SwitchCaseListSyntax: SyntaxCollection, SyntaxHashable {
  public enum Element: SyntaxChildChoices {
    case `switchCase`(SwitchCaseSyntax)
    case `ifConfigDecl`(IfConfigDeclSyntax)
    
    public var _syntaxNode: Syntax {
      switch self {
      case .switchCase(let node):
        return node._syntaxNode
      case .ifConfigDecl(let node):
        return node._syntaxNode
      }
    }
    
    init(_ data: SyntaxData) {
      self.init(Syntax(data))!
    }
    
    public init(_ node: SwitchCaseSyntax) {
      self = .switchCase(node)
    }
    
    public init(_ node: IfConfigDeclSyntax) {
      self = .ifConfigDecl(node)
    }
    
    public init?(_ node: some SyntaxProtocol) {
      if let node = node.as(SwitchCaseSyntax.self) {
        self = .switchCase(node)
        return
      }
      if let node = node.as(IfConfigDeclSyntax.self) {
        self = .ifConfigDecl(node)
        return
      }
      return nil
    }
    
    public static var structure: SyntaxNodeStructure {
      return .choices([
          .node(SwitchCaseSyntax.self),
          .node(IfConfigDeclSyntax.self)])
    }
  }
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .switchCaseList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.switchCaseList
}

public struct TupleExprElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = TupleExprElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .tupleExprElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.tupleExprElementList
}

public struct TuplePatternElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = TuplePatternElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .tuplePatternElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.tuplePatternElementList
}

public struct TupleTypeElementListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = TupleTypeElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .tupleTypeElementList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.tupleTypeElementList
}

/// A collection of syntax nodes that occurred in the source code but could not be used to form a valid syntax tree.
public struct UnexpectedNodesSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = Syntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .unexpectedNodes else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.unexpectedNodes
}

public struct VersionComponentListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = VersionComponentSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .versionComponentList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.versionComponentList
}

public struct YieldExprListSyntax: SyntaxCollection, SyntaxHashable {
  public typealias Element = YieldExprListElementSyntax
  
  public let _syntaxNode: Syntax
  
  public init?(_ node: some SyntaxProtocol) {
    guard node.raw.kind == .yieldExprList else {
      return nil
    }
    self._syntaxNode = node._syntaxNode
  }
  
  public static let syntaxKind = SyntaxKind.yieldExprList
}
